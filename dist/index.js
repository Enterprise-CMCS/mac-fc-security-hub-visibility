/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 87351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(22037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 42186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(87351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(22037));
const path = __importStar(__nccwpck_require__(71017));
const oidc_utils_1 = __nccwpck_require__(98041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(81327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(81327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(57147));
const os = __importStar(__nccwpck_require__(22037));
const uuid_1 = __nccwpck_require__(75840);
const utils_1 = __nccwpck_require__(5278);
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 98041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(96255);
const auth_1 = __nccwpck_require__(35526);
const core_1 = __nccwpck_require__(42186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(71017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 81327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(22037);
const fs_1 = __nccwpck_require__(57147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 35526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 96255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(13685));
const https = __importStar(__nccwpck_require__(95687));
const pm = __importStar(__nccwpck_require__(19835));
const tunnel = __importStar(__nccwpck_require__(74294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 19835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
        return true;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperNoProxyItem === '*' ||
            upperReqHosts.some(x => x === upperNoProxyItem ||
                x.endsWith(`.${upperNoProxyItem}`) ||
                (upperNoProxyItem.startsWith('.') &&
                    x.endsWith(`${upperNoProxyItem}`)))) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return (hostLower === 'localhost' ||
        hostLower.startsWith('127.') ||
        hostLower.startsWith('[::1]') ||
        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));
}
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 32374:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwsCrc32 = void 0;
var tslib_1 = __nccwpck_require__(5066);
var util_1 = __nccwpck_require__(41236);
var index_1 = __nccwpck_require__(47327);
var AwsCrc32 = /** @class */ (function () {
    function AwsCrc32() {
        this.crc32 = new index_1.Crc32();
    }
    AwsCrc32.prototype.update = function (toHash) {
        if ((0, util_1.isEmptyData)(toHash))
            return;
        this.crc32.update((0, util_1.convertToBuffer)(toHash));
    };
    AwsCrc32.prototype.digest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, (0, util_1.numToUint8)(this.crc32.digest())];
            });
        });
    };
    AwsCrc32.prototype.reset = function () {
        this.crc32 = new index_1.Crc32();
    };
    return AwsCrc32;
}());
exports.AwsCrc32 = AwsCrc32;
//# sourceMappingURL=aws_crc32.js.map

/***/ }),

/***/ 47327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
var tslib_1 = __nccwpck_require__(5066);
var util_1 = __nccwpck_require__(41236);
function crc32(data) {
    return new Crc32().update(data).digest();
}
exports.crc32 = crc32;
var Crc32 = /** @class */ (function () {
    function Crc32() {
        this.checksum = 0xffffffff;
    }
    Crc32.prototype.update = function (data) {
        var e_1, _a;
        try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum =
                    (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    Crc32.prototype.digest = function () {
        return (this.checksum ^ 0xffffffff) >>> 0;
    };
    return Crc32;
}());
exports.Crc32 = Crc32;
// prettier-ignore
var a_lookUpTable = [
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
];
var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
var aws_crc32_1 = __nccwpck_require__(32374);
Object.defineProperty(exports, "AwsCrc32", ({ enumerable: true, get: function () { return aws_crc32_1.AwsCrc32; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5066:
/***/ ((module) => {

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __createBinding = function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
});


/***/ }),

/***/ 43228:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToBuffer = void 0;
var util_utf8_browser_1 = __nccwpck_require__(28172);
// Quick polyfill
var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from
    ? function (input) { return Buffer.from(input, "utf8"); }
    : util_utf8_browser_1.fromUtf8;
function convertToBuffer(data) {
    // Already a Uint8, do nothing
    if (data instanceof Uint8Array)
        return data;
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
}
exports.convertToBuffer = convertToBuffer;
//# sourceMappingURL=convertToBuffer.js.map

/***/ }),

/***/ 41236:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
var convertToBuffer_1 = __nccwpck_require__(43228);
Object.defineProperty(exports, "convertToBuffer", ({ enumerable: true, get: function () { return convertToBuffer_1.convertToBuffer; } }));
var isEmptyData_1 = __nccwpck_require__(18275);
Object.defineProperty(exports, "isEmptyData", ({ enumerable: true, get: function () { return isEmptyData_1.isEmptyData; } }));
var numToUint8_1 = __nccwpck_require__(93775);
Object.defineProperty(exports, "numToUint8", ({ enumerable: true, get: function () { return numToUint8_1.numToUint8; } }));
var uint32ArrayFrom_1 = __nccwpck_require__(39404);
Object.defineProperty(exports, "uint32ArrayFrom", ({ enumerable: true, get: function () { return uint32ArrayFrom_1.uint32ArrayFrom; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18275:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmptyData = void 0;
function isEmptyData(data) {
    if (typeof data === "string") {
        return data.length === 0;
    }
    return data.byteLength === 0;
}
exports.isEmptyData = isEmptyData;
//# sourceMappingURL=isEmptyData.js.map

/***/ }),

/***/ 93775:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numToUint8 = void 0;
function numToUint8(num) {
    return new Uint8Array([
        (num & 0xff000000) >> 24,
        (num & 0x00ff0000) >> 16,
        (num & 0x0000ff00) >> 8,
        num & 0x000000ff,
    ]);
}
exports.numToUint8 = numToUint8;
//# sourceMappingURL=numToUint8.js.map

/***/ }),

/***/ 39404:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32ArrayFrom = void 0;
// IE 11 does not support Array.from, so we do it manually
function uint32ArrayFrom(a_lookUpTable) {
    if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
        }
        return return_array;
    }
    return Uint32Array.from(a_lookUpTable);
}
exports.uint32ArrayFrom = uint32ArrayFrom;
//# sourceMappingURL=uint32ArrayFrom.js.map

/***/ }),

/***/ 44786:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IAM = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const AddClientIDToOpenIDConnectProviderCommand_1 = __nccwpck_require__(11629);
const AddRoleToInstanceProfileCommand_1 = __nccwpck_require__(12628);
const AddUserToGroupCommand_1 = __nccwpck_require__(62481);
const AttachGroupPolicyCommand_1 = __nccwpck_require__(1396);
const AttachRolePolicyCommand_1 = __nccwpck_require__(76859);
const AttachUserPolicyCommand_1 = __nccwpck_require__(34430);
const ChangePasswordCommand_1 = __nccwpck_require__(96427);
const CreateAccessKeyCommand_1 = __nccwpck_require__(22074);
const CreateAccountAliasCommand_1 = __nccwpck_require__(21038);
const CreateGroupCommand_1 = __nccwpck_require__(75510);
const CreateInstanceProfileCommand_1 = __nccwpck_require__(46601);
const CreateLoginProfileCommand_1 = __nccwpck_require__(9799);
const CreateOpenIDConnectProviderCommand_1 = __nccwpck_require__(21721);
const CreatePolicyCommand_1 = __nccwpck_require__(93380);
const CreatePolicyVersionCommand_1 = __nccwpck_require__(80886);
const CreateRoleCommand_1 = __nccwpck_require__(14199);
const CreateSAMLProviderCommand_1 = __nccwpck_require__(32287);
const CreateServiceLinkedRoleCommand_1 = __nccwpck_require__(95386);
const CreateServiceSpecificCredentialCommand_1 = __nccwpck_require__(80166);
const CreateUserCommand_1 = __nccwpck_require__(80728);
const CreateVirtualMFADeviceCommand_1 = __nccwpck_require__(82284);
const DeactivateMFADeviceCommand_1 = __nccwpck_require__(27998);
const DeleteAccessKeyCommand_1 = __nccwpck_require__(92064);
const DeleteAccountAliasCommand_1 = __nccwpck_require__(91961);
const DeleteAccountPasswordPolicyCommand_1 = __nccwpck_require__(73079);
const DeleteGroupCommand_1 = __nccwpck_require__(18409);
const DeleteGroupPolicyCommand_1 = __nccwpck_require__(90975);
const DeleteInstanceProfileCommand_1 = __nccwpck_require__(38672);
const DeleteLoginProfileCommand_1 = __nccwpck_require__(48912);
const DeleteOpenIDConnectProviderCommand_1 = __nccwpck_require__(66931);
const DeletePolicyCommand_1 = __nccwpck_require__(97547);
const DeletePolicyVersionCommand_1 = __nccwpck_require__(17282);
const DeleteRoleCommand_1 = __nccwpck_require__(39539);
const DeleteRolePermissionsBoundaryCommand_1 = __nccwpck_require__(3869);
const DeleteRolePolicyCommand_1 = __nccwpck_require__(40322);
const DeleteSAMLProviderCommand_1 = __nccwpck_require__(11643);
const DeleteServerCertificateCommand_1 = __nccwpck_require__(21672);
const DeleteServiceLinkedRoleCommand_1 = __nccwpck_require__(14177);
const DeleteServiceSpecificCredentialCommand_1 = __nccwpck_require__(57051);
const DeleteSigningCertificateCommand_1 = __nccwpck_require__(16723);
const DeleteSSHPublicKeyCommand_1 = __nccwpck_require__(76253);
const DeleteUserCommand_1 = __nccwpck_require__(17091);
const DeleteUserPermissionsBoundaryCommand_1 = __nccwpck_require__(82640);
const DeleteUserPolicyCommand_1 = __nccwpck_require__(72335);
const DeleteVirtualMFADeviceCommand_1 = __nccwpck_require__(29804);
const DetachGroupPolicyCommand_1 = __nccwpck_require__(64334);
const DetachRolePolicyCommand_1 = __nccwpck_require__(17300);
const DetachUserPolicyCommand_1 = __nccwpck_require__(80938);
const EnableMFADeviceCommand_1 = __nccwpck_require__(52607);
const GenerateCredentialReportCommand_1 = __nccwpck_require__(91102);
const GenerateOrganizationsAccessReportCommand_1 = __nccwpck_require__(12029);
const GenerateServiceLastAccessedDetailsCommand_1 = __nccwpck_require__(46151);
const GetAccessKeyLastUsedCommand_1 = __nccwpck_require__(29459);
const GetAccountAuthorizationDetailsCommand_1 = __nccwpck_require__(88568);
const GetAccountPasswordPolicyCommand_1 = __nccwpck_require__(27562);
const GetAccountSummaryCommand_1 = __nccwpck_require__(60674);
const GetContextKeysForCustomPolicyCommand_1 = __nccwpck_require__(98318);
const GetContextKeysForPrincipalPolicyCommand_1 = __nccwpck_require__(17595);
const GetCredentialReportCommand_1 = __nccwpck_require__(50430);
const GetGroupCommand_1 = __nccwpck_require__(85392);
const GetGroupPolicyCommand_1 = __nccwpck_require__(70566);
const GetInstanceProfileCommand_1 = __nccwpck_require__(27715);
const GetLoginProfileCommand_1 = __nccwpck_require__(91560);
const GetMFADeviceCommand_1 = __nccwpck_require__(68295);
const GetOpenIDConnectProviderCommand_1 = __nccwpck_require__(9699);
const GetOrganizationsAccessReportCommand_1 = __nccwpck_require__(81033);
const GetPolicyCommand_1 = __nccwpck_require__(1415);
const GetPolicyVersionCommand_1 = __nccwpck_require__(59856);
const GetRoleCommand_1 = __nccwpck_require__(82426);
const GetRolePolicyCommand_1 = __nccwpck_require__(83795);
const GetSAMLProviderCommand_1 = __nccwpck_require__(69224);
const GetServerCertificateCommand_1 = __nccwpck_require__(64462);
const GetServiceLastAccessedDetailsCommand_1 = __nccwpck_require__(62013);
const GetServiceLastAccessedDetailsWithEntitiesCommand_1 = __nccwpck_require__(93226);
const GetServiceLinkedRoleDeletionStatusCommand_1 = __nccwpck_require__(60283);
const GetSSHPublicKeyCommand_1 = __nccwpck_require__(34394);
const GetUserCommand_1 = __nccwpck_require__(79345);
const GetUserPolicyCommand_1 = __nccwpck_require__(58459);
const ListAccessKeysCommand_1 = __nccwpck_require__(97373);
const ListAccountAliasesCommand_1 = __nccwpck_require__(64599);
const ListAttachedGroupPoliciesCommand_1 = __nccwpck_require__(78313);
const ListAttachedRolePoliciesCommand_1 = __nccwpck_require__(79686);
const ListAttachedUserPoliciesCommand_1 = __nccwpck_require__(31818);
const ListEntitiesForPolicyCommand_1 = __nccwpck_require__(48813);
const ListGroupPoliciesCommand_1 = __nccwpck_require__(23819);
const ListGroupsCommand_1 = __nccwpck_require__(53646);
const ListGroupsForUserCommand_1 = __nccwpck_require__(29368);
const ListInstanceProfilesCommand_1 = __nccwpck_require__(90361);
const ListInstanceProfilesForRoleCommand_1 = __nccwpck_require__(36897);
const ListInstanceProfileTagsCommand_1 = __nccwpck_require__(58238);
const ListMFADevicesCommand_1 = __nccwpck_require__(30008);
const ListMFADeviceTagsCommand_1 = __nccwpck_require__(93043);
const ListOpenIDConnectProvidersCommand_1 = __nccwpck_require__(86834);
const ListOpenIDConnectProviderTagsCommand_1 = __nccwpck_require__(16844);
const ListPoliciesCommand_1 = __nccwpck_require__(8349);
const ListPoliciesGrantingServiceAccessCommand_1 = __nccwpck_require__(4982);
const ListPolicyTagsCommand_1 = __nccwpck_require__(60264);
const ListPolicyVersionsCommand_1 = __nccwpck_require__(92250);
const ListRolePoliciesCommand_1 = __nccwpck_require__(27265);
const ListRolesCommand_1 = __nccwpck_require__(86805);
const ListRoleTagsCommand_1 = __nccwpck_require__(37);
const ListSAMLProvidersCommand_1 = __nccwpck_require__(13333);
const ListSAMLProviderTagsCommand_1 = __nccwpck_require__(82416);
const ListServerCertificatesCommand_1 = __nccwpck_require__(75768);
const ListServerCertificateTagsCommand_1 = __nccwpck_require__(8474);
const ListServiceSpecificCredentialsCommand_1 = __nccwpck_require__(51167);
const ListSigningCertificatesCommand_1 = __nccwpck_require__(35966);
const ListSSHPublicKeysCommand_1 = __nccwpck_require__(34152);
const ListUserPoliciesCommand_1 = __nccwpck_require__(83440);
const ListUsersCommand_1 = __nccwpck_require__(94234);
const ListUserTagsCommand_1 = __nccwpck_require__(39245);
const ListVirtualMFADevicesCommand_1 = __nccwpck_require__(5950);
const PutGroupPolicyCommand_1 = __nccwpck_require__(41824);
const PutRolePermissionsBoundaryCommand_1 = __nccwpck_require__(60953);
const PutRolePolicyCommand_1 = __nccwpck_require__(80778);
const PutUserPermissionsBoundaryCommand_1 = __nccwpck_require__(88140);
const PutUserPolicyCommand_1 = __nccwpck_require__(41470);
const RemoveClientIDFromOpenIDConnectProviderCommand_1 = __nccwpck_require__(25733);
const RemoveRoleFromInstanceProfileCommand_1 = __nccwpck_require__(43694);
const RemoveUserFromGroupCommand_1 = __nccwpck_require__(45109);
const ResetServiceSpecificCredentialCommand_1 = __nccwpck_require__(56977);
const ResyncMFADeviceCommand_1 = __nccwpck_require__(19736);
const SetDefaultPolicyVersionCommand_1 = __nccwpck_require__(72457);
const SetSecurityTokenServicePreferencesCommand_1 = __nccwpck_require__(94251);
const SimulateCustomPolicyCommand_1 = __nccwpck_require__(48453);
const SimulatePrincipalPolicyCommand_1 = __nccwpck_require__(33979);
const TagInstanceProfileCommand_1 = __nccwpck_require__(35775);
const TagMFADeviceCommand_1 = __nccwpck_require__(55735);
const TagOpenIDConnectProviderCommand_1 = __nccwpck_require__(37781);
const TagPolicyCommand_1 = __nccwpck_require__(28972);
const TagRoleCommand_1 = __nccwpck_require__(12277);
const TagSAMLProviderCommand_1 = __nccwpck_require__(21060);
const TagServerCertificateCommand_1 = __nccwpck_require__(98317);
const TagUserCommand_1 = __nccwpck_require__(8867);
const UntagInstanceProfileCommand_1 = __nccwpck_require__(90945);
const UntagMFADeviceCommand_1 = __nccwpck_require__(31502);
const UntagOpenIDConnectProviderCommand_1 = __nccwpck_require__(49046);
const UntagPolicyCommand_1 = __nccwpck_require__(95074);
const UntagRoleCommand_1 = __nccwpck_require__(29045);
const UntagSAMLProviderCommand_1 = __nccwpck_require__(99473);
const UntagServerCertificateCommand_1 = __nccwpck_require__(39125);
const UntagUserCommand_1 = __nccwpck_require__(22643);
const UpdateAccessKeyCommand_1 = __nccwpck_require__(55768);
const UpdateAccountPasswordPolicyCommand_1 = __nccwpck_require__(48793);
const UpdateAssumeRolePolicyCommand_1 = __nccwpck_require__(35801);
const UpdateGroupCommand_1 = __nccwpck_require__(4047);
const UpdateLoginProfileCommand_1 = __nccwpck_require__(15832);
const UpdateOpenIDConnectProviderThumbprintCommand_1 = __nccwpck_require__(19509);
const UpdateRoleCommand_1 = __nccwpck_require__(85361);
const UpdateRoleDescriptionCommand_1 = __nccwpck_require__(18390);
const UpdateSAMLProviderCommand_1 = __nccwpck_require__(76652);
const UpdateServerCertificateCommand_1 = __nccwpck_require__(30474);
const UpdateServiceSpecificCredentialCommand_1 = __nccwpck_require__(60256);
const UpdateSigningCertificateCommand_1 = __nccwpck_require__(9457);
const UpdateSSHPublicKeyCommand_1 = __nccwpck_require__(49724);
const UpdateUserCommand_1 = __nccwpck_require__(18301);
const UploadServerCertificateCommand_1 = __nccwpck_require__(53344);
const UploadSigningCertificateCommand_1 = __nccwpck_require__(84118);
const UploadSSHPublicKeyCommand_1 = __nccwpck_require__(28168);
const IAMClient_1 = __nccwpck_require__(8652);
const commands = {
    AddClientIDToOpenIDConnectProviderCommand: AddClientIDToOpenIDConnectProviderCommand_1.AddClientIDToOpenIDConnectProviderCommand,
    AddRoleToInstanceProfileCommand: AddRoleToInstanceProfileCommand_1.AddRoleToInstanceProfileCommand,
    AddUserToGroupCommand: AddUserToGroupCommand_1.AddUserToGroupCommand,
    AttachGroupPolicyCommand: AttachGroupPolicyCommand_1.AttachGroupPolicyCommand,
    AttachRolePolicyCommand: AttachRolePolicyCommand_1.AttachRolePolicyCommand,
    AttachUserPolicyCommand: AttachUserPolicyCommand_1.AttachUserPolicyCommand,
    ChangePasswordCommand: ChangePasswordCommand_1.ChangePasswordCommand,
    CreateAccessKeyCommand: CreateAccessKeyCommand_1.CreateAccessKeyCommand,
    CreateAccountAliasCommand: CreateAccountAliasCommand_1.CreateAccountAliasCommand,
    CreateGroupCommand: CreateGroupCommand_1.CreateGroupCommand,
    CreateInstanceProfileCommand: CreateInstanceProfileCommand_1.CreateInstanceProfileCommand,
    CreateLoginProfileCommand: CreateLoginProfileCommand_1.CreateLoginProfileCommand,
    CreateOpenIDConnectProviderCommand: CreateOpenIDConnectProviderCommand_1.CreateOpenIDConnectProviderCommand,
    CreatePolicyCommand: CreatePolicyCommand_1.CreatePolicyCommand,
    CreatePolicyVersionCommand: CreatePolicyVersionCommand_1.CreatePolicyVersionCommand,
    CreateRoleCommand: CreateRoleCommand_1.CreateRoleCommand,
    CreateSAMLProviderCommand: CreateSAMLProviderCommand_1.CreateSAMLProviderCommand,
    CreateServiceLinkedRoleCommand: CreateServiceLinkedRoleCommand_1.CreateServiceLinkedRoleCommand,
    CreateServiceSpecificCredentialCommand: CreateServiceSpecificCredentialCommand_1.CreateServiceSpecificCredentialCommand,
    CreateUserCommand: CreateUserCommand_1.CreateUserCommand,
    CreateVirtualMFADeviceCommand: CreateVirtualMFADeviceCommand_1.CreateVirtualMFADeviceCommand,
    DeactivateMFADeviceCommand: DeactivateMFADeviceCommand_1.DeactivateMFADeviceCommand,
    DeleteAccessKeyCommand: DeleteAccessKeyCommand_1.DeleteAccessKeyCommand,
    DeleteAccountAliasCommand: DeleteAccountAliasCommand_1.DeleteAccountAliasCommand,
    DeleteAccountPasswordPolicyCommand: DeleteAccountPasswordPolicyCommand_1.DeleteAccountPasswordPolicyCommand,
    DeleteGroupCommand: DeleteGroupCommand_1.DeleteGroupCommand,
    DeleteGroupPolicyCommand: DeleteGroupPolicyCommand_1.DeleteGroupPolicyCommand,
    DeleteInstanceProfileCommand: DeleteInstanceProfileCommand_1.DeleteInstanceProfileCommand,
    DeleteLoginProfileCommand: DeleteLoginProfileCommand_1.DeleteLoginProfileCommand,
    DeleteOpenIDConnectProviderCommand: DeleteOpenIDConnectProviderCommand_1.DeleteOpenIDConnectProviderCommand,
    DeletePolicyCommand: DeletePolicyCommand_1.DeletePolicyCommand,
    DeletePolicyVersionCommand: DeletePolicyVersionCommand_1.DeletePolicyVersionCommand,
    DeleteRoleCommand: DeleteRoleCommand_1.DeleteRoleCommand,
    DeleteRolePermissionsBoundaryCommand: DeleteRolePermissionsBoundaryCommand_1.DeleteRolePermissionsBoundaryCommand,
    DeleteRolePolicyCommand: DeleteRolePolicyCommand_1.DeleteRolePolicyCommand,
    DeleteSAMLProviderCommand: DeleteSAMLProviderCommand_1.DeleteSAMLProviderCommand,
    DeleteServerCertificateCommand: DeleteServerCertificateCommand_1.DeleteServerCertificateCommand,
    DeleteServiceLinkedRoleCommand: DeleteServiceLinkedRoleCommand_1.DeleteServiceLinkedRoleCommand,
    DeleteServiceSpecificCredentialCommand: DeleteServiceSpecificCredentialCommand_1.DeleteServiceSpecificCredentialCommand,
    DeleteSigningCertificateCommand: DeleteSigningCertificateCommand_1.DeleteSigningCertificateCommand,
    DeleteSSHPublicKeyCommand: DeleteSSHPublicKeyCommand_1.DeleteSSHPublicKeyCommand,
    DeleteUserCommand: DeleteUserCommand_1.DeleteUserCommand,
    DeleteUserPermissionsBoundaryCommand: DeleteUserPermissionsBoundaryCommand_1.DeleteUserPermissionsBoundaryCommand,
    DeleteUserPolicyCommand: DeleteUserPolicyCommand_1.DeleteUserPolicyCommand,
    DeleteVirtualMFADeviceCommand: DeleteVirtualMFADeviceCommand_1.DeleteVirtualMFADeviceCommand,
    DetachGroupPolicyCommand: DetachGroupPolicyCommand_1.DetachGroupPolicyCommand,
    DetachRolePolicyCommand: DetachRolePolicyCommand_1.DetachRolePolicyCommand,
    DetachUserPolicyCommand: DetachUserPolicyCommand_1.DetachUserPolicyCommand,
    EnableMFADeviceCommand: EnableMFADeviceCommand_1.EnableMFADeviceCommand,
    GenerateCredentialReportCommand: GenerateCredentialReportCommand_1.GenerateCredentialReportCommand,
    GenerateOrganizationsAccessReportCommand: GenerateOrganizationsAccessReportCommand_1.GenerateOrganizationsAccessReportCommand,
    GenerateServiceLastAccessedDetailsCommand: GenerateServiceLastAccessedDetailsCommand_1.GenerateServiceLastAccessedDetailsCommand,
    GetAccessKeyLastUsedCommand: GetAccessKeyLastUsedCommand_1.GetAccessKeyLastUsedCommand,
    GetAccountAuthorizationDetailsCommand: GetAccountAuthorizationDetailsCommand_1.GetAccountAuthorizationDetailsCommand,
    GetAccountPasswordPolicyCommand: GetAccountPasswordPolicyCommand_1.GetAccountPasswordPolicyCommand,
    GetAccountSummaryCommand: GetAccountSummaryCommand_1.GetAccountSummaryCommand,
    GetContextKeysForCustomPolicyCommand: GetContextKeysForCustomPolicyCommand_1.GetContextKeysForCustomPolicyCommand,
    GetContextKeysForPrincipalPolicyCommand: GetContextKeysForPrincipalPolicyCommand_1.GetContextKeysForPrincipalPolicyCommand,
    GetCredentialReportCommand: GetCredentialReportCommand_1.GetCredentialReportCommand,
    GetGroupCommand: GetGroupCommand_1.GetGroupCommand,
    GetGroupPolicyCommand: GetGroupPolicyCommand_1.GetGroupPolicyCommand,
    GetInstanceProfileCommand: GetInstanceProfileCommand_1.GetInstanceProfileCommand,
    GetLoginProfileCommand: GetLoginProfileCommand_1.GetLoginProfileCommand,
    GetMFADeviceCommand: GetMFADeviceCommand_1.GetMFADeviceCommand,
    GetOpenIDConnectProviderCommand: GetOpenIDConnectProviderCommand_1.GetOpenIDConnectProviderCommand,
    GetOrganizationsAccessReportCommand: GetOrganizationsAccessReportCommand_1.GetOrganizationsAccessReportCommand,
    GetPolicyCommand: GetPolicyCommand_1.GetPolicyCommand,
    GetPolicyVersionCommand: GetPolicyVersionCommand_1.GetPolicyVersionCommand,
    GetRoleCommand: GetRoleCommand_1.GetRoleCommand,
    GetRolePolicyCommand: GetRolePolicyCommand_1.GetRolePolicyCommand,
    GetSAMLProviderCommand: GetSAMLProviderCommand_1.GetSAMLProviderCommand,
    GetServerCertificateCommand: GetServerCertificateCommand_1.GetServerCertificateCommand,
    GetServiceLastAccessedDetailsCommand: GetServiceLastAccessedDetailsCommand_1.GetServiceLastAccessedDetailsCommand,
    GetServiceLastAccessedDetailsWithEntitiesCommand: GetServiceLastAccessedDetailsWithEntitiesCommand_1.GetServiceLastAccessedDetailsWithEntitiesCommand,
    GetServiceLinkedRoleDeletionStatusCommand: GetServiceLinkedRoleDeletionStatusCommand_1.GetServiceLinkedRoleDeletionStatusCommand,
    GetSSHPublicKeyCommand: GetSSHPublicKeyCommand_1.GetSSHPublicKeyCommand,
    GetUserCommand: GetUserCommand_1.GetUserCommand,
    GetUserPolicyCommand: GetUserPolicyCommand_1.GetUserPolicyCommand,
    ListAccessKeysCommand: ListAccessKeysCommand_1.ListAccessKeysCommand,
    ListAccountAliasesCommand: ListAccountAliasesCommand_1.ListAccountAliasesCommand,
    ListAttachedGroupPoliciesCommand: ListAttachedGroupPoliciesCommand_1.ListAttachedGroupPoliciesCommand,
    ListAttachedRolePoliciesCommand: ListAttachedRolePoliciesCommand_1.ListAttachedRolePoliciesCommand,
    ListAttachedUserPoliciesCommand: ListAttachedUserPoliciesCommand_1.ListAttachedUserPoliciesCommand,
    ListEntitiesForPolicyCommand: ListEntitiesForPolicyCommand_1.ListEntitiesForPolicyCommand,
    ListGroupPoliciesCommand: ListGroupPoliciesCommand_1.ListGroupPoliciesCommand,
    ListGroupsCommand: ListGroupsCommand_1.ListGroupsCommand,
    ListGroupsForUserCommand: ListGroupsForUserCommand_1.ListGroupsForUserCommand,
    ListInstanceProfilesCommand: ListInstanceProfilesCommand_1.ListInstanceProfilesCommand,
    ListInstanceProfilesForRoleCommand: ListInstanceProfilesForRoleCommand_1.ListInstanceProfilesForRoleCommand,
    ListInstanceProfileTagsCommand: ListInstanceProfileTagsCommand_1.ListInstanceProfileTagsCommand,
    ListMFADevicesCommand: ListMFADevicesCommand_1.ListMFADevicesCommand,
    ListMFADeviceTagsCommand: ListMFADeviceTagsCommand_1.ListMFADeviceTagsCommand,
    ListOpenIDConnectProvidersCommand: ListOpenIDConnectProvidersCommand_1.ListOpenIDConnectProvidersCommand,
    ListOpenIDConnectProviderTagsCommand: ListOpenIDConnectProviderTagsCommand_1.ListOpenIDConnectProviderTagsCommand,
    ListPoliciesCommand: ListPoliciesCommand_1.ListPoliciesCommand,
    ListPoliciesGrantingServiceAccessCommand: ListPoliciesGrantingServiceAccessCommand_1.ListPoliciesGrantingServiceAccessCommand,
    ListPolicyTagsCommand: ListPolicyTagsCommand_1.ListPolicyTagsCommand,
    ListPolicyVersionsCommand: ListPolicyVersionsCommand_1.ListPolicyVersionsCommand,
    ListRolePoliciesCommand: ListRolePoliciesCommand_1.ListRolePoliciesCommand,
    ListRolesCommand: ListRolesCommand_1.ListRolesCommand,
    ListRoleTagsCommand: ListRoleTagsCommand_1.ListRoleTagsCommand,
    ListSAMLProvidersCommand: ListSAMLProvidersCommand_1.ListSAMLProvidersCommand,
    ListSAMLProviderTagsCommand: ListSAMLProviderTagsCommand_1.ListSAMLProviderTagsCommand,
    ListServerCertificatesCommand: ListServerCertificatesCommand_1.ListServerCertificatesCommand,
    ListServerCertificateTagsCommand: ListServerCertificateTagsCommand_1.ListServerCertificateTagsCommand,
    ListServiceSpecificCredentialsCommand: ListServiceSpecificCredentialsCommand_1.ListServiceSpecificCredentialsCommand,
    ListSigningCertificatesCommand: ListSigningCertificatesCommand_1.ListSigningCertificatesCommand,
    ListSSHPublicKeysCommand: ListSSHPublicKeysCommand_1.ListSSHPublicKeysCommand,
    ListUserPoliciesCommand: ListUserPoliciesCommand_1.ListUserPoliciesCommand,
    ListUsersCommand: ListUsersCommand_1.ListUsersCommand,
    ListUserTagsCommand: ListUserTagsCommand_1.ListUserTagsCommand,
    ListVirtualMFADevicesCommand: ListVirtualMFADevicesCommand_1.ListVirtualMFADevicesCommand,
    PutGroupPolicyCommand: PutGroupPolicyCommand_1.PutGroupPolicyCommand,
    PutRolePermissionsBoundaryCommand: PutRolePermissionsBoundaryCommand_1.PutRolePermissionsBoundaryCommand,
    PutRolePolicyCommand: PutRolePolicyCommand_1.PutRolePolicyCommand,
    PutUserPermissionsBoundaryCommand: PutUserPermissionsBoundaryCommand_1.PutUserPermissionsBoundaryCommand,
    PutUserPolicyCommand: PutUserPolicyCommand_1.PutUserPolicyCommand,
    RemoveClientIDFromOpenIDConnectProviderCommand: RemoveClientIDFromOpenIDConnectProviderCommand_1.RemoveClientIDFromOpenIDConnectProviderCommand,
    RemoveRoleFromInstanceProfileCommand: RemoveRoleFromInstanceProfileCommand_1.RemoveRoleFromInstanceProfileCommand,
    RemoveUserFromGroupCommand: RemoveUserFromGroupCommand_1.RemoveUserFromGroupCommand,
    ResetServiceSpecificCredentialCommand: ResetServiceSpecificCredentialCommand_1.ResetServiceSpecificCredentialCommand,
    ResyncMFADeviceCommand: ResyncMFADeviceCommand_1.ResyncMFADeviceCommand,
    SetDefaultPolicyVersionCommand: SetDefaultPolicyVersionCommand_1.SetDefaultPolicyVersionCommand,
    SetSecurityTokenServicePreferencesCommand: SetSecurityTokenServicePreferencesCommand_1.SetSecurityTokenServicePreferencesCommand,
    SimulateCustomPolicyCommand: SimulateCustomPolicyCommand_1.SimulateCustomPolicyCommand,
    SimulatePrincipalPolicyCommand: SimulatePrincipalPolicyCommand_1.SimulatePrincipalPolicyCommand,
    TagInstanceProfileCommand: TagInstanceProfileCommand_1.TagInstanceProfileCommand,
    TagMFADeviceCommand: TagMFADeviceCommand_1.TagMFADeviceCommand,
    TagOpenIDConnectProviderCommand: TagOpenIDConnectProviderCommand_1.TagOpenIDConnectProviderCommand,
    TagPolicyCommand: TagPolicyCommand_1.TagPolicyCommand,
    TagRoleCommand: TagRoleCommand_1.TagRoleCommand,
    TagSAMLProviderCommand: TagSAMLProviderCommand_1.TagSAMLProviderCommand,
    TagServerCertificateCommand: TagServerCertificateCommand_1.TagServerCertificateCommand,
    TagUserCommand: TagUserCommand_1.TagUserCommand,
    UntagInstanceProfileCommand: UntagInstanceProfileCommand_1.UntagInstanceProfileCommand,
    UntagMFADeviceCommand: UntagMFADeviceCommand_1.UntagMFADeviceCommand,
    UntagOpenIDConnectProviderCommand: UntagOpenIDConnectProviderCommand_1.UntagOpenIDConnectProviderCommand,
    UntagPolicyCommand: UntagPolicyCommand_1.UntagPolicyCommand,
    UntagRoleCommand: UntagRoleCommand_1.UntagRoleCommand,
    UntagSAMLProviderCommand: UntagSAMLProviderCommand_1.UntagSAMLProviderCommand,
    UntagServerCertificateCommand: UntagServerCertificateCommand_1.UntagServerCertificateCommand,
    UntagUserCommand: UntagUserCommand_1.UntagUserCommand,
    UpdateAccessKeyCommand: UpdateAccessKeyCommand_1.UpdateAccessKeyCommand,
    UpdateAccountPasswordPolicyCommand: UpdateAccountPasswordPolicyCommand_1.UpdateAccountPasswordPolicyCommand,
    UpdateAssumeRolePolicyCommand: UpdateAssumeRolePolicyCommand_1.UpdateAssumeRolePolicyCommand,
    UpdateGroupCommand: UpdateGroupCommand_1.UpdateGroupCommand,
    UpdateLoginProfileCommand: UpdateLoginProfileCommand_1.UpdateLoginProfileCommand,
    UpdateOpenIDConnectProviderThumbprintCommand: UpdateOpenIDConnectProviderThumbprintCommand_1.UpdateOpenIDConnectProviderThumbprintCommand,
    UpdateRoleCommand: UpdateRoleCommand_1.UpdateRoleCommand,
    UpdateRoleDescriptionCommand: UpdateRoleDescriptionCommand_1.UpdateRoleDescriptionCommand,
    UpdateSAMLProviderCommand: UpdateSAMLProviderCommand_1.UpdateSAMLProviderCommand,
    UpdateServerCertificateCommand: UpdateServerCertificateCommand_1.UpdateServerCertificateCommand,
    UpdateServiceSpecificCredentialCommand: UpdateServiceSpecificCredentialCommand_1.UpdateServiceSpecificCredentialCommand,
    UpdateSigningCertificateCommand: UpdateSigningCertificateCommand_1.UpdateSigningCertificateCommand,
    UpdateSSHPublicKeyCommand: UpdateSSHPublicKeyCommand_1.UpdateSSHPublicKeyCommand,
    UpdateUserCommand: UpdateUserCommand_1.UpdateUserCommand,
    UploadServerCertificateCommand: UploadServerCertificateCommand_1.UploadServerCertificateCommand,
    UploadSigningCertificateCommand: UploadSigningCertificateCommand_1.UploadSigningCertificateCommand,
    UploadSSHPublicKeyCommand: UploadSSHPublicKeyCommand_1.UploadSSHPublicKeyCommand,
};
class IAM extends IAMClient_1.IAMClient {
}
exports.IAM = IAM;
(0, smithy_client_1.createAggregatedClient)(commands, IAM);


/***/ }),

/***/ 8652:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IAMClient = exports.__Client = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const EndpointParameters_1 = __nccwpck_require__(9539);
const runtimeConfig_1 = __nccwpck_require__(14294);
class IAMClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.IAMClient = IAMClient;


/***/ }),

/***/ 11629:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddClientIDToOpenIDConnectProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class AddClientIDToOpenIDConnectProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AddClientIDToOpenIDConnectProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "AddClientIDToOpenIDConnectProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AddClientIDToOpenIDConnectProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AddClientIDToOpenIDConnectProviderCommand)(output, context);
    }
}
exports.AddClientIDToOpenIDConnectProviderCommand = AddClientIDToOpenIDConnectProviderCommand;


/***/ }),

/***/ 12628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddRoleToInstanceProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class AddRoleToInstanceProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AddRoleToInstanceProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "AddRoleToInstanceProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AddRoleToInstanceProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AddRoleToInstanceProfileCommand)(output, context);
    }
}
exports.AddRoleToInstanceProfileCommand = AddRoleToInstanceProfileCommand;


/***/ }),

/***/ 62481:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddUserToGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class AddUserToGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AddUserToGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "AddUserToGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AddUserToGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AddUserToGroupCommand)(output, context);
    }
}
exports.AddUserToGroupCommand = AddUserToGroupCommand;


/***/ }),

/***/ 1396:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttachGroupPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class AttachGroupPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AttachGroupPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "AttachGroupPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AttachGroupPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AttachGroupPolicyCommand)(output, context);
    }
}
exports.AttachGroupPolicyCommand = AttachGroupPolicyCommand;


/***/ }),

/***/ 76859:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttachRolePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class AttachRolePolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AttachRolePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "AttachRolePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AttachRolePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AttachRolePolicyCommand)(output, context);
    }
}
exports.AttachRolePolicyCommand = AttachRolePolicyCommand;


/***/ }),

/***/ 34430:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttachUserPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class AttachUserPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AttachUserPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "AttachUserPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AttachUserPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AttachUserPolicyCommand)(output, context);
    }
}
exports.AttachUserPolicyCommand = AttachUserPolicyCommand;


/***/ }),

/***/ 96427:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangePasswordCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(18824);
const Aws_query_1 = __nccwpck_require__(12786);
class ChangePasswordCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ChangePasswordCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ChangePasswordCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ChangePasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ChangePasswordCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ChangePasswordCommand)(output, context);
    }
}
exports.ChangePasswordCommand = ChangePasswordCommand;


/***/ }),

/***/ 22074:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateAccessKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(18824);
const Aws_query_1 = __nccwpck_require__(12786);
class CreateAccessKeyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateAccessKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateAccessKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: models_0_1.CreateAccessKeyResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateAccessKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateAccessKeyCommand)(output, context);
    }
}
exports.CreateAccessKeyCommand = CreateAccessKeyCommand;


/***/ }),

/***/ 21038:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateAccountAliasCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreateAccountAliasCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateAccountAliasCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateAccountAliasCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateAccountAliasCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateAccountAliasCommand)(output, context);
    }
}
exports.CreateAccountAliasCommand = CreateAccountAliasCommand;


/***/ }),

/***/ 75510:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreateGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateGroupCommand)(output, context);
    }
}
exports.CreateGroupCommand = CreateGroupCommand;


/***/ }),

/***/ 46601:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateInstanceProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreateInstanceProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateInstanceProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateInstanceProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateInstanceProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateInstanceProfileCommand)(output, context);
    }
}
exports.CreateInstanceProfileCommand = CreateInstanceProfileCommand;


/***/ }),

/***/ 9799:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateLoginProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(18824);
const Aws_query_1 = __nccwpck_require__(12786);
class CreateLoginProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateLoginProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateLoginProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateLoginProfileRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateLoginProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateLoginProfileCommand)(output, context);
    }
}
exports.CreateLoginProfileCommand = CreateLoginProfileCommand;


/***/ }),

/***/ 21721:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateOpenIDConnectProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreateOpenIDConnectProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateOpenIDConnectProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateOpenIDConnectProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateOpenIDConnectProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateOpenIDConnectProviderCommand)(output, context);
    }
}
exports.CreateOpenIDConnectProviderCommand = CreateOpenIDConnectProviderCommand;


/***/ }),

/***/ 93380:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreatePolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreatePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreatePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreatePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreatePolicyCommand)(output, context);
    }
}
exports.CreatePolicyCommand = CreatePolicyCommand;


/***/ }),

/***/ 80886:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePolicyVersionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreatePolicyVersionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreatePolicyVersionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreatePolicyVersionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreatePolicyVersionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreatePolicyVersionCommand)(output, context);
    }
}
exports.CreatePolicyVersionCommand = CreatePolicyVersionCommand;


/***/ }),

/***/ 14199:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreateRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateRoleCommand)(output, context);
    }
}
exports.CreateRoleCommand = CreateRoleCommand;


/***/ }),

/***/ 32287:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateSAMLProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreateSAMLProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateSAMLProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateSAMLProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateSAMLProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateSAMLProviderCommand)(output, context);
    }
}
exports.CreateSAMLProviderCommand = CreateSAMLProviderCommand;


/***/ }),

/***/ 95386:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateServiceLinkedRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreateServiceLinkedRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateServiceLinkedRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateServiceLinkedRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateServiceLinkedRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateServiceLinkedRoleCommand)(output, context);
    }
}
exports.CreateServiceLinkedRoleCommand = CreateServiceLinkedRoleCommand;


/***/ }),

/***/ 80166:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateServiceSpecificCredentialCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(18824);
const Aws_query_1 = __nccwpck_require__(12786);
class CreateServiceSpecificCredentialCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateServiceSpecificCredentialCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateServiceSpecificCredentialCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: models_0_1.CreateServiceSpecificCredentialResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateServiceSpecificCredentialCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateServiceSpecificCredentialCommand)(output, context);
    }
}
exports.CreateServiceSpecificCredentialCommand = CreateServiceSpecificCredentialCommand;


/***/ }),

/***/ 80728:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class CreateUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateUserCommand)(output, context);
    }
}
exports.CreateUserCommand = CreateUserCommand;


/***/ }),

/***/ 82284:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateVirtualMFADeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(18824);
const Aws_query_1 = __nccwpck_require__(12786);
class CreateVirtualMFADeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateVirtualMFADeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "CreateVirtualMFADeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: models_0_1.CreateVirtualMFADeviceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_CreateVirtualMFADeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_CreateVirtualMFADeviceCommand)(output, context);
    }
}
exports.CreateVirtualMFADeviceCommand = CreateVirtualMFADeviceCommand;


/***/ }),

/***/ 27998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeactivateMFADeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeactivateMFADeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeactivateMFADeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeactivateMFADeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeactivateMFADeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeactivateMFADeviceCommand)(output, context);
    }
}
exports.DeactivateMFADeviceCommand = DeactivateMFADeviceCommand;


/***/ }),

/***/ 92064:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteAccessKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteAccessKeyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteAccessKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteAccessKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteAccessKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteAccessKeyCommand)(output, context);
    }
}
exports.DeleteAccessKeyCommand = DeleteAccessKeyCommand;


/***/ }),

/***/ 91961:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteAccountAliasCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteAccountAliasCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteAccountAliasCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteAccountAliasCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteAccountAliasCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteAccountAliasCommand)(output, context);
    }
}
exports.DeleteAccountAliasCommand = DeleteAccountAliasCommand;


/***/ }),

/***/ 73079:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteAccountPasswordPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteAccountPasswordPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteAccountPasswordPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteAccountPasswordPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteAccountPasswordPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteAccountPasswordPolicyCommand)(output, context);
    }
}
exports.DeleteAccountPasswordPolicyCommand = DeleteAccountPasswordPolicyCommand;


/***/ }),

/***/ 18409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteGroupCommand)(output, context);
    }
}
exports.DeleteGroupCommand = DeleteGroupCommand;


/***/ }),

/***/ 90975:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteGroupPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteGroupPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteGroupPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteGroupPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteGroupPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteGroupPolicyCommand)(output, context);
    }
}
exports.DeleteGroupPolicyCommand = DeleteGroupPolicyCommand;


/***/ }),

/***/ 38672:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteInstanceProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteInstanceProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteInstanceProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteInstanceProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteInstanceProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteInstanceProfileCommand)(output, context);
    }
}
exports.DeleteInstanceProfileCommand = DeleteInstanceProfileCommand;


/***/ }),

/***/ 48912:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteLoginProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteLoginProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteLoginProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteLoginProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteLoginProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteLoginProfileCommand)(output, context);
    }
}
exports.DeleteLoginProfileCommand = DeleteLoginProfileCommand;


/***/ }),

/***/ 66931:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteOpenIDConnectProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteOpenIDConnectProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteOpenIDConnectProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteOpenIDConnectProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteOpenIDConnectProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteOpenIDConnectProviderCommand)(output, context);
    }
}
exports.DeleteOpenIDConnectProviderCommand = DeleteOpenIDConnectProviderCommand;


/***/ }),

/***/ 97547:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeletePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeletePolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeletePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeletePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeletePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeletePolicyCommand)(output, context);
    }
}
exports.DeletePolicyCommand = DeletePolicyCommand;


/***/ }),

/***/ 17282:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeletePolicyVersionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeletePolicyVersionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeletePolicyVersionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeletePolicyVersionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeletePolicyVersionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeletePolicyVersionCommand)(output, context);
    }
}
exports.DeletePolicyVersionCommand = DeletePolicyVersionCommand;


/***/ }),

/***/ 39539:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteRoleCommand)(output, context);
    }
}
exports.DeleteRoleCommand = DeleteRoleCommand;


/***/ }),

/***/ 3869:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteRolePermissionsBoundaryCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteRolePermissionsBoundaryCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteRolePermissionsBoundaryCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteRolePermissionsBoundaryCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteRolePermissionsBoundaryCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteRolePermissionsBoundaryCommand)(output, context);
    }
}
exports.DeleteRolePermissionsBoundaryCommand = DeleteRolePermissionsBoundaryCommand;


/***/ }),

/***/ 40322:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteRolePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteRolePolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteRolePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteRolePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteRolePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteRolePolicyCommand)(output, context);
    }
}
exports.DeleteRolePolicyCommand = DeleteRolePolicyCommand;


/***/ }),

/***/ 11643:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteSAMLProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteSAMLProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteSAMLProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteSAMLProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteSAMLProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteSAMLProviderCommand)(output, context);
    }
}
exports.DeleteSAMLProviderCommand = DeleteSAMLProviderCommand;


/***/ }),

/***/ 76253:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteSSHPublicKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteSSHPublicKeyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteSSHPublicKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteSSHPublicKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteSSHPublicKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteSSHPublicKeyCommand)(output, context);
    }
}
exports.DeleteSSHPublicKeyCommand = DeleteSSHPublicKeyCommand;


/***/ }),

/***/ 21672:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteServerCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteServerCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteServerCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteServerCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteServerCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteServerCertificateCommand)(output, context);
    }
}
exports.DeleteServerCertificateCommand = DeleteServerCertificateCommand;


/***/ }),

/***/ 14177:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteServiceLinkedRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteServiceLinkedRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteServiceLinkedRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteServiceLinkedRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteServiceLinkedRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteServiceLinkedRoleCommand)(output, context);
    }
}
exports.DeleteServiceLinkedRoleCommand = DeleteServiceLinkedRoleCommand;


/***/ }),

/***/ 57051:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteServiceSpecificCredentialCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteServiceSpecificCredentialCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteServiceSpecificCredentialCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteServiceSpecificCredentialCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteServiceSpecificCredentialCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteServiceSpecificCredentialCommand)(output, context);
    }
}
exports.DeleteServiceSpecificCredentialCommand = DeleteServiceSpecificCredentialCommand;


/***/ }),

/***/ 16723:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteSigningCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteSigningCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteSigningCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteSigningCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteSigningCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteSigningCertificateCommand)(output, context);
    }
}
exports.DeleteSigningCertificateCommand = DeleteSigningCertificateCommand;


/***/ }),

/***/ 17091:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteUserCommand)(output, context);
    }
}
exports.DeleteUserCommand = DeleteUserCommand;


/***/ }),

/***/ 82640:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteUserPermissionsBoundaryCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteUserPermissionsBoundaryCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteUserPermissionsBoundaryCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteUserPermissionsBoundaryCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteUserPermissionsBoundaryCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteUserPermissionsBoundaryCommand)(output, context);
    }
}
exports.DeleteUserPermissionsBoundaryCommand = DeleteUserPermissionsBoundaryCommand;


/***/ }),

/***/ 72335:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteUserPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteUserPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteUserPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteUserPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteUserPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteUserPolicyCommand)(output, context);
    }
}
exports.DeleteUserPolicyCommand = DeleteUserPolicyCommand;


/***/ }),

/***/ 29804:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteVirtualMFADeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DeleteVirtualMFADeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteVirtualMFADeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DeleteVirtualMFADeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DeleteVirtualMFADeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DeleteVirtualMFADeviceCommand)(output, context);
    }
}
exports.DeleteVirtualMFADeviceCommand = DeleteVirtualMFADeviceCommand;


/***/ }),

/***/ 64334:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DetachGroupPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DetachGroupPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DetachGroupPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DetachGroupPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DetachGroupPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DetachGroupPolicyCommand)(output, context);
    }
}
exports.DetachGroupPolicyCommand = DetachGroupPolicyCommand;


/***/ }),

/***/ 17300:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DetachRolePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DetachRolePolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DetachRolePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DetachRolePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DetachRolePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DetachRolePolicyCommand)(output, context);
    }
}
exports.DetachRolePolicyCommand = DetachRolePolicyCommand;


/***/ }),

/***/ 80938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DetachUserPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class DetachUserPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DetachUserPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "DetachUserPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DetachUserPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DetachUserPolicyCommand)(output, context);
    }
}
exports.DetachUserPolicyCommand = DetachUserPolicyCommand;


/***/ }),

/***/ 52607:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnableMFADeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class EnableMFADeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, EnableMFADeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "EnableMFADeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_EnableMFADeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_EnableMFADeviceCommand)(output, context);
    }
}
exports.EnableMFADeviceCommand = EnableMFADeviceCommand;


/***/ }),

/***/ 91102:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateCredentialReportCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GenerateCredentialReportCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GenerateCredentialReportCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GenerateCredentialReportCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GenerateCredentialReportCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GenerateCredentialReportCommand)(output, context);
    }
}
exports.GenerateCredentialReportCommand = GenerateCredentialReportCommand;


/***/ }),

/***/ 12029:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateOrganizationsAccessReportCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GenerateOrganizationsAccessReportCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GenerateOrganizationsAccessReportCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GenerateOrganizationsAccessReportCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GenerateOrganizationsAccessReportCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GenerateOrganizationsAccessReportCommand)(output, context);
    }
}
exports.GenerateOrganizationsAccessReportCommand = GenerateOrganizationsAccessReportCommand;


/***/ }),

/***/ 46151:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateServiceLastAccessedDetailsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GenerateServiceLastAccessedDetailsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GenerateServiceLastAccessedDetailsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GenerateServiceLastAccessedDetailsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GenerateServiceLastAccessedDetailsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GenerateServiceLastAccessedDetailsCommand)(output, context);
    }
}
exports.GenerateServiceLastAccessedDetailsCommand = GenerateServiceLastAccessedDetailsCommand;


/***/ }),

/***/ 29459:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAccessKeyLastUsedCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetAccessKeyLastUsedCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAccessKeyLastUsedCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetAccessKeyLastUsedCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetAccessKeyLastUsedCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetAccessKeyLastUsedCommand)(output, context);
    }
}
exports.GetAccessKeyLastUsedCommand = GetAccessKeyLastUsedCommand;


/***/ }),

/***/ 88568:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAccountAuthorizationDetailsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetAccountAuthorizationDetailsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAccountAuthorizationDetailsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetAccountAuthorizationDetailsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetAccountAuthorizationDetailsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetAccountAuthorizationDetailsCommand)(output, context);
    }
}
exports.GetAccountAuthorizationDetailsCommand = GetAccountAuthorizationDetailsCommand;


/***/ }),

/***/ 27562:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAccountPasswordPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetAccountPasswordPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAccountPasswordPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetAccountPasswordPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetAccountPasswordPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetAccountPasswordPolicyCommand)(output, context);
    }
}
exports.GetAccountPasswordPolicyCommand = GetAccountPasswordPolicyCommand;


/***/ }),

/***/ 60674:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAccountSummaryCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetAccountSummaryCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAccountSummaryCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetAccountSummaryCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetAccountSummaryCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetAccountSummaryCommand)(output, context);
    }
}
exports.GetAccountSummaryCommand = GetAccountSummaryCommand;


/***/ }),

/***/ 98318:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetContextKeysForCustomPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetContextKeysForCustomPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetContextKeysForCustomPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetContextKeysForCustomPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetContextKeysForCustomPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetContextKeysForCustomPolicyCommand)(output, context);
    }
}
exports.GetContextKeysForCustomPolicyCommand = GetContextKeysForCustomPolicyCommand;


/***/ }),

/***/ 17595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetContextKeysForPrincipalPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetContextKeysForPrincipalPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetContextKeysForPrincipalPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetContextKeysForPrincipalPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetContextKeysForPrincipalPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetContextKeysForPrincipalPolicyCommand)(output, context);
    }
}
exports.GetContextKeysForPrincipalPolicyCommand = GetContextKeysForPrincipalPolicyCommand;


/***/ }),

/***/ 50430:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCredentialReportCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetCredentialReportCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetCredentialReportCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetCredentialReportCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetCredentialReportCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetCredentialReportCommand)(output, context);
    }
}
exports.GetCredentialReportCommand = GetCredentialReportCommand;


/***/ }),

/***/ 85392:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetGroupCommand)(output, context);
    }
}
exports.GetGroupCommand = GetGroupCommand;


/***/ }),

/***/ 70566:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetGroupPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetGroupPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetGroupPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetGroupPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetGroupPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetGroupPolicyCommand)(output, context);
    }
}
exports.GetGroupPolicyCommand = GetGroupPolicyCommand;


/***/ }),

/***/ 27715:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetInstanceProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetInstanceProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetInstanceProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetInstanceProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetInstanceProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetInstanceProfileCommand)(output, context);
    }
}
exports.GetInstanceProfileCommand = GetInstanceProfileCommand;


/***/ }),

/***/ 91560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetLoginProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetLoginProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetLoginProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetLoginProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetLoginProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetLoginProfileCommand)(output, context);
    }
}
exports.GetLoginProfileCommand = GetLoginProfileCommand;


/***/ }),

/***/ 68295:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetMFADeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetMFADeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetMFADeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetMFADeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetMFADeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetMFADeviceCommand)(output, context);
    }
}
exports.GetMFADeviceCommand = GetMFADeviceCommand;


/***/ }),

/***/ 9699:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOpenIDConnectProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetOpenIDConnectProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetOpenIDConnectProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetOpenIDConnectProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetOpenIDConnectProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetOpenIDConnectProviderCommand)(output, context);
    }
}
exports.GetOpenIDConnectProviderCommand = GetOpenIDConnectProviderCommand;


/***/ }),

/***/ 81033:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOrganizationsAccessReportCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetOrganizationsAccessReportCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetOrganizationsAccessReportCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetOrganizationsAccessReportCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetOrganizationsAccessReportCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetOrganizationsAccessReportCommand)(output, context);
    }
}
exports.GetOrganizationsAccessReportCommand = GetOrganizationsAccessReportCommand;


/***/ }),

/***/ 1415:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetPolicyCommand)(output, context);
    }
}
exports.GetPolicyCommand = GetPolicyCommand;


/***/ }),

/***/ 59856:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPolicyVersionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetPolicyVersionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetPolicyVersionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetPolicyVersionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetPolicyVersionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetPolicyVersionCommand)(output, context);
    }
}
exports.GetPolicyVersionCommand = GetPolicyVersionCommand;


/***/ }),

/***/ 82426:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetRoleCommand)(output, context);
    }
}
exports.GetRoleCommand = GetRoleCommand;


/***/ }),

/***/ 83795:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRolePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetRolePolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetRolePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetRolePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetRolePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetRolePolicyCommand)(output, context);
    }
}
exports.GetRolePolicyCommand = GetRolePolicyCommand;


/***/ }),

/***/ 69224:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSAMLProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetSAMLProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetSAMLProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetSAMLProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetSAMLProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetSAMLProviderCommand)(output, context);
    }
}
exports.GetSAMLProviderCommand = GetSAMLProviderCommand;


/***/ }),

/***/ 34394:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSSHPublicKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetSSHPublicKeyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetSSHPublicKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetSSHPublicKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetSSHPublicKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetSSHPublicKeyCommand)(output, context);
    }
}
exports.GetSSHPublicKeyCommand = GetSSHPublicKeyCommand;


/***/ }),

/***/ 64462:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetServerCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetServerCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetServerCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetServerCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetServerCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetServerCertificateCommand)(output, context);
    }
}
exports.GetServerCertificateCommand = GetServerCertificateCommand;


/***/ }),

/***/ 62013:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetServiceLastAccessedDetailsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetServiceLastAccessedDetailsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetServiceLastAccessedDetailsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetServiceLastAccessedDetailsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetServiceLastAccessedDetailsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetServiceLastAccessedDetailsCommand)(output, context);
    }
}
exports.GetServiceLastAccessedDetailsCommand = GetServiceLastAccessedDetailsCommand;


/***/ }),

/***/ 93226:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetServiceLastAccessedDetailsWithEntitiesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetServiceLastAccessedDetailsWithEntitiesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetServiceLastAccessedDetailsWithEntitiesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetServiceLastAccessedDetailsWithEntitiesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetServiceLastAccessedDetailsWithEntitiesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetServiceLastAccessedDetailsWithEntitiesCommand)(output, context);
    }
}
exports.GetServiceLastAccessedDetailsWithEntitiesCommand = GetServiceLastAccessedDetailsWithEntitiesCommand;


/***/ }),

/***/ 60283:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetServiceLinkedRoleDeletionStatusCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetServiceLinkedRoleDeletionStatusCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetServiceLinkedRoleDeletionStatusCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetServiceLinkedRoleDeletionStatusCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetServiceLinkedRoleDeletionStatusCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetServiceLinkedRoleDeletionStatusCommand)(output, context);
    }
}
exports.GetServiceLinkedRoleDeletionStatusCommand = GetServiceLinkedRoleDeletionStatusCommand;


/***/ }),

/***/ 79345:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetUserCommand)(output, context);
    }
}
exports.GetUserCommand = GetUserCommand;


/***/ }),

/***/ 58459:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetUserPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class GetUserPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetUserPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "GetUserPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetUserPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetUserPolicyCommand)(output, context);
    }
}
exports.GetUserPolicyCommand = GetUserPolicyCommand;


/***/ }),

/***/ 97373:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccessKeysCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListAccessKeysCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccessKeysCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListAccessKeysCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListAccessKeysCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListAccessKeysCommand)(output, context);
    }
}
exports.ListAccessKeysCommand = ListAccessKeysCommand;


/***/ }),

/***/ 64599:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccountAliasesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListAccountAliasesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountAliasesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListAccountAliasesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListAccountAliasesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListAccountAliasesCommand)(output, context);
    }
}
exports.ListAccountAliasesCommand = ListAccountAliasesCommand;


/***/ }),

/***/ 78313:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAttachedGroupPoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListAttachedGroupPoliciesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAttachedGroupPoliciesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListAttachedGroupPoliciesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListAttachedGroupPoliciesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListAttachedGroupPoliciesCommand)(output, context);
    }
}
exports.ListAttachedGroupPoliciesCommand = ListAttachedGroupPoliciesCommand;


/***/ }),

/***/ 79686:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAttachedRolePoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListAttachedRolePoliciesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAttachedRolePoliciesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListAttachedRolePoliciesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListAttachedRolePoliciesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListAttachedRolePoliciesCommand)(output, context);
    }
}
exports.ListAttachedRolePoliciesCommand = ListAttachedRolePoliciesCommand;


/***/ }),

/***/ 31818:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAttachedUserPoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListAttachedUserPoliciesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAttachedUserPoliciesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListAttachedUserPoliciesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListAttachedUserPoliciesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListAttachedUserPoliciesCommand)(output, context);
    }
}
exports.ListAttachedUserPoliciesCommand = ListAttachedUserPoliciesCommand;


/***/ }),

/***/ 48813:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListEntitiesForPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListEntitiesForPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListEntitiesForPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListEntitiesForPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListEntitiesForPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListEntitiesForPolicyCommand)(output, context);
    }
}
exports.ListEntitiesForPolicyCommand = ListEntitiesForPolicyCommand;


/***/ }),

/***/ 23819:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListGroupPoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListGroupPoliciesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListGroupPoliciesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListGroupPoliciesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListGroupPoliciesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListGroupPoliciesCommand)(output, context);
    }
}
exports.ListGroupPoliciesCommand = ListGroupPoliciesCommand;


/***/ }),

/***/ 53646:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListGroupsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListGroupsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListGroupsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListGroupsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListGroupsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListGroupsCommand)(output, context);
    }
}
exports.ListGroupsCommand = ListGroupsCommand;


/***/ }),

/***/ 29368:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListGroupsForUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListGroupsForUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListGroupsForUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListGroupsForUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListGroupsForUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListGroupsForUserCommand)(output, context);
    }
}
exports.ListGroupsForUserCommand = ListGroupsForUserCommand;


/***/ }),

/***/ 58238:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListInstanceProfileTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListInstanceProfileTagsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListInstanceProfileTagsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListInstanceProfileTagsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListInstanceProfileTagsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListInstanceProfileTagsCommand)(output, context);
    }
}
exports.ListInstanceProfileTagsCommand = ListInstanceProfileTagsCommand;


/***/ }),

/***/ 90361:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListInstanceProfilesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListInstanceProfilesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListInstanceProfilesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListInstanceProfilesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListInstanceProfilesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListInstanceProfilesCommand)(output, context);
    }
}
exports.ListInstanceProfilesCommand = ListInstanceProfilesCommand;


/***/ }),

/***/ 36897:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListInstanceProfilesForRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListInstanceProfilesForRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListInstanceProfilesForRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListInstanceProfilesForRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListInstanceProfilesForRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListInstanceProfilesForRoleCommand)(output, context);
    }
}
exports.ListInstanceProfilesForRoleCommand = ListInstanceProfilesForRoleCommand;


/***/ }),

/***/ 93043:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListMFADeviceTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListMFADeviceTagsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListMFADeviceTagsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListMFADeviceTagsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListMFADeviceTagsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListMFADeviceTagsCommand)(output, context);
    }
}
exports.ListMFADeviceTagsCommand = ListMFADeviceTagsCommand;


/***/ }),

/***/ 30008:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListMFADevicesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListMFADevicesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListMFADevicesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListMFADevicesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListMFADevicesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListMFADevicesCommand)(output, context);
    }
}
exports.ListMFADevicesCommand = ListMFADevicesCommand;


/***/ }),

/***/ 16844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListOpenIDConnectProviderTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListOpenIDConnectProviderTagsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListOpenIDConnectProviderTagsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListOpenIDConnectProviderTagsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListOpenIDConnectProviderTagsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListOpenIDConnectProviderTagsCommand)(output, context);
    }
}
exports.ListOpenIDConnectProviderTagsCommand = ListOpenIDConnectProviderTagsCommand;


/***/ }),

/***/ 86834:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListOpenIDConnectProvidersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListOpenIDConnectProvidersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListOpenIDConnectProvidersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListOpenIDConnectProvidersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListOpenIDConnectProvidersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListOpenIDConnectProvidersCommand)(output, context);
    }
}
exports.ListOpenIDConnectProvidersCommand = ListOpenIDConnectProvidersCommand;


/***/ }),

/***/ 8349:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListPoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListPoliciesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListPoliciesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListPoliciesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListPoliciesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListPoliciesCommand)(output, context);
    }
}
exports.ListPoliciesCommand = ListPoliciesCommand;


/***/ }),

/***/ 4982:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListPoliciesGrantingServiceAccessCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListPoliciesGrantingServiceAccessCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListPoliciesGrantingServiceAccessCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListPoliciesGrantingServiceAccessCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListPoliciesGrantingServiceAccessCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListPoliciesGrantingServiceAccessCommand)(output, context);
    }
}
exports.ListPoliciesGrantingServiceAccessCommand = ListPoliciesGrantingServiceAccessCommand;


/***/ }),

/***/ 60264:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListPolicyTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListPolicyTagsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListPolicyTagsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListPolicyTagsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListPolicyTagsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListPolicyTagsCommand)(output, context);
    }
}
exports.ListPolicyTagsCommand = ListPolicyTagsCommand;


/***/ }),

/***/ 92250:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListPolicyVersionsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListPolicyVersionsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListPolicyVersionsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListPolicyVersionsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListPolicyVersionsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListPolicyVersionsCommand)(output, context);
    }
}
exports.ListPolicyVersionsCommand = ListPolicyVersionsCommand;


/***/ }),

/***/ 27265:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListRolePoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListRolePoliciesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListRolePoliciesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListRolePoliciesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListRolePoliciesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListRolePoliciesCommand)(output, context);
    }
}
exports.ListRolePoliciesCommand = ListRolePoliciesCommand;


/***/ }),

/***/ 37:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListRoleTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListRoleTagsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListRoleTagsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListRoleTagsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListRoleTagsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListRoleTagsCommand)(output, context);
    }
}
exports.ListRoleTagsCommand = ListRoleTagsCommand;


/***/ }),

/***/ 86805:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListRolesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListRolesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListRolesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListRolesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListRolesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListRolesCommand)(output, context);
    }
}
exports.ListRolesCommand = ListRolesCommand;


/***/ }),

/***/ 82416:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListSAMLProviderTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListSAMLProviderTagsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListSAMLProviderTagsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListSAMLProviderTagsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListSAMLProviderTagsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListSAMLProviderTagsCommand)(output, context);
    }
}
exports.ListSAMLProviderTagsCommand = ListSAMLProviderTagsCommand;


/***/ }),

/***/ 13333:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListSAMLProvidersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListSAMLProvidersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListSAMLProvidersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListSAMLProvidersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListSAMLProvidersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListSAMLProvidersCommand)(output, context);
    }
}
exports.ListSAMLProvidersCommand = ListSAMLProvidersCommand;


/***/ }),

/***/ 34152:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListSSHPublicKeysCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListSSHPublicKeysCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListSSHPublicKeysCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListSSHPublicKeysCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListSSHPublicKeysCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListSSHPublicKeysCommand)(output, context);
    }
}
exports.ListSSHPublicKeysCommand = ListSSHPublicKeysCommand;


/***/ }),

/***/ 8474:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListServerCertificateTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListServerCertificateTagsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListServerCertificateTagsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListServerCertificateTagsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListServerCertificateTagsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListServerCertificateTagsCommand)(output, context);
    }
}
exports.ListServerCertificateTagsCommand = ListServerCertificateTagsCommand;


/***/ }),

/***/ 75768:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListServerCertificatesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListServerCertificatesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListServerCertificatesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListServerCertificatesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListServerCertificatesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListServerCertificatesCommand)(output, context);
    }
}
exports.ListServerCertificatesCommand = ListServerCertificatesCommand;


/***/ }),

/***/ 51167:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListServiceSpecificCredentialsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListServiceSpecificCredentialsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListServiceSpecificCredentialsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListServiceSpecificCredentialsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListServiceSpecificCredentialsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListServiceSpecificCredentialsCommand)(output, context);
    }
}
exports.ListServiceSpecificCredentialsCommand = ListServiceSpecificCredentialsCommand;


/***/ }),

/***/ 35966:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListSigningCertificatesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListSigningCertificatesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListSigningCertificatesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListSigningCertificatesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListSigningCertificatesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListSigningCertificatesCommand)(output, context);
    }
}
exports.ListSigningCertificatesCommand = ListSigningCertificatesCommand;


/***/ }),

/***/ 83440:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListUserPoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListUserPoliciesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListUserPoliciesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListUserPoliciesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListUserPoliciesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListUserPoliciesCommand)(output, context);
    }
}
exports.ListUserPoliciesCommand = ListUserPoliciesCommand;


/***/ }),

/***/ 39245:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListUserTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListUserTagsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListUserTagsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListUserTagsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListUserTagsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListUserTagsCommand)(output, context);
    }
}
exports.ListUserTagsCommand = ListUserTagsCommand;


/***/ }),

/***/ 94234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListUsersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ListUsersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListUsersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListUsersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListUsersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListUsersCommand)(output, context);
    }
}
exports.ListUsersCommand = ListUsersCommand;


/***/ }),

/***/ 5950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListVirtualMFADevicesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(18824);
const Aws_query_1 = __nccwpck_require__(12786);
class ListVirtualMFADevicesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListVirtualMFADevicesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ListVirtualMFADevicesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: models_0_1.ListVirtualMFADevicesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ListVirtualMFADevicesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ListVirtualMFADevicesCommand)(output, context);
    }
}
exports.ListVirtualMFADevicesCommand = ListVirtualMFADevicesCommand;


/***/ }),

/***/ 41824:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutGroupPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class PutGroupPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutGroupPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "PutGroupPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_PutGroupPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_PutGroupPolicyCommand)(output, context);
    }
}
exports.PutGroupPolicyCommand = PutGroupPolicyCommand;


/***/ }),

/***/ 60953:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutRolePermissionsBoundaryCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class PutRolePermissionsBoundaryCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutRolePermissionsBoundaryCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "PutRolePermissionsBoundaryCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_PutRolePermissionsBoundaryCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_PutRolePermissionsBoundaryCommand)(output, context);
    }
}
exports.PutRolePermissionsBoundaryCommand = PutRolePermissionsBoundaryCommand;


/***/ }),

/***/ 80778:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutRolePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class PutRolePolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutRolePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "PutRolePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_PutRolePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_PutRolePolicyCommand)(output, context);
    }
}
exports.PutRolePolicyCommand = PutRolePolicyCommand;


/***/ }),

/***/ 88140:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutUserPermissionsBoundaryCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class PutUserPermissionsBoundaryCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutUserPermissionsBoundaryCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "PutUserPermissionsBoundaryCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_PutUserPermissionsBoundaryCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_PutUserPermissionsBoundaryCommand)(output, context);
    }
}
exports.PutUserPermissionsBoundaryCommand = PutUserPermissionsBoundaryCommand;


/***/ }),

/***/ 41470:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutUserPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class PutUserPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutUserPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "PutUserPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_PutUserPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_PutUserPolicyCommand)(output, context);
    }
}
exports.PutUserPolicyCommand = PutUserPolicyCommand;


/***/ }),

/***/ 25733:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveClientIDFromOpenIDConnectProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class RemoveClientIDFromOpenIDConnectProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RemoveClientIDFromOpenIDConnectProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "RemoveClientIDFromOpenIDConnectProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_RemoveClientIDFromOpenIDConnectProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_RemoveClientIDFromOpenIDConnectProviderCommand)(output, context);
    }
}
exports.RemoveClientIDFromOpenIDConnectProviderCommand = RemoveClientIDFromOpenIDConnectProviderCommand;


/***/ }),

/***/ 43694:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveRoleFromInstanceProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class RemoveRoleFromInstanceProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RemoveRoleFromInstanceProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "RemoveRoleFromInstanceProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_RemoveRoleFromInstanceProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_RemoveRoleFromInstanceProfileCommand)(output, context);
    }
}
exports.RemoveRoleFromInstanceProfileCommand = RemoveRoleFromInstanceProfileCommand;


/***/ }),

/***/ 45109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveUserFromGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class RemoveUserFromGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RemoveUserFromGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "RemoveUserFromGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_RemoveUserFromGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_RemoveUserFromGroupCommand)(output, context);
    }
}
exports.RemoveUserFromGroupCommand = RemoveUserFromGroupCommand;


/***/ }),

/***/ 56977:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResetServiceSpecificCredentialCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(18824);
const Aws_query_1 = __nccwpck_require__(12786);
class ResetServiceSpecificCredentialCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ResetServiceSpecificCredentialCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ResetServiceSpecificCredentialCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: models_0_1.ResetServiceSpecificCredentialResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ResetServiceSpecificCredentialCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ResetServiceSpecificCredentialCommand)(output, context);
    }
}
exports.ResetServiceSpecificCredentialCommand = ResetServiceSpecificCredentialCommand;


/***/ }),

/***/ 19736:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResyncMFADeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class ResyncMFADeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ResyncMFADeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "ResyncMFADeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_ResyncMFADeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_ResyncMFADeviceCommand)(output, context);
    }
}
exports.ResyncMFADeviceCommand = ResyncMFADeviceCommand;


/***/ }),

/***/ 72457:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetDefaultPolicyVersionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class SetDefaultPolicyVersionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SetDefaultPolicyVersionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "SetDefaultPolicyVersionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_SetDefaultPolicyVersionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_SetDefaultPolicyVersionCommand)(output, context);
    }
}
exports.SetDefaultPolicyVersionCommand = SetDefaultPolicyVersionCommand;


/***/ }),

/***/ 94251:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetSecurityTokenServicePreferencesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class SetSecurityTokenServicePreferencesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SetSecurityTokenServicePreferencesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "SetSecurityTokenServicePreferencesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_SetSecurityTokenServicePreferencesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_SetSecurityTokenServicePreferencesCommand)(output, context);
    }
}
exports.SetSecurityTokenServicePreferencesCommand = SetSecurityTokenServicePreferencesCommand;


/***/ }),

/***/ 48453:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimulateCustomPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class SimulateCustomPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SimulateCustomPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "SimulateCustomPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_SimulateCustomPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_SimulateCustomPolicyCommand)(output, context);
    }
}
exports.SimulateCustomPolicyCommand = SimulateCustomPolicyCommand;


/***/ }),

/***/ 33979:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimulatePrincipalPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class SimulatePrincipalPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SimulatePrincipalPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "SimulatePrincipalPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_SimulatePrincipalPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_SimulatePrincipalPolicyCommand)(output, context);
    }
}
exports.SimulatePrincipalPolicyCommand = SimulatePrincipalPolicyCommand;


/***/ }),

/***/ 35775:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagInstanceProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class TagInstanceProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagInstanceProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "TagInstanceProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_TagInstanceProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_TagInstanceProfileCommand)(output, context);
    }
}
exports.TagInstanceProfileCommand = TagInstanceProfileCommand;


/***/ }),

/***/ 55735:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagMFADeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class TagMFADeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagMFADeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "TagMFADeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_TagMFADeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_TagMFADeviceCommand)(output, context);
    }
}
exports.TagMFADeviceCommand = TagMFADeviceCommand;


/***/ }),

/***/ 37781:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagOpenIDConnectProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class TagOpenIDConnectProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagOpenIDConnectProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "TagOpenIDConnectProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_TagOpenIDConnectProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_TagOpenIDConnectProviderCommand)(output, context);
    }
}
exports.TagOpenIDConnectProviderCommand = TagOpenIDConnectProviderCommand;


/***/ }),

/***/ 28972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class TagPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "TagPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_TagPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_TagPolicyCommand)(output, context);
    }
}
exports.TagPolicyCommand = TagPolicyCommand;


/***/ }),

/***/ 12277:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class TagRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "TagRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_TagRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_TagRoleCommand)(output, context);
    }
}
exports.TagRoleCommand = TagRoleCommand;


/***/ }),

/***/ 21060:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagSAMLProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class TagSAMLProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagSAMLProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "TagSAMLProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_TagSAMLProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_TagSAMLProviderCommand)(output, context);
    }
}
exports.TagSAMLProviderCommand = TagSAMLProviderCommand;


/***/ }),

/***/ 98317:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagServerCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class TagServerCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagServerCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "TagServerCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_TagServerCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_TagServerCertificateCommand)(output, context);
    }
}
exports.TagServerCertificateCommand = TagServerCertificateCommand;


/***/ }),

/***/ 8867:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class TagUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "TagUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_TagUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_TagUserCommand)(output, context);
    }
}
exports.TagUserCommand = TagUserCommand;


/***/ }),

/***/ 90945:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagInstanceProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UntagInstanceProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagInstanceProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UntagInstanceProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UntagInstanceProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UntagInstanceProfileCommand)(output, context);
    }
}
exports.UntagInstanceProfileCommand = UntagInstanceProfileCommand;


/***/ }),

/***/ 31502:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagMFADeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UntagMFADeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagMFADeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UntagMFADeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UntagMFADeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UntagMFADeviceCommand)(output, context);
    }
}
exports.UntagMFADeviceCommand = UntagMFADeviceCommand;


/***/ }),

/***/ 49046:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagOpenIDConnectProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UntagOpenIDConnectProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagOpenIDConnectProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UntagOpenIDConnectProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UntagOpenIDConnectProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UntagOpenIDConnectProviderCommand)(output, context);
    }
}
exports.UntagOpenIDConnectProviderCommand = UntagOpenIDConnectProviderCommand;


/***/ }),

/***/ 95074:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UntagPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UntagPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UntagPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UntagPolicyCommand)(output, context);
    }
}
exports.UntagPolicyCommand = UntagPolicyCommand;


/***/ }),

/***/ 29045:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UntagRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UntagRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UntagRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UntagRoleCommand)(output, context);
    }
}
exports.UntagRoleCommand = UntagRoleCommand;


/***/ }),

/***/ 99473:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagSAMLProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UntagSAMLProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagSAMLProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UntagSAMLProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UntagSAMLProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UntagSAMLProviderCommand)(output, context);
    }
}
exports.UntagSAMLProviderCommand = UntagSAMLProviderCommand;


/***/ }),

/***/ 39125:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagServerCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UntagServerCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagServerCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UntagServerCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UntagServerCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UntagServerCertificateCommand)(output, context);
    }
}
exports.UntagServerCertificateCommand = UntagServerCertificateCommand;


/***/ }),

/***/ 22643:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UntagUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UntagUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UntagUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UntagUserCommand)(output, context);
    }
}
exports.UntagUserCommand = UntagUserCommand;


/***/ }),

/***/ 55768:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateAccessKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateAccessKeyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateAccessKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateAccessKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateAccessKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateAccessKeyCommand)(output, context);
    }
}
exports.UpdateAccessKeyCommand = UpdateAccessKeyCommand;


/***/ }),

/***/ 48793:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateAccountPasswordPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateAccountPasswordPolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateAccountPasswordPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateAccountPasswordPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateAccountPasswordPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateAccountPasswordPolicyCommand)(output, context);
    }
}
exports.UpdateAccountPasswordPolicyCommand = UpdateAccountPasswordPolicyCommand;


/***/ }),

/***/ 35801:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateAssumeRolePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateAssumeRolePolicyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateAssumeRolePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateAssumeRolePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateAssumeRolePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateAssumeRolePolicyCommand)(output, context);
    }
}
exports.UpdateAssumeRolePolicyCommand = UpdateAssumeRolePolicyCommand;


/***/ }),

/***/ 4047:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateGroupCommand)(output, context);
    }
}
exports.UpdateGroupCommand = UpdateGroupCommand;


/***/ }),

/***/ 15832:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateLoginProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_1_1 = __nccwpck_require__(58414);
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateLoginProfileCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateLoginProfileCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateLoginProfileCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.UpdateLoginProfileRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateLoginProfileCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateLoginProfileCommand)(output, context);
    }
}
exports.UpdateLoginProfileCommand = UpdateLoginProfileCommand;


/***/ }),

/***/ 19509:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateOpenIDConnectProviderThumbprintCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateOpenIDConnectProviderThumbprintCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateOpenIDConnectProviderThumbprintCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateOpenIDConnectProviderThumbprintCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateOpenIDConnectProviderThumbprintCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateOpenIDConnectProviderThumbprintCommand)(output, context);
    }
}
exports.UpdateOpenIDConnectProviderThumbprintCommand = UpdateOpenIDConnectProviderThumbprintCommand;


/***/ }),

/***/ 85361:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateRoleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateRoleCommand)(output, context);
    }
}
exports.UpdateRoleCommand = UpdateRoleCommand;


/***/ }),

/***/ 18390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateRoleDescriptionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateRoleDescriptionCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateRoleDescriptionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateRoleDescriptionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateRoleDescriptionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateRoleDescriptionCommand)(output, context);
    }
}
exports.UpdateRoleDescriptionCommand = UpdateRoleDescriptionCommand;


/***/ }),

/***/ 76652:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateSAMLProviderCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateSAMLProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateSAMLProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateSAMLProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateSAMLProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateSAMLProviderCommand)(output, context);
    }
}
exports.UpdateSAMLProviderCommand = UpdateSAMLProviderCommand;


/***/ }),

/***/ 49724:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateSSHPublicKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateSSHPublicKeyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateSSHPublicKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateSSHPublicKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateSSHPublicKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateSSHPublicKeyCommand)(output, context);
    }
}
exports.UpdateSSHPublicKeyCommand = UpdateSSHPublicKeyCommand;


/***/ }),

/***/ 30474:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateServerCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateServerCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateServerCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateServerCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateServerCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateServerCertificateCommand)(output, context);
    }
}
exports.UpdateServerCertificateCommand = UpdateServerCertificateCommand;


/***/ }),

/***/ 60256:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateServiceSpecificCredentialCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateServiceSpecificCredentialCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateServiceSpecificCredentialCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateServiceSpecificCredentialCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateServiceSpecificCredentialCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateServiceSpecificCredentialCommand)(output, context);
    }
}
exports.UpdateServiceSpecificCredentialCommand = UpdateServiceSpecificCredentialCommand;


/***/ }),

/***/ 9457:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateSigningCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateSigningCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateSigningCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateSigningCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateSigningCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateSigningCertificateCommand)(output, context);
    }
}
exports.UpdateSigningCertificateCommand = UpdateSigningCertificateCommand;


/***/ }),

/***/ 18301:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UpdateUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UpdateUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UpdateUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UpdateUserCommand)(output, context);
    }
}
exports.UpdateUserCommand = UpdateUserCommand;


/***/ }),

/***/ 28168:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploadSSHPublicKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UploadSSHPublicKeyCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UploadSSHPublicKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UploadSSHPublicKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UploadSSHPublicKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UploadSSHPublicKeyCommand)(output, context);
    }
}
exports.UploadSSHPublicKeyCommand = UploadSSHPublicKeyCommand;


/***/ }),

/***/ 53344:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploadServerCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_1_1 = __nccwpck_require__(58414);
const Aws_query_1 = __nccwpck_require__(12786);
class UploadServerCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UploadServerCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UploadServerCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.UploadServerCertificateRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UploadServerCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UploadServerCertificateCommand)(output, context);
    }
}
exports.UploadServerCertificateCommand = UploadServerCertificateCommand;


/***/ }),

/***/ 84118:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploadSigningCertificateCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(12786);
class UploadSigningCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UploadSigningCertificateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "IAMClient";
        const commandName = "UploadSigningCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_UploadSigningCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_UploadSigningCertificateCommand)(output, context);
    }
}
exports.UploadSigningCertificateCommand = UploadSigningCertificateCommand;


/***/ }),

/***/ 83426:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(11629), exports);
tslib_1.__exportStar(__nccwpck_require__(12628), exports);
tslib_1.__exportStar(__nccwpck_require__(62481), exports);
tslib_1.__exportStar(__nccwpck_require__(1396), exports);
tslib_1.__exportStar(__nccwpck_require__(76859), exports);
tslib_1.__exportStar(__nccwpck_require__(34430), exports);
tslib_1.__exportStar(__nccwpck_require__(96427), exports);
tslib_1.__exportStar(__nccwpck_require__(22074), exports);
tslib_1.__exportStar(__nccwpck_require__(21038), exports);
tslib_1.__exportStar(__nccwpck_require__(75510), exports);
tslib_1.__exportStar(__nccwpck_require__(46601), exports);
tslib_1.__exportStar(__nccwpck_require__(9799), exports);
tslib_1.__exportStar(__nccwpck_require__(21721), exports);
tslib_1.__exportStar(__nccwpck_require__(93380), exports);
tslib_1.__exportStar(__nccwpck_require__(80886), exports);
tslib_1.__exportStar(__nccwpck_require__(14199), exports);
tslib_1.__exportStar(__nccwpck_require__(32287), exports);
tslib_1.__exportStar(__nccwpck_require__(95386), exports);
tslib_1.__exportStar(__nccwpck_require__(80166), exports);
tslib_1.__exportStar(__nccwpck_require__(80728), exports);
tslib_1.__exportStar(__nccwpck_require__(82284), exports);
tslib_1.__exportStar(__nccwpck_require__(27998), exports);
tslib_1.__exportStar(__nccwpck_require__(92064), exports);
tslib_1.__exportStar(__nccwpck_require__(91961), exports);
tslib_1.__exportStar(__nccwpck_require__(73079), exports);
tslib_1.__exportStar(__nccwpck_require__(18409), exports);
tslib_1.__exportStar(__nccwpck_require__(90975), exports);
tslib_1.__exportStar(__nccwpck_require__(38672), exports);
tslib_1.__exportStar(__nccwpck_require__(48912), exports);
tslib_1.__exportStar(__nccwpck_require__(66931), exports);
tslib_1.__exportStar(__nccwpck_require__(97547), exports);
tslib_1.__exportStar(__nccwpck_require__(17282), exports);
tslib_1.__exportStar(__nccwpck_require__(39539), exports);
tslib_1.__exportStar(__nccwpck_require__(3869), exports);
tslib_1.__exportStar(__nccwpck_require__(40322), exports);
tslib_1.__exportStar(__nccwpck_require__(11643), exports);
tslib_1.__exportStar(__nccwpck_require__(76253), exports);
tslib_1.__exportStar(__nccwpck_require__(21672), exports);
tslib_1.__exportStar(__nccwpck_require__(14177), exports);
tslib_1.__exportStar(__nccwpck_require__(57051), exports);
tslib_1.__exportStar(__nccwpck_require__(16723), exports);
tslib_1.__exportStar(__nccwpck_require__(17091), exports);
tslib_1.__exportStar(__nccwpck_require__(82640), exports);
tslib_1.__exportStar(__nccwpck_require__(72335), exports);
tslib_1.__exportStar(__nccwpck_require__(29804), exports);
tslib_1.__exportStar(__nccwpck_require__(64334), exports);
tslib_1.__exportStar(__nccwpck_require__(17300), exports);
tslib_1.__exportStar(__nccwpck_require__(80938), exports);
tslib_1.__exportStar(__nccwpck_require__(52607), exports);
tslib_1.__exportStar(__nccwpck_require__(91102), exports);
tslib_1.__exportStar(__nccwpck_require__(12029), exports);
tslib_1.__exportStar(__nccwpck_require__(46151), exports);
tslib_1.__exportStar(__nccwpck_require__(29459), exports);
tslib_1.__exportStar(__nccwpck_require__(88568), exports);
tslib_1.__exportStar(__nccwpck_require__(27562), exports);
tslib_1.__exportStar(__nccwpck_require__(60674), exports);
tslib_1.__exportStar(__nccwpck_require__(98318), exports);
tslib_1.__exportStar(__nccwpck_require__(17595), exports);
tslib_1.__exportStar(__nccwpck_require__(50430), exports);
tslib_1.__exportStar(__nccwpck_require__(85392), exports);
tslib_1.__exportStar(__nccwpck_require__(70566), exports);
tslib_1.__exportStar(__nccwpck_require__(27715), exports);
tslib_1.__exportStar(__nccwpck_require__(91560), exports);
tslib_1.__exportStar(__nccwpck_require__(68295), exports);
tslib_1.__exportStar(__nccwpck_require__(9699), exports);
tslib_1.__exportStar(__nccwpck_require__(81033), exports);
tslib_1.__exportStar(__nccwpck_require__(1415), exports);
tslib_1.__exportStar(__nccwpck_require__(59856), exports);
tslib_1.__exportStar(__nccwpck_require__(82426), exports);
tslib_1.__exportStar(__nccwpck_require__(83795), exports);
tslib_1.__exportStar(__nccwpck_require__(69224), exports);
tslib_1.__exportStar(__nccwpck_require__(34394), exports);
tslib_1.__exportStar(__nccwpck_require__(64462), exports);
tslib_1.__exportStar(__nccwpck_require__(62013), exports);
tslib_1.__exportStar(__nccwpck_require__(93226), exports);
tslib_1.__exportStar(__nccwpck_require__(60283), exports);
tslib_1.__exportStar(__nccwpck_require__(79345), exports);
tslib_1.__exportStar(__nccwpck_require__(58459), exports);
tslib_1.__exportStar(__nccwpck_require__(97373), exports);
tslib_1.__exportStar(__nccwpck_require__(64599), exports);
tslib_1.__exportStar(__nccwpck_require__(78313), exports);
tslib_1.__exportStar(__nccwpck_require__(79686), exports);
tslib_1.__exportStar(__nccwpck_require__(31818), exports);
tslib_1.__exportStar(__nccwpck_require__(48813), exports);
tslib_1.__exportStar(__nccwpck_require__(23819), exports);
tslib_1.__exportStar(__nccwpck_require__(53646), exports);
tslib_1.__exportStar(__nccwpck_require__(29368), exports);
tslib_1.__exportStar(__nccwpck_require__(58238), exports);
tslib_1.__exportStar(__nccwpck_require__(90361), exports);
tslib_1.__exportStar(__nccwpck_require__(36897), exports);
tslib_1.__exportStar(__nccwpck_require__(93043), exports);
tslib_1.__exportStar(__nccwpck_require__(30008), exports);
tslib_1.__exportStar(__nccwpck_require__(16844), exports);
tslib_1.__exportStar(__nccwpck_require__(86834), exports);
tslib_1.__exportStar(__nccwpck_require__(8349), exports);
tslib_1.__exportStar(__nccwpck_require__(4982), exports);
tslib_1.__exportStar(__nccwpck_require__(60264), exports);
tslib_1.__exportStar(__nccwpck_require__(92250), exports);
tslib_1.__exportStar(__nccwpck_require__(27265), exports);
tslib_1.__exportStar(__nccwpck_require__(37), exports);
tslib_1.__exportStar(__nccwpck_require__(86805), exports);
tslib_1.__exportStar(__nccwpck_require__(82416), exports);
tslib_1.__exportStar(__nccwpck_require__(13333), exports);
tslib_1.__exportStar(__nccwpck_require__(34152), exports);
tslib_1.__exportStar(__nccwpck_require__(8474), exports);
tslib_1.__exportStar(__nccwpck_require__(75768), exports);
tslib_1.__exportStar(__nccwpck_require__(51167), exports);
tslib_1.__exportStar(__nccwpck_require__(35966), exports);
tslib_1.__exportStar(__nccwpck_require__(83440), exports);
tslib_1.__exportStar(__nccwpck_require__(39245), exports);
tslib_1.__exportStar(__nccwpck_require__(94234), exports);
tslib_1.__exportStar(__nccwpck_require__(5950), exports);
tslib_1.__exportStar(__nccwpck_require__(41824), exports);
tslib_1.__exportStar(__nccwpck_require__(60953), exports);
tslib_1.__exportStar(__nccwpck_require__(80778), exports);
tslib_1.__exportStar(__nccwpck_require__(88140), exports);
tslib_1.__exportStar(__nccwpck_require__(41470), exports);
tslib_1.__exportStar(__nccwpck_require__(25733), exports);
tslib_1.__exportStar(__nccwpck_require__(43694), exports);
tslib_1.__exportStar(__nccwpck_require__(45109), exports);
tslib_1.__exportStar(__nccwpck_require__(56977), exports);
tslib_1.__exportStar(__nccwpck_require__(19736), exports);
tslib_1.__exportStar(__nccwpck_require__(72457), exports);
tslib_1.__exportStar(__nccwpck_require__(94251), exports);
tslib_1.__exportStar(__nccwpck_require__(48453), exports);
tslib_1.__exportStar(__nccwpck_require__(33979), exports);
tslib_1.__exportStar(__nccwpck_require__(35775), exports);
tslib_1.__exportStar(__nccwpck_require__(55735), exports);
tslib_1.__exportStar(__nccwpck_require__(37781), exports);
tslib_1.__exportStar(__nccwpck_require__(28972), exports);
tslib_1.__exportStar(__nccwpck_require__(12277), exports);
tslib_1.__exportStar(__nccwpck_require__(21060), exports);
tslib_1.__exportStar(__nccwpck_require__(98317), exports);
tslib_1.__exportStar(__nccwpck_require__(8867), exports);
tslib_1.__exportStar(__nccwpck_require__(90945), exports);
tslib_1.__exportStar(__nccwpck_require__(31502), exports);
tslib_1.__exportStar(__nccwpck_require__(49046), exports);
tslib_1.__exportStar(__nccwpck_require__(95074), exports);
tslib_1.__exportStar(__nccwpck_require__(29045), exports);
tslib_1.__exportStar(__nccwpck_require__(99473), exports);
tslib_1.__exportStar(__nccwpck_require__(39125), exports);
tslib_1.__exportStar(__nccwpck_require__(22643), exports);
tslib_1.__exportStar(__nccwpck_require__(55768), exports);
tslib_1.__exportStar(__nccwpck_require__(48793), exports);
tslib_1.__exportStar(__nccwpck_require__(35801), exports);
tslib_1.__exportStar(__nccwpck_require__(4047), exports);
tslib_1.__exportStar(__nccwpck_require__(15832), exports);
tslib_1.__exportStar(__nccwpck_require__(19509), exports);
tslib_1.__exportStar(__nccwpck_require__(85361), exports);
tslib_1.__exportStar(__nccwpck_require__(18390), exports);
tslib_1.__exportStar(__nccwpck_require__(76652), exports);
tslib_1.__exportStar(__nccwpck_require__(49724), exports);
tslib_1.__exportStar(__nccwpck_require__(30474), exports);
tslib_1.__exportStar(__nccwpck_require__(60256), exports);
tslib_1.__exportStar(__nccwpck_require__(9457), exports);
tslib_1.__exportStar(__nccwpck_require__(18301), exports);
tslib_1.__exportStar(__nccwpck_require__(28168), exports);
tslib_1.__exportStar(__nccwpck_require__(53344), exports);
tslib_1.__exportStar(__nccwpck_require__(84118), exports);


/***/ }),

/***/ 9539:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "iam",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 21320:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(19986);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 19986:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const A = "required", B = "fn", C = "argv", D = "ref", E = "authSchemes", F = "signingName", G = "signingRegion";
const a = "isSet", b = "tree", c = "error", d = "endpoint", e = "PartitionResult", f = "stringEquals", g = "sigv4", h = "iam", i = { [A]: false, "type": "String" }, j = { [A]: true, "default": false, "type": "Boolean" }, k = { [D]: "Endpoint" }, l = { [B]: "booleanEquals", [C]: [{ [D]: "UseFIPS" }, true] }, m = { [B]: "booleanEquals", [C]: [{ [D]: "UseDualStack" }, true] }, n = {}, o = { [B]: f, [C]: [{ [B]: "getAttr", [C]: [{ [D]: e }, "name"] }, "aws"] }, p = { [B]: "getAttr", [C]: [{ [D]: e }, "name"] }, q = { [B]: "booleanEquals", [C]: [{ [D]: "UseFIPS" }, false] }, r = { [B]: "booleanEquals", [C]: [{ [D]: "UseDualStack" }, false] }, s = { [E]: [{ "name": g, [F]: h, [G]: "us-east-1" }] }, t = { [B]: f, [C]: [p, "aws-us-gov"] }, u = { "url": "https://iam.us-gov.amazonaws.com", "properties": { [E]: [{ "name": g, [F]: h, [G]: "us-gov-west-1" }] }, "headers": {} }, v = { [B]: "booleanEquals", [C]: [true, { [B]: "getAttr", [C]: [{ [D]: e }, "supportsFIPS"] }] }, w = { [B]: "booleanEquals", [C]: [true, { [B]: "getAttr", [C]: [{ [D]: e }, "supportsDualStack"] }] }, x = [l], y = [m], z = [{ [D]: "Region" }];
const _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [B]: a, [C]: [k] }], type: b, rules: [{ conditions: x, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: y, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: k, properties: n, headers: n }, type: d }] }] }, { type: b, rules: [{ conditions: [{ [B]: a, [C]: z }], type: b, rules: [{ conditions: [{ [B]: "aws.partition", [C]: z, assign: e }], type: b, rules: [{ conditions: [o, q, r], endpoint: { url: "https://iam.amazonaws.com", properties: s, headers: n }, type: d }, { conditions: [o, l, r], endpoint: { url: "https://iam-fips.amazonaws.com", properties: s, headers: n }, type: d }, { conditions: [{ [B]: f, [C]: [p, "aws-cn"] }, q, r], endpoint: { url: "https://iam.cn-north-1.amazonaws.com.cn", properties: { [E]: [{ name: g, [F]: h, [G]: "cn-north-1" }] }, headers: n }, type: d }, { conditions: [t, q, r], endpoint: u, type: d }, { conditions: [t, l, r], endpoint: u, type: d }, { conditions: [{ [B]: f, [C]: [p, "aws-iso"] }, q, r], endpoint: { url: "https://iam.us-iso-east-1.c2s.ic.gov", properties: { [E]: [{ name: g, [F]: h, [G]: "us-iso-east-1" }] }, headers: n }, type: d }, { conditions: [{ [B]: f, [C]: [p, "aws-iso-b"] }, q, r], endpoint: { url: "https://iam.us-isob-east-1.sc2s.sgov.gov", properties: { [E]: [{ name: g, [F]: h, [G]: "us-isob-east-1" }] }, headers: n }, type: d }, { conditions: [l, m], type: b, rules: [{ conditions: [v, w], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://iam-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: d }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: x, type: b, rules: [{ conditions: [v], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://iam-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: y, type: b, rules: [{ conditions: [w], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://iam.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: d }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { type: b, rules: [{ endpoint: { url: "https://iam.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: d }] }] }] }, { error: "Invalid Configuration: Missing Region", type: c }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 26276:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IAMServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(8652), exports);
tslib_1.__exportStar(__nccwpck_require__(44786), exports);
tslib_1.__exportStar(__nccwpck_require__(83426), exports);
tslib_1.__exportStar(__nccwpck_require__(92723), exports);
tslib_1.__exportStar(__nccwpck_require__(89467), exports);
tslib_1.__exportStar(__nccwpck_require__(3226), exports);
var IAMServiceException_1 = __nccwpck_require__(40103);
Object.defineProperty(exports, "IAMServiceException", ({ enumerable: true, get: function () { return IAMServiceException_1.IAMServiceException; } }));


/***/ }),

/***/ 40103:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IAMServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class IAMServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, IAMServiceException.prototype);
    }
}
exports.IAMServiceException = IAMServiceException;


/***/ }),

/***/ 3226:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(18824), exports);
tslib_1.__exportStar(__nccwpck_require__(58414), exports);


/***/ }),

/***/ 18824:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListVirtualMFADevicesResponseFilterSensitiveLog = exports.CreateVirtualMFADeviceResponseFilterSensitiveLog = exports.VirtualMFADeviceFilterSensitiveLog = exports.CreateServiceSpecificCredentialResponseFilterSensitiveLog = exports.ServiceSpecificCredentialFilterSensitiveLog = exports.CreateLoginProfileRequestFilterSensitiveLog = exports.CreateAccessKeyResponseFilterSensitiveLog = exports.ChangePasswordRequestFilterSensitiveLog = exports.AccessKeyFilterSensitiveLog = exports.PolicySourceType = exports.PolicyEvaluationDecisionType = exports.ContextKeyTypeEnum = exports.PolicyEvaluationException = exports.GlobalEndpointTokenVersion = exports.PolicyType = exports.PolicyScopeType = exports.PolicyUsageType = exports.UnrecognizedPublicKeyEncodingException = exports.EncodingType = exports.DeletionTaskStatusType = exports.PolicyOwnerEntityType = exports.JobStatusType = exports.SortKeyType = exports.ReportFormatType = exports.CredentialReportNotReadyException = exports.CredentialReportNotPresentException = exports.CredentialReportExpiredException = exports.SummaryKeyType = exports.EntityType = exports.ReportGenerationLimitExceededException = exports.ReportStateType = exports.InvalidAuthenticationCodeException = exports.DeleteConflictException = exports.ServiceNotSupportedException = exports.MalformedPolicyDocumentException = exports.ConcurrentModificationException = exports.PasswordPolicyViolationException = exports.InvalidUserTypeException = exports.EntityTemporarilyUnmodifiableException = exports.PolicyNotAttachableException = exports.PermissionsBoundaryAttachmentType = exports.AssignmentStatusType = exports.UnmodifiableEntityException = exports.EntityAlreadyExistsException = exports.ServiceFailureException = exports.NoSuchEntityException = exports.LimitExceededException = exports.InvalidInputException = exports.StatusType = exports.AccessAdvisorUsageGranularityType = void 0;
exports.ResetServiceSpecificCredentialResponseFilterSensitiveLog = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const IAMServiceException_1 = __nccwpck_require__(40103);
exports.AccessAdvisorUsageGranularityType = {
    ACTION_LEVEL: "ACTION_LEVEL",
    SERVICE_LEVEL: "SERVICE_LEVEL",
};
exports.StatusType = {
    Active: "Active",
    Inactive: "Inactive",
};
class InvalidInputException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidInputException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidInputException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidInputException.prototype);
    }
}
exports.InvalidInputException = InvalidInputException;
class LimitExceededException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LimitExceededException.prototype);
    }
}
exports.LimitExceededException = LimitExceededException;
class NoSuchEntityException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "NoSuchEntityException",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchEntityException";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchEntityException.prototype);
    }
}
exports.NoSuchEntityException = NoSuchEntityException;
class ServiceFailureException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "ServiceFailureException",
            $fault: "server",
            ...opts,
        });
        this.name = "ServiceFailureException";
        this.$fault = "server";
        Object.setPrototypeOf(this, ServiceFailureException.prototype);
    }
}
exports.ServiceFailureException = ServiceFailureException;
class EntityAlreadyExistsException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "EntityAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "EntityAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, EntityAlreadyExistsException.prototype);
    }
}
exports.EntityAlreadyExistsException = EntityAlreadyExistsException;
class UnmodifiableEntityException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "UnmodifiableEntityException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnmodifiableEntityException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnmodifiableEntityException.prototype);
    }
}
exports.UnmodifiableEntityException = UnmodifiableEntityException;
exports.AssignmentStatusType = {
    Any: "Any",
    Assigned: "Assigned",
    Unassigned: "Unassigned",
};
exports.PermissionsBoundaryAttachmentType = {
    Policy: "PermissionsBoundaryPolicy",
};
class PolicyNotAttachableException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "PolicyNotAttachableException",
            $fault: "client",
            ...opts,
        });
        this.name = "PolicyNotAttachableException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PolicyNotAttachableException.prototype);
    }
}
exports.PolicyNotAttachableException = PolicyNotAttachableException;
class EntityTemporarilyUnmodifiableException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "EntityTemporarilyUnmodifiableException",
            $fault: "client",
            ...opts,
        });
        this.name = "EntityTemporarilyUnmodifiableException";
        this.$fault = "client";
        Object.setPrototypeOf(this, EntityTemporarilyUnmodifiableException.prototype);
    }
}
exports.EntityTemporarilyUnmodifiableException = EntityTemporarilyUnmodifiableException;
class InvalidUserTypeException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidUserTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidUserTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidUserTypeException.prototype);
    }
}
exports.InvalidUserTypeException = InvalidUserTypeException;
class PasswordPolicyViolationException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "PasswordPolicyViolationException",
            $fault: "client",
            ...opts,
        });
        this.name = "PasswordPolicyViolationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PasswordPolicyViolationException.prototype);
    }
}
exports.PasswordPolicyViolationException = PasswordPolicyViolationException;
class ConcurrentModificationException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "ConcurrentModificationException",
            $fault: "client",
            ...opts,
        });
        this.name = "ConcurrentModificationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
    }
}
exports.ConcurrentModificationException = ConcurrentModificationException;
class MalformedPolicyDocumentException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedPolicyDocumentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
}
exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;
class ServiceNotSupportedException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "ServiceNotSupportedException",
            $fault: "client",
            ...opts,
        });
        this.name = "ServiceNotSupportedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ServiceNotSupportedException.prototype);
    }
}
exports.ServiceNotSupportedException = ServiceNotSupportedException;
class DeleteConflictException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "DeleteConflictException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeleteConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeleteConflictException.prototype);
    }
}
exports.DeleteConflictException = DeleteConflictException;
class InvalidAuthenticationCodeException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidAuthenticationCodeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAuthenticationCodeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAuthenticationCodeException.prototype);
    }
}
exports.InvalidAuthenticationCodeException = InvalidAuthenticationCodeException;
exports.ReportStateType = {
    COMPLETE: "COMPLETE",
    INPROGRESS: "INPROGRESS",
    STARTED: "STARTED",
};
class ReportGenerationLimitExceededException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "ReportGenerationLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ReportGenerationLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ReportGenerationLimitExceededException.prototype);
    }
}
exports.ReportGenerationLimitExceededException = ReportGenerationLimitExceededException;
exports.EntityType = {
    AWSManagedPolicy: "AWSManagedPolicy",
    Group: "Group",
    LocalManagedPolicy: "LocalManagedPolicy",
    Role: "Role",
    User: "User",
};
exports.SummaryKeyType = {
    AccessKeysPerUserQuota: "AccessKeysPerUserQuota",
    AccountAccessKeysPresent: "AccountAccessKeysPresent",
    AccountMFAEnabled: "AccountMFAEnabled",
    AccountSigningCertificatesPresent: "AccountSigningCertificatesPresent",
    AttachedPoliciesPerGroupQuota: "AttachedPoliciesPerGroupQuota",
    AttachedPoliciesPerRoleQuota: "AttachedPoliciesPerRoleQuota",
    AttachedPoliciesPerUserQuota: "AttachedPoliciesPerUserQuota",
    GlobalEndpointTokenVersion: "GlobalEndpointTokenVersion",
    GroupPolicySizeQuota: "GroupPolicySizeQuota",
    Groups: "Groups",
    GroupsPerUserQuota: "GroupsPerUserQuota",
    GroupsQuota: "GroupsQuota",
    MFADevices: "MFADevices",
    MFADevicesInUse: "MFADevicesInUse",
    Policies: "Policies",
    PoliciesQuota: "PoliciesQuota",
    PolicySizeQuota: "PolicySizeQuota",
    PolicyVersionsInUse: "PolicyVersionsInUse",
    PolicyVersionsInUseQuota: "PolicyVersionsInUseQuota",
    ServerCertificates: "ServerCertificates",
    ServerCertificatesQuota: "ServerCertificatesQuota",
    SigningCertificatesPerUserQuota: "SigningCertificatesPerUserQuota",
    UserPolicySizeQuota: "UserPolicySizeQuota",
    Users: "Users",
    UsersQuota: "UsersQuota",
    VersionsPerPolicyQuota: "VersionsPerPolicyQuota",
};
class CredentialReportExpiredException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "CredentialReportExpiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "CredentialReportExpiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, CredentialReportExpiredException.prototype);
    }
}
exports.CredentialReportExpiredException = CredentialReportExpiredException;
class CredentialReportNotPresentException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "CredentialReportNotPresentException",
            $fault: "client",
            ...opts,
        });
        this.name = "CredentialReportNotPresentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, CredentialReportNotPresentException.prototype);
    }
}
exports.CredentialReportNotPresentException = CredentialReportNotPresentException;
class CredentialReportNotReadyException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "CredentialReportNotReadyException",
            $fault: "client",
            ...opts,
        });
        this.name = "CredentialReportNotReadyException";
        this.$fault = "client";
        Object.setPrototypeOf(this, CredentialReportNotReadyException.prototype);
    }
}
exports.CredentialReportNotReadyException = CredentialReportNotReadyException;
exports.ReportFormatType = {
    text_csv: "text/csv",
};
exports.SortKeyType = {
    LAST_AUTHENTICATED_TIME_ASCENDING: "LAST_AUTHENTICATED_TIME_ASCENDING",
    LAST_AUTHENTICATED_TIME_DESCENDING: "LAST_AUTHENTICATED_TIME_DESCENDING",
    SERVICE_NAMESPACE_ASCENDING: "SERVICE_NAMESPACE_ASCENDING",
    SERVICE_NAMESPACE_DESCENDING: "SERVICE_NAMESPACE_DESCENDING",
};
exports.JobStatusType = {
    COMPLETED: "COMPLETED",
    FAILED: "FAILED",
    IN_PROGRESS: "IN_PROGRESS",
};
exports.PolicyOwnerEntityType = {
    GROUP: "GROUP",
    ROLE: "ROLE",
    USER: "USER",
};
exports.DeletionTaskStatusType = {
    FAILED: "FAILED",
    IN_PROGRESS: "IN_PROGRESS",
    NOT_STARTED: "NOT_STARTED",
    SUCCEEDED: "SUCCEEDED",
};
exports.EncodingType = {
    PEM: "PEM",
    SSH: "SSH",
};
class UnrecognizedPublicKeyEncodingException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "UnrecognizedPublicKeyEncodingException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnrecognizedPublicKeyEncodingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnrecognizedPublicKeyEncodingException.prototype);
    }
}
exports.UnrecognizedPublicKeyEncodingException = UnrecognizedPublicKeyEncodingException;
exports.PolicyUsageType = {
    PermissionsBoundary: "PermissionsBoundary",
    PermissionsPolicy: "PermissionsPolicy",
};
exports.PolicyScopeType = {
    AWS: "AWS",
    All: "All",
    Local: "Local",
};
exports.PolicyType = {
    INLINE: "INLINE",
    MANAGED: "MANAGED",
};
exports.GlobalEndpointTokenVersion = {
    v1Token: "v1Token",
    v2Token: "v2Token",
};
class PolicyEvaluationException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "PolicyEvaluationException",
            $fault: "server",
            ...opts,
        });
        this.name = "PolicyEvaluationException";
        this.$fault = "server";
        Object.setPrototypeOf(this, PolicyEvaluationException.prototype);
    }
}
exports.PolicyEvaluationException = PolicyEvaluationException;
exports.ContextKeyTypeEnum = {
    BINARY: "binary",
    BINARY_LIST: "binaryList",
    BOOLEAN: "boolean",
    BOOLEAN_LIST: "booleanList",
    DATE: "date",
    DATE_LIST: "dateList",
    IP: "ip",
    IP_LIST: "ipList",
    NUMERIC: "numeric",
    NUMERIC_LIST: "numericList",
    STRING: "string",
    STRING_LIST: "stringList",
};
exports.PolicyEvaluationDecisionType = {
    ALLOWED: "allowed",
    EXPLICIT_DENY: "explicitDeny",
    IMPLICIT_DENY: "implicitDeny",
};
exports.PolicySourceType = {
    AWS_MANAGED: "aws-managed",
    GROUP: "group",
    NONE: "none",
    RESOURCE: "resource",
    ROLE: "role",
    USER: "user",
    USER_MANAGED: "user-managed",
};
const AccessKeyFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SecretAccessKey && { SecretAccessKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.AccessKeyFilterSensitiveLog = AccessKeyFilterSensitiveLog;
const ChangePasswordRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.OldPassword && { OldPassword: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.NewPassword && { NewPassword: smithy_client_1.SENSITIVE_STRING }),
});
exports.ChangePasswordRequestFilterSensitiveLog = ChangePasswordRequestFilterSensitiveLog;
const CreateAccessKeyResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.AccessKey && { AccessKey: (0, exports.AccessKeyFilterSensitiveLog)(obj.AccessKey) }),
});
exports.CreateAccessKeyResponseFilterSensitiveLog = CreateAccessKeyResponseFilterSensitiveLog;
const CreateLoginProfileRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Password && { Password: smithy_client_1.SENSITIVE_STRING }),
});
exports.CreateLoginProfileRequestFilterSensitiveLog = CreateLoginProfileRequestFilterSensitiveLog;
const ServiceSpecificCredentialFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ServicePassword && { ServicePassword: smithy_client_1.SENSITIVE_STRING }),
});
exports.ServiceSpecificCredentialFilterSensitiveLog = ServiceSpecificCredentialFilterSensitiveLog;
const CreateServiceSpecificCredentialResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ServiceSpecificCredential && {
        ServiceSpecificCredential: (0, exports.ServiceSpecificCredentialFilterSensitiveLog)(obj.ServiceSpecificCredential),
    }),
});
exports.CreateServiceSpecificCredentialResponseFilterSensitiveLog = CreateServiceSpecificCredentialResponseFilterSensitiveLog;
const VirtualMFADeviceFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Base32StringSeed && { Base32StringSeed: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.QRCodePNG && { QRCodePNG: smithy_client_1.SENSITIVE_STRING }),
});
exports.VirtualMFADeviceFilterSensitiveLog = VirtualMFADeviceFilterSensitiveLog;
const CreateVirtualMFADeviceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.VirtualMFADevice && { VirtualMFADevice: (0, exports.VirtualMFADeviceFilterSensitiveLog)(obj.VirtualMFADevice) }),
});
exports.CreateVirtualMFADeviceResponseFilterSensitiveLog = CreateVirtualMFADeviceResponseFilterSensitiveLog;
const ListVirtualMFADevicesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.VirtualMFADevices && {
        VirtualMFADevices: obj.VirtualMFADevices.map((item) => (0, exports.VirtualMFADeviceFilterSensitiveLog)(item)),
    }),
});
exports.ListVirtualMFADevicesResponseFilterSensitiveLog = ListVirtualMFADevicesResponseFilterSensitiveLog;
const ResetServiceSpecificCredentialResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ServiceSpecificCredential && {
        ServiceSpecificCredential: (0, exports.ServiceSpecificCredentialFilterSensitiveLog)(obj.ServiceSpecificCredential),
    }),
});
exports.ResetServiceSpecificCredentialResponseFilterSensitiveLog = ResetServiceSpecificCredentialResponseFilterSensitiveLog;


/***/ }),

/***/ 58414:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploadServerCertificateRequestFilterSensitiveLog = exports.UpdateLoginProfileRequestFilterSensitiveLog = exports.InvalidPublicKeyException = exports.DuplicateSSHPublicKeyException = exports.InvalidCertificateException = exports.DuplicateCertificateException = exports.MalformedCertificateException = exports.KeyPairMismatchException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const IAMServiceException_1 = __nccwpck_require__(40103);
class KeyPairMismatchException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "KeyPairMismatchException",
            $fault: "client",
            ...opts,
        });
        this.name = "KeyPairMismatchException";
        this.$fault = "client";
        Object.setPrototypeOf(this, KeyPairMismatchException.prototype);
    }
}
exports.KeyPairMismatchException = KeyPairMismatchException;
class MalformedCertificateException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "MalformedCertificateException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedCertificateException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedCertificateException.prototype);
    }
}
exports.MalformedCertificateException = MalformedCertificateException;
class DuplicateCertificateException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "DuplicateCertificateException",
            $fault: "client",
            ...opts,
        });
        this.name = "DuplicateCertificateException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DuplicateCertificateException.prototype);
    }
}
exports.DuplicateCertificateException = DuplicateCertificateException;
class InvalidCertificateException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidCertificateException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidCertificateException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidCertificateException.prototype);
    }
}
exports.InvalidCertificateException = InvalidCertificateException;
class DuplicateSSHPublicKeyException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "DuplicateSSHPublicKeyException",
            $fault: "client",
            ...opts,
        });
        this.name = "DuplicateSSHPublicKeyException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DuplicateSSHPublicKeyException.prototype);
    }
}
exports.DuplicateSSHPublicKeyException = DuplicateSSHPublicKeyException;
class InvalidPublicKeyException extends IAMServiceException_1.IAMServiceException {
    constructor(opts) {
        super({
            name: "InvalidPublicKeyException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidPublicKeyException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidPublicKeyException.prototype);
    }
}
exports.InvalidPublicKeyException = InvalidPublicKeyException;
const UpdateLoginProfileRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Password && { Password: smithy_client_1.SENSITIVE_STRING }),
});
exports.UpdateLoginProfileRequestFilterSensitiveLog = UpdateLoginProfileRequestFilterSensitiveLog;
const UploadServerCertificateRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.PrivateKey && { PrivateKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.UploadServerCertificateRequestFilterSensitiveLog = UploadServerCertificateRequestFilterSensitiveLog;


/***/ }),

/***/ 71519:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateGetAccountAuthorizationDetails = void 0;
const GetAccountAuthorizationDetailsCommand_1 = __nccwpck_require__(88568);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new GetAccountAuthorizationDetailsCommand_1.GetAccountAuthorizationDetailsCommand(input), ...args);
};
async function* paginateGetAccountAuthorizationDetails(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateGetAccountAuthorizationDetails = paginateGetAccountAuthorizationDetails;


/***/ }),

/***/ 36733:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateGetGroup = void 0;
const GetGroupCommand_1 = __nccwpck_require__(85392);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new GetGroupCommand_1.GetGroupCommand(input), ...args);
};
async function* paginateGetGroup(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateGetGroup = paginateGetGroup;


/***/ }),

/***/ 99845:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 74270:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccessKeys = void 0;
const ListAccessKeysCommand_1 = __nccwpck_require__(97373);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAccessKeysCommand_1.ListAccessKeysCommand(input), ...args);
};
async function* paginateListAccessKeys(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccessKeys = paginateListAccessKeys;


/***/ }),

/***/ 80190:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccountAliases = void 0;
const ListAccountAliasesCommand_1 = __nccwpck_require__(64599);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAccountAliasesCommand_1.ListAccountAliasesCommand(input), ...args);
};
async function* paginateListAccountAliases(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccountAliases = paginateListAccountAliases;


/***/ }),

/***/ 82459:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAttachedGroupPolicies = void 0;
const ListAttachedGroupPoliciesCommand_1 = __nccwpck_require__(78313);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAttachedGroupPoliciesCommand_1.ListAttachedGroupPoliciesCommand(input), ...args);
};
async function* paginateListAttachedGroupPolicies(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAttachedGroupPolicies = paginateListAttachedGroupPolicies;


/***/ }),

/***/ 84285:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAttachedRolePolicies = void 0;
const ListAttachedRolePoliciesCommand_1 = __nccwpck_require__(79686);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAttachedRolePoliciesCommand_1.ListAttachedRolePoliciesCommand(input), ...args);
};
async function* paginateListAttachedRolePolicies(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAttachedRolePolicies = paginateListAttachedRolePolicies;


/***/ }),

/***/ 89195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAttachedUserPolicies = void 0;
const ListAttachedUserPoliciesCommand_1 = __nccwpck_require__(31818);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAttachedUserPoliciesCommand_1.ListAttachedUserPoliciesCommand(input), ...args);
};
async function* paginateListAttachedUserPolicies(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAttachedUserPolicies = paginateListAttachedUserPolicies;


/***/ }),

/***/ 99707:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListEntitiesForPolicy = void 0;
const ListEntitiesForPolicyCommand_1 = __nccwpck_require__(48813);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListEntitiesForPolicyCommand_1.ListEntitiesForPolicyCommand(input), ...args);
};
async function* paginateListEntitiesForPolicy(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListEntitiesForPolicy = paginateListEntitiesForPolicy;


/***/ }),

/***/ 7845:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListGroupPolicies = void 0;
const ListGroupPoliciesCommand_1 = __nccwpck_require__(23819);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListGroupPoliciesCommand_1.ListGroupPoliciesCommand(input), ...args);
};
async function* paginateListGroupPolicies(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListGroupPolicies = paginateListGroupPolicies;


/***/ }),

/***/ 57709:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListGroupsForUser = void 0;
const ListGroupsForUserCommand_1 = __nccwpck_require__(29368);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListGroupsForUserCommand_1.ListGroupsForUserCommand(input), ...args);
};
async function* paginateListGroupsForUser(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListGroupsForUser = paginateListGroupsForUser;


/***/ }),

/***/ 93178:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListGroups = void 0;
const ListGroupsCommand_1 = __nccwpck_require__(53646);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListGroupsCommand_1.ListGroupsCommand(input), ...args);
};
async function* paginateListGroups(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListGroups = paginateListGroups;


/***/ }),

/***/ 49177:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListInstanceProfileTags = void 0;
const ListInstanceProfileTagsCommand_1 = __nccwpck_require__(58238);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListInstanceProfileTagsCommand_1.ListInstanceProfileTagsCommand(input), ...args);
};
async function* paginateListInstanceProfileTags(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListInstanceProfileTags = paginateListInstanceProfileTags;


/***/ }),

/***/ 6253:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListInstanceProfilesForRole = void 0;
const ListInstanceProfilesForRoleCommand_1 = __nccwpck_require__(36897);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListInstanceProfilesForRoleCommand_1.ListInstanceProfilesForRoleCommand(input), ...args);
};
async function* paginateListInstanceProfilesForRole(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListInstanceProfilesForRole = paginateListInstanceProfilesForRole;


/***/ }),

/***/ 12696:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListInstanceProfiles = void 0;
const ListInstanceProfilesCommand_1 = __nccwpck_require__(90361);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListInstanceProfilesCommand_1.ListInstanceProfilesCommand(input), ...args);
};
async function* paginateListInstanceProfiles(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListInstanceProfiles = paginateListInstanceProfiles;


/***/ }),

/***/ 1626:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListMFADeviceTags = void 0;
const ListMFADeviceTagsCommand_1 = __nccwpck_require__(93043);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListMFADeviceTagsCommand_1.ListMFADeviceTagsCommand(input), ...args);
};
async function* paginateListMFADeviceTags(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListMFADeviceTags = paginateListMFADeviceTags;


/***/ }),

/***/ 30952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListMFADevices = void 0;
const ListMFADevicesCommand_1 = __nccwpck_require__(30008);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListMFADevicesCommand_1.ListMFADevicesCommand(input), ...args);
};
async function* paginateListMFADevices(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListMFADevices = paginateListMFADevices;


/***/ }),

/***/ 18340:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListOpenIDConnectProviderTags = void 0;
const ListOpenIDConnectProviderTagsCommand_1 = __nccwpck_require__(16844);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListOpenIDConnectProviderTagsCommand_1.ListOpenIDConnectProviderTagsCommand(input), ...args);
};
async function* paginateListOpenIDConnectProviderTags(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListOpenIDConnectProviderTags = paginateListOpenIDConnectProviderTags;


/***/ }),

/***/ 68397:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListPolicies = void 0;
const ListPoliciesCommand_1 = __nccwpck_require__(8349);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListPoliciesCommand_1.ListPoliciesCommand(input), ...args);
};
async function* paginateListPolicies(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListPolicies = paginateListPolicies;


/***/ }),

/***/ 81237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListPolicyTags = void 0;
const ListPolicyTagsCommand_1 = __nccwpck_require__(60264);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListPolicyTagsCommand_1.ListPolicyTagsCommand(input), ...args);
};
async function* paginateListPolicyTags(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListPolicyTags = paginateListPolicyTags;


/***/ }),

/***/ 25893:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListPolicyVersions = void 0;
const ListPolicyVersionsCommand_1 = __nccwpck_require__(92250);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListPolicyVersionsCommand_1.ListPolicyVersionsCommand(input), ...args);
};
async function* paginateListPolicyVersions(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListPolicyVersions = paginateListPolicyVersions;


/***/ }),

/***/ 43150:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListRolePolicies = void 0;
const ListRolePoliciesCommand_1 = __nccwpck_require__(27265);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListRolePoliciesCommand_1.ListRolePoliciesCommand(input), ...args);
};
async function* paginateListRolePolicies(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListRolePolicies = paginateListRolePolicies;


/***/ }),

/***/ 54763:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListRoleTags = void 0;
const ListRoleTagsCommand_1 = __nccwpck_require__(37);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListRoleTagsCommand_1.ListRoleTagsCommand(input), ...args);
};
async function* paginateListRoleTags(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListRoleTags = paginateListRoleTags;


/***/ }),

/***/ 42003:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListRoles = void 0;
const ListRolesCommand_1 = __nccwpck_require__(86805);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListRolesCommand_1.ListRolesCommand(input), ...args);
};
async function* paginateListRoles(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListRoles = paginateListRoles;


/***/ }),

/***/ 84756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListSAMLProviderTags = void 0;
const ListSAMLProviderTagsCommand_1 = __nccwpck_require__(82416);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListSAMLProviderTagsCommand_1.ListSAMLProviderTagsCommand(input), ...args);
};
async function* paginateListSAMLProviderTags(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListSAMLProviderTags = paginateListSAMLProviderTags;


/***/ }),

/***/ 51318:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListSSHPublicKeys = void 0;
const ListSSHPublicKeysCommand_1 = __nccwpck_require__(34152);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListSSHPublicKeysCommand_1.ListSSHPublicKeysCommand(input), ...args);
};
async function* paginateListSSHPublicKeys(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListSSHPublicKeys = paginateListSSHPublicKeys;


/***/ }),

/***/ 24486:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListServerCertificateTags = void 0;
const ListServerCertificateTagsCommand_1 = __nccwpck_require__(8474);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListServerCertificateTagsCommand_1.ListServerCertificateTagsCommand(input), ...args);
};
async function* paginateListServerCertificateTags(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListServerCertificateTags = paginateListServerCertificateTags;


/***/ }),

/***/ 20443:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListServerCertificates = void 0;
const ListServerCertificatesCommand_1 = __nccwpck_require__(75768);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListServerCertificatesCommand_1.ListServerCertificatesCommand(input), ...args);
};
async function* paginateListServerCertificates(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListServerCertificates = paginateListServerCertificates;


/***/ }),

/***/ 91132:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListSigningCertificates = void 0;
const ListSigningCertificatesCommand_1 = __nccwpck_require__(35966);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListSigningCertificatesCommand_1.ListSigningCertificatesCommand(input), ...args);
};
async function* paginateListSigningCertificates(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListSigningCertificates = paginateListSigningCertificates;


/***/ }),

/***/ 77729:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListUserPolicies = void 0;
const ListUserPoliciesCommand_1 = __nccwpck_require__(83440);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListUserPoliciesCommand_1.ListUserPoliciesCommand(input), ...args);
};
async function* paginateListUserPolicies(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListUserPolicies = paginateListUserPolicies;


/***/ }),

/***/ 29312:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListUserTags = void 0;
const ListUserTagsCommand_1 = __nccwpck_require__(39245);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListUserTagsCommand_1.ListUserTagsCommand(input), ...args);
};
async function* paginateListUserTags(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListUserTags = paginateListUserTags;


/***/ }),

/***/ 24554:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListUsers = void 0;
const ListUsersCommand_1 = __nccwpck_require__(94234);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListUsersCommand_1.ListUsersCommand(input), ...args);
};
async function* paginateListUsers(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListUsers = paginateListUsers;


/***/ }),

/***/ 87953:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListVirtualMFADevices = void 0;
const ListVirtualMFADevicesCommand_1 = __nccwpck_require__(5950);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListVirtualMFADevicesCommand_1.ListVirtualMFADevicesCommand(input), ...args);
};
async function* paginateListVirtualMFADevices(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListVirtualMFADevices = paginateListVirtualMFADevices;


/***/ }),

/***/ 81444:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateSimulateCustomPolicy = void 0;
const SimulateCustomPolicyCommand_1 = __nccwpck_require__(48453);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new SimulateCustomPolicyCommand_1.SimulateCustomPolicyCommand(input), ...args);
};
async function* paginateSimulateCustomPolicy(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateSimulateCustomPolicy = paginateSimulateCustomPolicy;


/***/ }),

/***/ 30685:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateSimulatePrincipalPolicy = void 0;
const SimulatePrincipalPolicyCommand_1 = __nccwpck_require__(33979);
const IAMClient_1 = __nccwpck_require__(8652);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new SimulatePrincipalPolicyCommand_1.SimulatePrincipalPolicyCommand(input), ...args);
};
async function* paginateSimulatePrincipalPolicy(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.Marker = token;
        input["MaxItems"] = config.pageSize;
        if (config.client instanceof IAMClient_1.IAMClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected IAM | IAMClient");
        }
        yield page;
        const prevToken = token;
        token = page.Marker;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateSimulatePrincipalPolicy = paginateSimulatePrincipalPolicy;


/***/ }),

/***/ 92723:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(71519), exports);
tslib_1.__exportStar(__nccwpck_require__(36733), exports);
tslib_1.__exportStar(__nccwpck_require__(99845), exports);
tslib_1.__exportStar(__nccwpck_require__(74270), exports);
tslib_1.__exportStar(__nccwpck_require__(80190), exports);
tslib_1.__exportStar(__nccwpck_require__(82459), exports);
tslib_1.__exportStar(__nccwpck_require__(84285), exports);
tslib_1.__exportStar(__nccwpck_require__(89195), exports);
tslib_1.__exportStar(__nccwpck_require__(99707), exports);
tslib_1.__exportStar(__nccwpck_require__(7845), exports);
tslib_1.__exportStar(__nccwpck_require__(57709), exports);
tslib_1.__exportStar(__nccwpck_require__(93178), exports);
tslib_1.__exportStar(__nccwpck_require__(49177), exports);
tslib_1.__exportStar(__nccwpck_require__(6253), exports);
tslib_1.__exportStar(__nccwpck_require__(12696), exports);
tslib_1.__exportStar(__nccwpck_require__(1626), exports);
tslib_1.__exportStar(__nccwpck_require__(30952), exports);
tslib_1.__exportStar(__nccwpck_require__(18340), exports);
tslib_1.__exportStar(__nccwpck_require__(68397), exports);
tslib_1.__exportStar(__nccwpck_require__(81237), exports);
tslib_1.__exportStar(__nccwpck_require__(25893), exports);
tslib_1.__exportStar(__nccwpck_require__(43150), exports);
tslib_1.__exportStar(__nccwpck_require__(54763), exports);
tslib_1.__exportStar(__nccwpck_require__(42003), exports);
tslib_1.__exportStar(__nccwpck_require__(84756), exports);
tslib_1.__exportStar(__nccwpck_require__(51318), exports);
tslib_1.__exportStar(__nccwpck_require__(24486), exports);
tslib_1.__exportStar(__nccwpck_require__(20443), exports);
tslib_1.__exportStar(__nccwpck_require__(91132), exports);
tslib_1.__exportStar(__nccwpck_require__(77729), exports);
tslib_1.__exportStar(__nccwpck_require__(29312), exports);
tslib_1.__exportStar(__nccwpck_require__(24554), exports);
tslib_1.__exportStar(__nccwpck_require__(87953), exports);
tslib_1.__exportStar(__nccwpck_require__(81444), exports);
tslib_1.__exportStar(__nccwpck_require__(30685), exports);


/***/ }),

/***/ 12786:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.se_GenerateCredentialReportCommand = exports.se_EnableMFADeviceCommand = exports.se_DetachUserPolicyCommand = exports.se_DetachRolePolicyCommand = exports.se_DetachGroupPolicyCommand = exports.se_DeleteVirtualMFADeviceCommand = exports.se_DeleteUserPolicyCommand = exports.se_DeleteUserPermissionsBoundaryCommand = exports.se_DeleteUserCommand = exports.se_DeleteSSHPublicKeyCommand = exports.se_DeleteSigningCertificateCommand = exports.se_DeleteServiceSpecificCredentialCommand = exports.se_DeleteServiceLinkedRoleCommand = exports.se_DeleteServerCertificateCommand = exports.se_DeleteSAMLProviderCommand = exports.se_DeleteRolePolicyCommand = exports.se_DeleteRolePermissionsBoundaryCommand = exports.se_DeleteRoleCommand = exports.se_DeletePolicyVersionCommand = exports.se_DeletePolicyCommand = exports.se_DeleteOpenIDConnectProviderCommand = exports.se_DeleteLoginProfileCommand = exports.se_DeleteInstanceProfileCommand = exports.se_DeleteGroupPolicyCommand = exports.se_DeleteGroupCommand = exports.se_DeleteAccountPasswordPolicyCommand = exports.se_DeleteAccountAliasCommand = exports.se_DeleteAccessKeyCommand = exports.se_DeactivateMFADeviceCommand = exports.se_CreateVirtualMFADeviceCommand = exports.se_CreateUserCommand = exports.se_CreateServiceSpecificCredentialCommand = exports.se_CreateServiceLinkedRoleCommand = exports.se_CreateSAMLProviderCommand = exports.se_CreateRoleCommand = exports.se_CreatePolicyVersionCommand = exports.se_CreatePolicyCommand = exports.se_CreateOpenIDConnectProviderCommand = exports.se_CreateLoginProfileCommand = exports.se_CreateInstanceProfileCommand = exports.se_CreateGroupCommand = exports.se_CreateAccountAliasCommand = exports.se_CreateAccessKeyCommand = exports.se_ChangePasswordCommand = exports.se_AttachUserPolicyCommand = exports.se_AttachRolePolicyCommand = exports.se_AttachGroupPolicyCommand = exports.se_AddUserToGroupCommand = exports.se_AddRoleToInstanceProfileCommand = exports.se_AddClientIDToOpenIDConnectProviderCommand = void 0;
exports.se_ListRolesCommand = exports.se_ListRolePoliciesCommand = exports.se_ListPolicyVersionsCommand = exports.se_ListPolicyTagsCommand = exports.se_ListPoliciesGrantingServiceAccessCommand = exports.se_ListPoliciesCommand = exports.se_ListOpenIDConnectProviderTagsCommand = exports.se_ListOpenIDConnectProvidersCommand = exports.se_ListMFADeviceTagsCommand = exports.se_ListMFADevicesCommand = exports.se_ListInstanceProfileTagsCommand = exports.se_ListInstanceProfilesForRoleCommand = exports.se_ListInstanceProfilesCommand = exports.se_ListGroupsForUserCommand = exports.se_ListGroupsCommand = exports.se_ListGroupPoliciesCommand = exports.se_ListEntitiesForPolicyCommand = exports.se_ListAttachedUserPoliciesCommand = exports.se_ListAttachedRolePoliciesCommand = exports.se_ListAttachedGroupPoliciesCommand = exports.se_ListAccountAliasesCommand = exports.se_ListAccessKeysCommand = exports.se_GetUserPolicyCommand = exports.se_GetUserCommand = exports.se_GetSSHPublicKeyCommand = exports.se_GetServiceLinkedRoleDeletionStatusCommand = exports.se_GetServiceLastAccessedDetailsWithEntitiesCommand = exports.se_GetServiceLastAccessedDetailsCommand = exports.se_GetServerCertificateCommand = exports.se_GetSAMLProviderCommand = exports.se_GetRolePolicyCommand = exports.se_GetRoleCommand = exports.se_GetPolicyVersionCommand = exports.se_GetPolicyCommand = exports.se_GetOrganizationsAccessReportCommand = exports.se_GetOpenIDConnectProviderCommand = exports.se_GetMFADeviceCommand = exports.se_GetLoginProfileCommand = exports.se_GetInstanceProfileCommand = exports.se_GetGroupPolicyCommand = exports.se_GetGroupCommand = exports.se_GetCredentialReportCommand = exports.se_GetContextKeysForPrincipalPolicyCommand = exports.se_GetContextKeysForCustomPolicyCommand = exports.se_GetAccountSummaryCommand = exports.se_GetAccountPasswordPolicyCommand = exports.se_GetAccountAuthorizationDetailsCommand = exports.se_GetAccessKeyLastUsedCommand = exports.se_GenerateServiceLastAccessedDetailsCommand = exports.se_GenerateOrganizationsAccessReportCommand = void 0;
exports.se_UpdateRoleDescriptionCommand = exports.se_UpdateRoleCommand = exports.se_UpdateOpenIDConnectProviderThumbprintCommand = exports.se_UpdateLoginProfileCommand = exports.se_UpdateGroupCommand = exports.se_UpdateAssumeRolePolicyCommand = exports.se_UpdateAccountPasswordPolicyCommand = exports.se_UpdateAccessKeyCommand = exports.se_UntagUserCommand = exports.se_UntagServerCertificateCommand = exports.se_UntagSAMLProviderCommand = exports.se_UntagRoleCommand = exports.se_UntagPolicyCommand = exports.se_UntagOpenIDConnectProviderCommand = exports.se_UntagMFADeviceCommand = exports.se_UntagInstanceProfileCommand = exports.se_TagUserCommand = exports.se_TagServerCertificateCommand = exports.se_TagSAMLProviderCommand = exports.se_TagRoleCommand = exports.se_TagPolicyCommand = exports.se_TagOpenIDConnectProviderCommand = exports.se_TagMFADeviceCommand = exports.se_TagInstanceProfileCommand = exports.se_SimulatePrincipalPolicyCommand = exports.se_SimulateCustomPolicyCommand = exports.se_SetSecurityTokenServicePreferencesCommand = exports.se_SetDefaultPolicyVersionCommand = exports.se_ResyncMFADeviceCommand = exports.se_ResetServiceSpecificCredentialCommand = exports.se_RemoveUserFromGroupCommand = exports.se_RemoveRoleFromInstanceProfileCommand = exports.se_RemoveClientIDFromOpenIDConnectProviderCommand = exports.se_PutUserPolicyCommand = exports.se_PutUserPermissionsBoundaryCommand = exports.se_PutRolePolicyCommand = exports.se_PutRolePermissionsBoundaryCommand = exports.se_PutGroupPolicyCommand = exports.se_ListVirtualMFADevicesCommand = exports.se_ListUserTagsCommand = exports.se_ListUsersCommand = exports.se_ListUserPoliciesCommand = exports.se_ListSSHPublicKeysCommand = exports.se_ListSigningCertificatesCommand = exports.se_ListServiceSpecificCredentialsCommand = exports.se_ListServerCertificateTagsCommand = exports.se_ListServerCertificatesCommand = exports.se_ListSAMLProviderTagsCommand = exports.se_ListSAMLProvidersCommand = exports.se_ListRoleTagsCommand = void 0;
exports.de_DeleteSSHPublicKeyCommand = exports.de_DeleteSigningCertificateCommand = exports.de_DeleteServiceSpecificCredentialCommand = exports.de_DeleteServiceLinkedRoleCommand = exports.de_DeleteServerCertificateCommand = exports.de_DeleteSAMLProviderCommand = exports.de_DeleteRolePolicyCommand = exports.de_DeleteRolePermissionsBoundaryCommand = exports.de_DeleteRoleCommand = exports.de_DeletePolicyVersionCommand = exports.de_DeletePolicyCommand = exports.de_DeleteOpenIDConnectProviderCommand = exports.de_DeleteLoginProfileCommand = exports.de_DeleteInstanceProfileCommand = exports.de_DeleteGroupPolicyCommand = exports.de_DeleteGroupCommand = exports.de_DeleteAccountPasswordPolicyCommand = exports.de_DeleteAccountAliasCommand = exports.de_DeleteAccessKeyCommand = exports.de_DeactivateMFADeviceCommand = exports.de_CreateVirtualMFADeviceCommand = exports.de_CreateUserCommand = exports.de_CreateServiceSpecificCredentialCommand = exports.de_CreateServiceLinkedRoleCommand = exports.de_CreateSAMLProviderCommand = exports.de_CreateRoleCommand = exports.de_CreatePolicyVersionCommand = exports.de_CreatePolicyCommand = exports.de_CreateOpenIDConnectProviderCommand = exports.de_CreateLoginProfileCommand = exports.de_CreateInstanceProfileCommand = exports.de_CreateGroupCommand = exports.de_CreateAccountAliasCommand = exports.de_CreateAccessKeyCommand = exports.de_ChangePasswordCommand = exports.de_AttachUserPolicyCommand = exports.de_AttachRolePolicyCommand = exports.de_AttachGroupPolicyCommand = exports.de_AddUserToGroupCommand = exports.de_AddRoleToInstanceProfileCommand = exports.de_AddClientIDToOpenIDConnectProviderCommand = exports.se_UploadSSHPublicKeyCommand = exports.se_UploadSigningCertificateCommand = exports.se_UploadServerCertificateCommand = exports.se_UpdateUserCommand = exports.se_UpdateSSHPublicKeyCommand = exports.se_UpdateSigningCertificateCommand = exports.se_UpdateServiceSpecificCredentialCommand = exports.se_UpdateServerCertificateCommand = exports.se_UpdateSAMLProviderCommand = void 0;
exports.de_ListMFADevicesCommand = exports.de_ListInstanceProfileTagsCommand = exports.de_ListInstanceProfilesForRoleCommand = exports.de_ListInstanceProfilesCommand = exports.de_ListGroupsForUserCommand = exports.de_ListGroupsCommand = exports.de_ListGroupPoliciesCommand = exports.de_ListEntitiesForPolicyCommand = exports.de_ListAttachedUserPoliciesCommand = exports.de_ListAttachedRolePoliciesCommand = exports.de_ListAttachedGroupPoliciesCommand = exports.de_ListAccountAliasesCommand = exports.de_ListAccessKeysCommand = exports.de_GetUserPolicyCommand = exports.de_GetUserCommand = exports.de_GetSSHPublicKeyCommand = exports.de_GetServiceLinkedRoleDeletionStatusCommand = exports.de_GetServiceLastAccessedDetailsWithEntitiesCommand = exports.de_GetServiceLastAccessedDetailsCommand = exports.de_GetServerCertificateCommand = exports.de_GetSAMLProviderCommand = exports.de_GetRolePolicyCommand = exports.de_GetRoleCommand = exports.de_GetPolicyVersionCommand = exports.de_GetPolicyCommand = exports.de_GetOrganizationsAccessReportCommand = exports.de_GetOpenIDConnectProviderCommand = exports.de_GetMFADeviceCommand = exports.de_GetLoginProfileCommand = exports.de_GetInstanceProfileCommand = exports.de_GetGroupPolicyCommand = exports.de_GetGroupCommand = exports.de_GetCredentialReportCommand = exports.de_GetContextKeysForPrincipalPolicyCommand = exports.de_GetContextKeysForCustomPolicyCommand = exports.de_GetAccountSummaryCommand = exports.de_GetAccountPasswordPolicyCommand = exports.de_GetAccountAuthorizationDetailsCommand = exports.de_GetAccessKeyLastUsedCommand = exports.de_GenerateServiceLastAccessedDetailsCommand = exports.de_GenerateOrganizationsAccessReportCommand = exports.de_GenerateCredentialReportCommand = exports.de_EnableMFADeviceCommand = exports.de_DetachUserPolicyCommand = exports.de_DetachRolePolicyCommand = exports.de_DetachGroupPolicyCommand = exports.de_DeleteVirtualMFADeviceCommand = exports.de_DeleteUserPolicyCommand = exports.de_DeleteUserPermissionsBoundaryCommand = exports.de_DeleteUserCommand = void 0;
exports.de_UntagServerCertificateCommand = exports.de_UntagSAMLProviderCommand = exports.de_UntagRoleCommand = exports.de_UntagPolicyCommand = exports.de_UntagOpenIDConnectProviderCommand = exports.de_UntagMFADeviceCommand = exports.de_UntagInstanceProfileCommand = exports.de_TagUserCommand = exports.de_TagServerCertificateCommand = exports.de_TagSAMLProviderCommand = exports.de_TagRoleCommand = exports.de_TagPolicyCommand = exports.de_TagOpenIDConnectProviderCommand = exports.de_TagMFADeviceCommand = exports.de_TagInstanceProfileCommand = exports.de_SimulatePrincipalPolicyCommand = exports.de_SimulateCustomPolicyCommand = exports.de_SetSecurityTokenServicePreferencesCommand = exports.de_SetDefaultPolicyVersionCommand = exports.de_ResyncMFADeviceCommand = exports.de_ResetServiceSpecificCredentialCommand = exports.de_RemoveUserFromGroupCommand = exports.de_RemoveRoleFromInstanceProfileCommand = exports.de_RemoveClientIDFromOpenIDConnectProviderCommand = exports.de_PutUserPolicyCommand = exports.de_PutUserPermissionsBoundaryCommand = exports.de_PutRolePolicyCommand = exports.de_PutRolePermissionsBoundaryCommand = exports.de_PutGroupPolicyCommand = exports.de_ListVirtualMFADevicesCommand = exports.de_ListUserTagsCommand = exports.de_ListUsersCommand = exports.de_ListUserPoliciesCommand = exports.de_ListSSHPublicKeysCommand = exports.de_ListSigningCertificatesCommand = exports.de_ListServiceSpecificCredentialsCommand = exports.de_ListServerCertificateTagsCommand = exports.de_ListServerCertificatesCommand = exports.de_ListSAMLProviderTagsCommand = exports.de_ListSAMLProvidersCommand = exports.de_ListRoleTagsCommand = exports.de_ListRolesCommand = exports.de_ListRolePoliciesCommand = exports.de_ListPolicyVersionsCommand = exports.de_ListPolicyTagsCommand = exports.de_ListPoliciesGrantingServiceAccessCommand = exports.de_ListPoliciesCommand = exports.de_ListOpenIDConnectProviderTagsCommand = exports.de_ListOpenIDConnectProvidersCommand = exports.de_ListMFADeviceTagsCommand = void 0;
exports.de_UploadSSHPublicKeyCommand = exports.de_UploadSigningCertificateCommand = exports.de_UploadServerCertificateCommand = exports.de_UpdateUserCommand = exports.de_UpdateSSHPublicKeyCommand = exports.de_UpdateSigningCertificateCommand = exports.de_UpdateServiceSpecificCredentialCommand = exports.de_UpdateServerCertificateCommand = exports.de_UpdateSAMLProviderCommand = exports.de_UpdateRoleDescriptionCommand = exports.de_UpdateRoleCommand = exports.de_UpdateOpenIDConnectProviderThumbprintCommand = exports.de_UpdateLoginProfileCommand = exports.de_UpdateGroupCommand = exports.de_UpdateAssumeRolePolicyCommand = exports.de_UpdateAccountPasswordPolicyCommand = exports.de_UpdateAccessKeyCommand = exports.de_UntagUserCommand = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const fast_xml_parser_1 = __nccwpck_require__(12603);
const IAMServiceException_1 = __nccwpck_require__(40103);
const models_0_1 = __nccwpck_require__(18824);
const models_1_1 = __nccwpck_require__(58414);
const se_AddClientIDToOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddClientIDToOpenIDConnectProviderRequest(input, context),
        Action: "AddClientIDToOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AddClientIDToOpenIDConnectProviderCommand = se_AddClientIDToOpenIDConnectProviderCommand;
const se_AddRoleToInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddRoleToInstanceProfileRequest(input, context),
        Action: "AddRoleToInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AddRoleToInstanceProfileCommand = se_AddRoleToInstanceProfileCommand;
const se_AddUserToGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddUserToGroupRequest(input, context),
        Action: "AddUserToGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AddUserToGroupCommand = se_AddUserToGroupCommand;
const se_AttachGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachGroupPolicyRequest(input, context),
        Action: "AttachGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AttachGroupPolicyCommand = se_AttachGroupPolicyCommand;
const se_AttachRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachRolePolicyRequest(input, context),
        Action: "AttachRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AttachRolePolicyCommand = se_AttachRolePolicyCommand;
const se_AttachUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachUserPolicyRequest(input, context),
        Action: "AttachUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AttachUserPolicyCommand = se_AttachUserPolicyCommand;
const se_ChangePasswordCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ChangePasswordRequest(input, context),
        Action: "ChangePassword",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ChangePasswordCommand = se_ChangePasswordCommand;
const se_CreateAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAccessKeyRequest(input, context),
        Action: "CreateAccessKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateAccessKeyCommand = se_CreateAccessKeyCommand;
const se_CreateAccountAliasCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAccountAliasRequest(input, context),
        Action: "CreateAccountAlias",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateAccountAliasCommand = se_CreateAccountAliasCommand;
const se_CreateGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateGroupRequest(input, context),
        Action: "CreateGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateGroupCommand = se_CreateGroupCommand;
const se_CreateInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateInstanceProfileRequest(input, context),
        Action: "CreateInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateInstanceProfileCommand = se_CreateInstanceProfileCommand;
const se_CreateLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLoginProfileRequest(input, context),
        Action: "CreateLoginProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateLoginProfileCommand = se_CreateLoginProfileCommand;
const se_CreateOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateOpenIDConnectProviderRequest(input, context),
        Action: "CreateOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateOpenIDConnectProviderCommand = se_CreateOpenIDConnectProviderCommand;
const se_CreatePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreatePolicyRequest(input, context),
        Action: "CreatePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreatePolicyCommand = se_CreatePolicyCommand;
const se_CreatePolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreatePolicyVersionRequest(input, context),
        Action: "CreatePolicyVersion",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreatePolicyVersionCommand = se_CreatePolicyVersionCommand;
const se_CreateRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRoleRequest(input, context),
        Action: "CreateRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateRoleCommand = se_CreateRoleCommand;
const se_CreateSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSAMLProviderRequest(input, context),
        Action: "CreateSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateSAMLProviderCommand = se_CreateSAMLProviderCommand;
const se_CreateServiceLinkedRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateServiceLinkedRoleRequest(input, context),
        Action: "CreateServiceLinkedRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateServiceLinkedRoleCommand = se_CreateServiceLinkedRoleCommand;
const se_CreateServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateServiceSpecificCredentialRequest(input, context),
        Action: "CreateServiceSpecificCredential",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateServiceSpecificCredentialCommand = se_CreateServiceSpecificCredentialCommand;
const se_CreateUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateUserRequest(input, context),
        Action: "CreateUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateUserCommand = se_CreateUserCommand;
const se_CreateVirtualMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVirtualMFADeviceRequest(input, context),
        Action: "CreateVirtualMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateVirtualMFADeviceCommand = se_CreateVirtualMFADeviceCommand;
const se_DeactivateMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeactivateMFADeviceRequest(input, context),
        Action: "DeactivateMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeactivateMFADeviceCommand = se_DeactivateMFADeviceCommand;
const se_DeleteAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAccessKeyRequest(input, context),
        Action: "DeleteAccessKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteAccessKeyCommand = se_DeleteAccessKeyCommand;
const se_DeleteAccountAliasCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAccountAliasRequest(input, context),
        Action: "DeleteAccountAlias",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteAccountAliasCommand = se_DeleteAccountAliasCommand;
const se_DeleteAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DeleteAccountPasswordPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteAccountPasswordPolicyCommand = se_DeleteAccountPasswordPolicyCommand;
const se_DeleteGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteGroupRequest(input, context),
        Action: "DeleteGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteGroupCommand = se_DeleteGroupCommand;
const se_DeleteGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteGroupPolicyRequest(input, context),
        Action: "DeleteGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteGroupPolicyCommand = se_DeleteGroupPolicyCommand;
const se_DeleteInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInstanceProfileRequest(input, context),
        Action: "DeleteInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteInstanceProfileCommand = se_DeleteInstanceProfileCommand;
const se_DeleteLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLoginProfileRequest(input, context),
        Action: "DeleteLoginProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteLoginProfileCommand = se_DeleteLoginProfileCommand;
const se_DeleteOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteOpenIDConnectProviderRequest(input, context),
        Action: "DeleteOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteOpenIDConnectProviderCommand = se_DeleteOpenIDConnectProviderCommand;
const se_DeletePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePolicyRequest(input, context),
        Action: "DeletePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeletePolicyCommand = se_DeletePolicyCommand;
const se_DeletePolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePolicyVersionRequest(input, context),
        Action: "DeletePolicyVersion",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeletePolicyVersionCommand = se_DeletePolicyVersionCommand;
const se_DeleteRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRoleRequest(input, context),
        Action: "DeleteRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteRoleCommand = se_DeleteRoleCommand;
const se_DeleteRolePermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRolePermissionsBoundaryRequest(input, context),
        Action: "DeleteRolePermissionsBoundary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteRolePermissionsBoundaryCommand = se_DeleteRolePermissionsBoundaryCommand;
const se_DeleteRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRolePolicyRequest(input, context),
        Action: "DeleteRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteRolePolicyCommand = se_DeleteRolePolicyCommand;
const se_DeleteSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSAMLProviderRequest(input, context),
        Action: "DeleteSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteSAMLProviderCommand = se_DeleteSAMLProviderCommand;
const se_DeleteServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServerCertificateRequest(input, context),
        Action: "DeleteServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteServerCertificateCommand = se_DeleteServerCertificateCommand;
const se_DeleteServiceLinkedRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServiceLinkedRoleRequest(input, context),
        Action: "DeleteServiceLinkedRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteServiceLinkedRoleCommand = se_DeleteServiceLinkedRoleCommand;
const se_DeleteServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServiceSpecificCredentialRequest(input, context),
        Action: "DeleteServiceSpecificCredential",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteServiceSpecificCredentialCommand = se_DeleteServiceSpecificCredentialCommand;
const se_DeleteSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSigningCertificateRequest(input, context),
        Action: "DeleteSigningCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteSigningCertificateCommand = se_DeleteSigningCertificateCommand;
const se_DeleteSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSSHPublicKeyRequest(input, context),
        Action: "DeleteSSHPublicKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteSSHPublicKeyCommand = se_DeleteSSHPublicKeyCommand;
const se_DeleteUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserRequest(input, context),
        Action: "DeleteUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteUserCommand = se_DeleteUserCommand;
const se_DeleteUserPermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserPermissionsBoundaryRequest(input, context),
        Action: "DeleteUserPermissionsBoundary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteUserPermissionsBoundaryCommand = se_DeleteUserPermissionsBoundaryCommand;
const se_DeleteUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserPolicyRequest(input, context),
        Action: "DeleteUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteUserPolicyCommand = se_DeleteUserPolicyCommand;
const se_DeleteVirtualMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVirtualMFADeviceRequest(input, context),
        Action: "DeleteVirtualMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteVirtualMFADeviceCommand = se_DeleteVirtualMFADeviceCommand;
const se_DetachGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachGroupPolicyRequest(input, context),
        Action: "DetachGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DetachGroupPolicyCommand = se_DetachGroupPolicyCommand;
const se_DetachRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachRolePolicyRequest(input, context),
        Action: "DetachRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DetachRolePolicyCommand = se_DetachRolePolicyCommand;
const se_DetachUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachUserPolicyRequest(input, context),
        Action: "DetachUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DetachUserPolicyCommand = se_DetachUserPolicyCommand;
const se_EnableMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableMFADeviceRequest(input, context),
        Action: "EnableMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_EnableMFADeviceCommand = se_EnableMFADeviceCommand;
const se_GenerateCredentialReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "GenerateCredentialReport",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateCredentialReportCommand = se_GenerateCredentialReportCommand;
const se_GenerateOrganizationsAccessReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GenerateOrganizationsAccessReportRequest(input, context),
        Action: "GenerateOrganizationsAccessReport",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateOrganizationsAccessReportCommand = se_GenerateOrganizationsAccessReportCommand;
const se_GenerateServiceLastAccessedDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GenerateServiceLastAccessedDetailsRequest(input, context),
        Action: "GenerateServiceLastAccessedDetails",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateServiceLastAccessedDetailsCommand = se_GenerateServiceLastAccessedDetailsCommand;
const se_GetAccessKeyLastUsedCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccessKeyLastUsedRequest(input, context),
        Action: "GetAccessKeyLastUsed",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAccessKeyLastUsedCommand = se_GetAccessKeyLastUsedCommand;
const se_GetAccountAuthorizationDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccountAuthorizationDetailsRequest(input, context),
        Action: "GetAccountAuthorizationDetails",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAccountAuthorizationDetailsCommand = se_GetAccountAuthorizationDetailsCommand;
const se_GetAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "GetAccountPasswordPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAccountPasswordPolicyCommand = se_GetAccountPasswordPolicyCommand;
const se_GetAccountSummaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "GetAccountSummary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAccountSummaryCommand = se_GetAccountSummaryCommand;
const se_GetContextKeysForCustomPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetContextKeysForCustomPolicyRequest(input, context),
        Action: "GetContextKeysForCustomPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetContextKeysForCustomPolicyCommand = se_GetContextKeysForCustomPolicyCommand;
const se_GetContextKeysForPrincipalPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetContextKeysForPrincipalPolicyRequest(input, context),
        Action: "GetContextKeysForPrincipalPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetContextKeysForPrincipalPolicyCommand = se_GetContextKeysForPrincipalPolicyCommand;
const se_GetCredentialReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "GetCredentialReport",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCredentialReportCommand = se_GetCredentialReportCommand;
const se_GetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetGroupRequest(input, context),
        Action: "GetGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetGroupCommand = se_GetGroupCommand;
const se_GetGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetGroupPolicyRequest(input, context),
        Action: "GetGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetGroupPolicyCommand = se_GetGroupPolicyCommand;
const se_GetInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInstanceProfileRequest(input, context),
        Action: "GetInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetInstanceProfileCommand = se_GetInstanceProfileCommand;
const se_GetLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetLoginProfileRequest(input, context),
        Action: "GetLoginProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetLoginProfileCommand = se_GetLoginProfileCommand;
const se_GetMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMFADeviceRequest(input, context),
        Action: "GetMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetMFADeviceCommand = se_GetMFADeviceCommand;
const se_GetOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetOpenIDConnectProviderRequest(input, context),
        Action: "GetOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetOpenIDConnectProviderCommand = se_GetOpenIDConnectProviderCommand;
const se_GetOrganizationsAccessReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetOrganizationsAccessReportRequest(input, context),
        Action: "GetOrganizationsAccessReport",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetOrganizationsAccessReportCommand = se_GetOrganizationsAccessReportCommand;
const se_GetPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPolicyRequest(input, context),
        Action: "GetPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetPolicyCommand = se_GetPolicyCommand;
const se_GetPolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPolicyVersionRequest(input, context),
        Action: "GetPolicyVersion",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetPolicyVersionCommand = se_GetPolicyVersionCommand;
const se_GetRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRoleRequest(input, context),
        Action: "GetRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetRoleCommand = se_GetRoleCommand;
const se_GetRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRolePolicyRequest(input, context),
        Action: "GetRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetRolePolicyCommand = se_GetRolePolicyCommand;
const se_GetSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSAMLProviderRequest(input, context),
        Action: "GetSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetSAMLProviderCommand = se_GetSAMLProviderCommand;
const se_GetServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServerCertificateRequest(input, context),
        Action: "GetServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetServerCertificateCommand = se_GetServerCertificateCommand;
const se_GetServiceLastAccessedDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLastAccessedDetailsRequest(input, context),
        Action: "GetServiceLastAccessedDetails",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetServiceLastAccessedDetailsCommand = se_GetServiceLastAccessedDetailsCommand;
const se_GetServiceLastAccessedDetailsWithEntitiesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLastAccessedDetailsWithEntitiesRequest(input, context),
        Action: "GetServiceLastAccessedDetailsWithEntities",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetServiceLastAccessedDetailsWithEntitiesCommand = se_GetServiceLastAccessedDetailsWithEntitiesCommand;
const se_GetServiceLinkedRoleDeletionStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLinkedRoleDeletionStatusRequest(input, context),
        Action: "GetServiceLinkedRoleDeletionStatus",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetServiceLinkedRoleDeletionStatusCommand = se_GetServiceLinkedRoleDeletionStatusCommand;
const se_GetSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSSHPublicKeyRequest(input, context),
        Action: "GetSSHPublicKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetSSHPublicKeyCommand = se_GetSSHPublicKeyCommand;
const se_GetUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetUserRequest(input, context),
        Action: "GetUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetUserCommand = se_GetUserCommand;
const se_GetUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetUserPolicyRequest(input, context),
        Action: "GetUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetUserPolicyCommand = se_GetUserPolicyCommand;
const se_ListAccessKeysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAccessKeysRequest(input, context),
        Action: "ListAccessKeys",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAccessKeysCommand = se_ListAccessKeysCommand;
const se_ListAccountAliasesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAccountAliasesRequest(input, context),
        Action: "ListAccountAliases",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAccountAliasesCommand = se_ListAccountAliasesCommand;
const se_ListAttachedGroupPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedGroupPoliciesRequest(input, context),
        Action: "ListAttachedGroupPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAttachedGroupPoliciesCommand = se_ListAttachedGroupPoliciesCommand;
const se_ListAttachedRolePoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedRolePoliciesRequest(input, context),
        Action: "ListAttachedRolePolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAttachedRolePoliciesCommand = se_ListAttachedRolePoliciesCommand;
const se_ListAttachedUserPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedUserPoliciesRequest(input, context),
        Action: "ListAttachedUserPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAttachedUserPoliciesCommand = se_ListAttachedUserPoliciesCommand;
const se_ListEntitiesForPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListEntitiesForPolicyRequest(input, context),
        Action: "ListEntitiesForPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListEntitiesForPolicyCommand = se_ListEntitiesForPolicyCommand;
const se_ListGroupPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupPoliciesRequest(input, context),
        Action: "ListGroupPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListGroupPoliciesCommand = se_ListGroupPoliciesCommand;
const se_ListGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupsRequest(input, context),
        Action: "ListGroups",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListGroupsCommand = se_ListGroupsCommand;
const se_ListGroupsForUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupsForUserRequest(input, context),
        Action: "ListGroupsForUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListGroupsForUserCommand = se_ListGroupsForUserCommand;
const se_ListInstanceProfilesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfilesRequest(input, context),
        Action: "ListInstanceProfiles",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListInstanceProfilesCommand = se_ListInstanceProfilesCommand;
const se_ListInstanceProfilesForRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfilesForRoleRequest(input, context),
        Action: "ListInstanceProfilesForRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListInstanceProfilesForRoleCommand = se_ListInstanceProfilesForRoleCommand;
const se_ListInstanceProfileTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfileTagsRequest(input, context),
        Action: "ListInstanceProfileTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListInstanceProfileTagsCommand = se_ListInstanceProfileTagsCommand;
const se_ListMFADevicesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMFADevicesRequest(input, context),
        Action: "ListMFADevices",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListMFADevicesCommand = se_ListMFADevicesCommand;
const se_ListMFADeviceTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMFADeviceTagsRequest(input, context),
        Action: "ListMFADeviceTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListMFADeviceTagsCommand = se_ListMFADeviceTagsCommand;
const se_ListOpenIDConnectProvidersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListOpenIDConnectProvidersRequest(input, context),
        Action: "ListOpenIDConnectProviders",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListOpenIDConnectProvidersCommand = se_ListOpenIDConnectProvidersCommand;
const se_ListOpenIDConnectProviderTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListOpenIDConnectProviderTagsRequest(input, context),
        Action: "ListOpenIDConnectProviderTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListOpenIDConnectProviderTagsCommand = se_ListOpenIDConnectProviderTagsCommand;
const se_ListPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPoliciesRequest(input, context),
        Action: "ListPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListPoliciesCommand = se_ListPoliciesCommand;
const se_ListPoliciesGrantingServiceAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPoliciesGrantingServiceAccessRequest(input, context),
        Action: "ListPoliciesGrantingServiceAccess",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListPoliciesGrantingServiceAccessCommand = se_ListPoliciesGrantingServiceAccessCommand;
const se_ListPolicyTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPolicyTagsRequest(input, context),
        Action: "ListPolicyTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListPolicyTagsCommand = se_ListPolicyTagsCommand;
const se_ListPolicyVersionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPolicyVersionsRequest(input, context),
        Action: "ListPolicyVersions",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListPolicyVersionsCommand = se_ListPolicyVersionsCommand;
const se_ListRolePoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRolePoliciesRequest(input, context),
        Action: "ListRolePolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListRolePoliciesCommand = se_ListRolePoliciesCommand;
const se_ListRolesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRolesRequest(input, context),
        Action: "ListRoles",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListRolesCommand = se_ListRolesCommand;
const se_ListRoleTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRoleTagsRequest(input, context),
        Action: "ListRoleTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListRoleTagsCommand = se_ListRoleTagsCommand;
const se_ListSAMLProvidersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSAMLProvidersRequest(input, context),
        Action: "ListSAMLProviders",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListSAMLProvidersCommand = se_ListSAMLProvidersCommand;
const se_ListSAMLProviderTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSAMLProviderTagsRequest(input, context),
        Action: "ListSAMLProviderTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListSAMLProviderTagsCommand = se_ListSAMLProviderTagsCommand;
const se_ListServerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServerCertificatesRequest(input, context),
        Action: "ListServerCertificates",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListServerCertificatesCommand = se_ListServerCertificatesCommand;
const se_ListServerCertificateTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServerCertificateTagsRequest(input, context),
        Action: "ListServerCertificateTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListServerCertificateTagsCommand = se_ListServerCertificateTagsCommand;
const se_ListServiceSpecificCredentialsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServiceSpecificCredentialsRequest(input, context),
        Action: "ListServiceSpecificCredentials",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListServiceSpecificCredentialsCommand = se_ListServiceSpecificCredentialsCommand;
const se_ListSigningCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSigningCertificatesRequest(input, context),
        Action: "ListSigningCertificates",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListSigningCertificatesCommand = se_ListSigningCertificatesCommand;
const se_ListSSHPublicKeysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSSHPublicKeysRequest(input, context),
        Action: "ListSSHPublicKeys",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListSSHPublicKeysCommand = se_ListSSHPublicKeysCommand;
const se_ListUserPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUserPoliciesRequest(input, context),
        Action: "ListUserPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListUserPoliciesCommand = se_ListUserPoliciesCommand;
const se_ListUsersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUsersRequest(input, context),
        Action: "ListUsers",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListUsersCommand = se_ListUsersCommand;
const se_ListUserTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUserTagsRequest(input, context),
        Action: "ListUserTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListUserTagsCommand = se_ListUserTagsCommand;
const se_ListVirtualMFADevicesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListVirtualMFADevicesRequest(input, context),
        Action: "ListVirtualMFADevices",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListVirtualMFADevicesCommand = se_ListVirtualMFADevicesCommand;
const se_PutGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutGroupPolicyRequest(input, context),
        Action: "PutGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutGroupPolicyCommand = se_PutGroupPolicyCommand;
const se_PutRolePermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutRolePermissionsBoundaryRequest(input, context),
        Action: "PutRolePermissionsBoundary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutRolePermissionsBoundaryCommand = se_PutRolePermissionsBoundaryCommand;
const se_PutRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutRolePolicyRequest(input, context),
        Action: "PutRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutRolePolicyCommand = se_PutRolePolicyCommand;
const se_PutUserPermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutUserPermissionsBoundaryRequest(input, context),
        Action: "PutUserPermissionsBoundary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutUserPermissionsBoundaryCommand = se_PutUserPermissionsBoundaryCommand;
const se_PutUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutUserPolicyRequest(input, context),
        Action: "PutUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutUserPolicyCommand = se_PutUserPolicyCommand;
const se_RemoveClientIDFromOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveClientIDFromOpenIDConnectProviderRequest(input, context),
        Action: "RemoveClientIDFromOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RemoveClientIDFromOpenIDConnectProviderCommand = se_RemoveClientIDFromOpenIDConnectProviderCommand;
const se_RemoveRoleFromInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveRoleFromInstanceProfileRequest(input, context),
        Action: "RemoveRoleFromInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RemoveRoleFromInstanceProfileCommand = se_RemoveRoleFromInstanceProfileCommand;
const se_RemoveUserFromGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveUserFromGroupRequest(input, context),
        Action: "RemoveUserFromGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RemoveUserFromGroupCommand = se_RemoveUserFromGroupCommand;
const se_ResetServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetServiceSpecificCredentialRequest(input, context),
        Action: "ResetServiceSpecificCredential",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ResetServiceSpecificCredentialCommand = se_ResetServiceSpecificCredentialCommand;
const se_ResyncMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResyncMFADeviceRequest(input, context),
        Action: "ResyncMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ResyncMFADeviceCommand = se_ResyncMFADeviceCommand;
const se_SetDefaultPolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetDefaultPolicyVersionRequest(input, context),
        Action: "SetDefaultPolicyVersion",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetDefaultPolicyVersionCommand = se_SetDefaultPolicyVersionCommand;
const se_SetSecurityTokenServicePreferencesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetSecurityTokenServicePreferencesRequest(input, context),
        Action: "SetSecurityTokenServicePreferences",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetSecurityTokenServicePreferencesCommand = se_SetSecurityTokenServicePreferencesCommand;
const se_SimulateCustomPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SimulateCustomPolicyRequest(input, context),
        Action: "SimulateCustomPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SimulateCustomPolicyCommand = se_SimulateCustomPolicyCommand;
const se_SimulatePrincipalPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SimulatePrincipalPolicyRequest(input, context),
        Action: "SimulatePrincipalPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SimulatePrincipalPolicyCommand = se_SimulatePrincipalPolicyCommand;
const se_TagInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagInstanceProfileRequest(input, context),
        Action: "TagInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagInstanceProfileCommand = se_TagInstanceProfileCommand;
const se_TagMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagMFADeviceRequest(input, context),
        Action: "TagMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagMFADeviceCommand = se_TagMFADeviceCommand;
const se_TagOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagOpenIDConnectProviderRequest(input, context),
        Action: "TagOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagOpenIDConnectProviderCommand = se_TagOpenIDConnectProviderCommand;
const se_TagPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagPolicyRequest(input, context),
        Action: "TagPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagPolicyCommand = se_TagPolicyCommand;
const se_TagRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagRoleRequest(input, context),
        Action: "TagRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagRoleCommand = se_TagRoleCommand;
const se_TagSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagSAMLProviderRequest(input, context),
        Action: "TagSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagSAMLProviderCommand = se_TagSAMLProviderCommand;
const se_TagServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagServerCertificateRequest(input, context),
        Action: "TagServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagServerCertificateCommand = se_TagServerCertificateCommand;
const se_TagUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagUserRequest(input, context),
        Action: "TagUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagUserCommand = se_TagUserCommand;
const se_UntagInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagInstanceProfileRequest(input, context),
        Action: "UntagInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagInstanceProfileCommand = se_UntagInstanceProfileCommand;
const se_UntagMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagMFADeviceRequest(input, context),
        Action: "UntagMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagMFADeviceCommand = se_UntagMFADeviceCommand;
const se_UntagOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagOpenIDConnectProviderRequest(input, context),
        Action: "UntagOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagOpenIDConnectProviderCommand = se_UntagOpenIDConnectProviderCommand;
const se_UntagPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagPolicyRequest(input, context),
        Action: "UntagPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagPolicyCommand = se_UntagPolicyCommand;
const se_UntagRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagRoleRequest(input, context),
        Action: "UntagRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagRoleCommand = se_UntagRoleCommand;
const se_UntagSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagSAMLProviderRequest(input, context),
        Action: "UntagSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagSAMLProviderCommand = se_UntagSAMLProviderCommand;
const se_UntagServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagServerCertificateRequest(input, context),
        Action: "UntagServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagServerCertificateCommand = se_UntagServerCertificateCommand;
const se_UntagUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagUserRequest(input, context),
        Action: "UntagUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagUserCommand = se_UntagUserCommand;
const se_UpdateAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAccessKeyRequest(input, context),
        Action: "UpdateAccessKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateAccessKeyCommand = se_UpdateAccessKeyCommand;
const se_UpdateAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAccountPasswordPolicyRequest(input, context),
        Action: "UpdateAccountPasswordPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateAccountPasswordPolicyCommand = se_UpdateAccountPasswordPolicyCommand;
const se_UpdateAssumeRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAssumeRolePolicyRequest(input, context),
        Action: "UpdateAssumeRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateAssumeRolePolicyCommand = se_UpdateAssumeRolePolicyCommand;
const se_UpdateGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateGroupRequest(input, context),
        Action: "UpdateGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateGroupCommand = se_UpdateGroupCommand;
const se_UpdateLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateLoginProfileRequest(input, context),
        Action: "UpdateLoginProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateLoginProfileCommand = se_UpdateLoginProfileCommand;
const se_UpdateOpenIDConnectProviderThumbprintCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateOpenIDConnectProviderThumbprintRequest(input, context),
        Action: "UpdateOpenIDConnectProviderThumbprint",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateOpenIDConnectProviderThumbprintCommand = se_UpdateOpenIDConnectProviderThumbprintCommand;
const se_UpdateRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateRoleRequest(input, context),
        Action: "UpdateRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateRoleCommand = se_UpdateRoleCommand;
const se_UpdateRoleDescriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateRoleDescriptionRequest(input, context),
        Action: "UpdateRoleDescription",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateRoleDescriptionCommand = se_UpdateRoleDescriptionCommand;
const se_UpdateSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSAMLProviderRequest(input, context),
        Action: "UpdateSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateSAMLProviderCommand = se_UpdateSAMLProviderCommand;
const se_UpdateServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateServerCertificateRequest(input, context),
        Action: "UpdateServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateServerCertificateCommand = se_UpdateServerCertificateCommand;
const se_UpdateServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateServiceSpecificCredentialRequest(input, context),
        Action: "UpdateServiceSpecificCredential",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateServiceSpecificCredentialCommand = se_UpdateServiceSpecificCredentialCommand;
const se_UpdateSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSigningCertificateRequest(input, context),
        Action: "UpdateSigningCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateSigningCertificateCommand = se_UpdateSigningCertificateCommand;
const se_UpdateSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSSHPublicKeyRequest(input, context),
        Action: "UpdateSSHPublicKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateSSHPublicKeyCommand = se_UpdateSSHPublicKeyCommand;
const se_UpdateUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateUserRequest(input, context),
        Action: "UpdateUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateUserCommand = se_UpdateUserCommand;
const se_UploadServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadServerCertificateRequest(input, context),
        Action: "UploadServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UploadServerCertificateCommand = se_UploadServerCertificateCommand;
const se_UploadSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadSigningCertificateRequest(input, context),
        Action: "UploadSigningCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UploadSigningCertificateCommand = se_UploadSigningCertificateCommand;
const se_UploadSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadSSHPublicKeyRequest(input, context),
        Action: "UploadSSHPublicKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UploadSSHPublicKeyCommand = se_UploadSSHPublicKeyCommand;
const de_AddClientIDToOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddClientIDToOpenIDConnectProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_AddClientIDToOpenIDConnectProviderCommand = de_AddClientIDToOpenIDConnectProviderCommand;
const de_AddClientIDToOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AddRoleToInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddRoleToInstanceProfileCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_AddRoleToInstanceProfileCommand = de_AddRoleToInstanceProfileCommand;
const de_AddRoleToInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AddUserToGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddUserToGroupCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_AddUserToGroupCommand = de_AddUserToGroupCommand;
const de_AddUserToGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AttachGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachGroupPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_AttachGroupPolicyCommand = de_AttachGroupPolicyCommand;
const de_AttachGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AttachRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachRolePolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_AttachRolePolicyCommand = de_AttachRolePolicyCommand;
const de_AttachRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AttachUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachUserPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_AttachUserPolicyCommand = de_AttachUserPolicyCommand;
const de_AttachUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ChangePasswordCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ChangePasswordCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_ChangePasswordCommand = de_ChangePasswordCommand;
const de_ChangePasswordCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "InvalidUserType":
        case "com.amazonaws.iam#InvalidUserTypeException":
            throw await de_InvalidUserTypeExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PasswordPolicyViolation":
        case "com.amazonaws.iam#PasswordPolicyViolationException":
            throw await de_PasswordPolicyViolationExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAccessKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateAccessKeyResponse(data.CreateAccessKeyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateAccessKeyCommand = de_CreateAccessKeyCommand;
const de_CreateAccessKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateAccountAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAccountAliasCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_CreateAccountAliasCommand = de_CreateAccountAliasCommand;
const de_CreateAccountAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateGroupResponse(data.CreateGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateGroupCommand = de_CreateGroupCommand;
const de_CreateGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateInstanceProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateInstanceProfileResponse(data.CreateInstanceProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateInstanceProfileCommand = de_CreateInstanceProfileCommand;
const de_CreateInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateLoginProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLoginProfileResponse(data.CreateLoginProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateLoginProfileCommand = de_CreateLoginProfileCommand;
const de_CreateLoginProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PasswordPolicyViolation":
        case "com.amazonaws.iam#PasswordPolicyViolationException":
            throw await de_PasswordPolicyViolationExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateOpenIDConnectProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateOpenIDConnectProviderResponse(data.CreateOpenIDConnectProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateOpenIDConnectProviderCommand = de_CreateOpenIDConnectProviderCommand;
const de_CreateOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreatePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreatePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePolicyResponse(data.CreatePolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreatePolicyCommand = de_CreatePolicyCommand;
const de_CreatePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreatePolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreatePolicyVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePolicyVersionResponse(data.CreatePolicyVersionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreatePolicyVersionCommand = de_CreatePolicyVersionCommand;
const de_CreatePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRoleResponse(data.CreateRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateRoleCommand = de_CreateRoleCommand;
const de_CreateRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateSAMLProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSAMLProviderResponse(data.CreateSAMLProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateSAMLProviderCommand = de_CreateSAMLProviderCommand;
const de_CreateSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateServiceLinkedRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateServiceLinkedRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateServiceLinkedRoleResponse(data.CreateServiceLinkedRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateServiceLinkedRoleCommand = de_CreateServiceLinkedRoleCommand;
const de_CreateServiceLinkedRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateServiceSpecificCredentialCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateServiceSpecificCredentialResponse(data.CreateServiceSpecificCredentialResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateServiceSpecificCredentialCommand = de_CreateServiceSpecificCredentialCommand;
const de_CreateServiceSpecificCredentialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "NotSupportedService":
        case "com.amazonaws.iam#ServiceNotSupportedException":
            throw await de_ServiceNotSupportedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateUserResponse(data.CreateUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateUserCommand = de_CreateUserCommand;
const de_CreateUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateVirtualMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateVirtualMFADeviceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVirtualMFADeviceResponse(data.CreateVirtualMFADeviceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateVirtualMFADeviceCommand = de_CreateVirtualMFADeviceCommand;
const de_CreateVirtualMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeactivateMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeactivateMFADeviceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeactivateMFADeviceCommand = de_DeactivateMFADeviceCommand;
const de_DeactivateMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAccessKeyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteAccessKeyCommand = de_DeleteAccessKeyCommand;
const de_DeleteAccessKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteAccountAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAccountAliasCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteAccountAliasCommand = de_DeleteAccountAliasCommand;
const de_DeleteAccountAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAccountPasswordPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteAccountPasswordPolicyCommand = de_DeleteAccountPasswordPolicyCommand;
const de_DeleteAccountPasswordPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteGroupCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteGroupCommand = de_DeleteGroupCommand;
const de_DeleteGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteGroupPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteGroupPolicyCommand = de_DeleteGroupPolicyCommand;
const de_DeleteGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteInstanceProfileCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteInstanceProfileCommand = de_DeleteInstanceProfileCommand;
const de_DeleteInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteLoginProfileCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteLoginProfileCommand = de_DeleteLoginProfileCommand;
const de_DeleteLoginProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteOpenIDConnectProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteOpenIDConnectProviderCommand = de_DeleteOpenIDConnectProviderCommand;
const de_DeleteOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeletePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeletePolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeletePolicyCommand = de_DeletePolicyCommand;
const de_DeletePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeletePolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeletePolicyVersionCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeletePolicyVersionCommand = de_DeletePolicyVersionCommand;
const de_DeletePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteRoleCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteRoleCommand = de_DeleteRoleCommand;
const de_DeleteRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteRolePermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteRolePermissionsBoundaryCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteRolePermissionsBoundaryCommand = de_DeleteRolePermissionsBoundaryCommand;
const de_DeleteRolePermissionsBoundaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteRolePolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteRolePolicyCommand = de_DeleteRolePolicyCommand;
const de_DeleteRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteSAMLProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteSAMLProviderCommand = de_DeleteSAMLProviderCommand;
const de_DeleteSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteServerCertificateCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteServerCertificateCommand = de_DeleteServerCertificateCommand;
const de_DeleteServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteServiceLinkedRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteServiceLinkedRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteServiceLinkedRoleResponse(data.DeleteServiceLinkedRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteServiceLinkedRoleCommand = de_DeleteServiceLinkedRoleCommand;
const de_DeleteServiceLinkedRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteServiceSpecificCredentialCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteServiceSpecificCredentialCommand = de_DeleteServiceSpecificCredentialCommand;
const de_DeleteServiceSpecificCredentialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteSigningCertificateCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteSigningCertificateCommand = de_DeleteSigningCertificateCommand;
const de_DeleteSigningCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteSSHPublicKeyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteSSHPublicKeyCommand = de_DeleteSSHPublicKeyCommand;
const de_DeleteSSHPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteUserCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteUserCommand = de_DeleteUserCommand;
const de_DeleteUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteUserPermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteUserPermissionsBoundaryCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteUserPermissionsBoundaryCommand = de_DeleteUserPermissionsBoundaryCommand;
const de_DeleteUserPermissionsBoundaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteUserPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteUserPolicyCommand = de_DeleteUserPolicyCommand;
const de_DeleteUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteVirtualMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteVirtualMFADeviceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteVirtualMFADeviceCommand = de_DeleteVirtualMFADeviceCommand;
const de_DeleteVirtualMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DetachGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachGroupPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DetachGroupPolicyCommand = de_DetachGroupPolicyCommand;
const de_DetachGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DetachRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachRolePolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DetachRolePolicyCommand = de_DetachRolePolicyCommand;
const de_DetachRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DetachUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachUserPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DetachUserPolicyCommand = de_DetachUserPolicyCommand;
const de_DetachUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_EnableMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableMFADeviceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_EnableMFADeviceCommand = de_EnableMFADeviceCommand;
const de_EnableMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "InvalidAuthenticationCode":
        case "com.amazonaws.iam#InvalidAuthenticationCodeException":
            throw await de_InvalidAuthenticationCodeExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GenerateCredentialReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateCredentialReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateCredentialReportResponse(data.GenerateCredentialReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateCredentialReportCommand = de_GenerateCredentialReportCommand;
const de_GenerateCredentialReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GenerateOrganizationsAccessReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateOrganizationsAccessReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateOrganizationsAccessReportResponse(data.GenerateOrganizationsAccessReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateOrganizationsAccessReportCommand = de_GenerateOrganizationsAccessReportCommand;
const de_GenerateOrganizationsAccessReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ReportGenerationLimitExceeded":
        case "com.amazonaws.iam#ReportGenerationLimitExceededException":
            throw await de_ReportGenerationLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GenerateServiceLastAccessedDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateServiceLastAccessedDetailsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateServiceLastAccessedDetailsResponse(data.GenerateServiceLastAccessedDetailsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateServiceLastAccessedDetailsCommand = de_GenerateServiceLastAccessedDetailsCommand;
const de_GenerateServiceLastAccessedDetailsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetAccessKeyLastUsedCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccessKeyLastUsedCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccessKeyLastUsedResponse(data.GetAccessKeyLastUsedResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetAccessKeyLastUsedCommand = de_GetAccessKeyLastUsedCommand;
const de_GetAccessKeyLastUsedCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetAccountAuthorizationDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccountAuthorizationDetailsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountAuthorizationDetailsResponse(data.GetAccountAuthorizationDetailsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetAccountAuthorizationDetailsCommand = de_GetAccountAuthorizationDetailsCommand;
const de_GetAccountAuthorizationDetailsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccountPasswordPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountPasswordPolicyResponse(data.GetAccountPasswordPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetAccountPasswordPolicyCommand = de_GetAccountPasswordPolicyCommand;
const de_GetAccountPasswordPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetAccountSummaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccountSummaryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountSummaryResponse(data.GetAccountSummaryResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetAccountSummaryCommand = de_GetAccountSummaryCommand;
const de_GetAccountSummaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetContextKeysForCustomPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetContextKeysForCustomPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetContextKeysForPolicyResponse(data.GetContextKeysForCustomPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetContextKeysForCustomPolicyCommand = de_GetContextKeysForCustomPolicyCommand;
const de_GetContextKeysForCustomPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetContextKeysForPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetContextKeysForPrincipalPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetContextKeysForPolicyResponse(data.GetContextKeysForPrincipalPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetContextKeysForPrincipalPolicyCommand = de_GetContextKeysForPrincipalPolicyCommand;
const de_GetContextKeysForPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCredentialReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCredentialReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCredentialReportResponse(data.GetCredentialReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetCredentialReportCommand = de_GetCredentialReportCommand;
const de_GetCredentialReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ReportExpired":
        case "com.amazonaws.iam#CredentialReportExpiredException":
            throw await de_CredentialReportExpiredExceptionRes(parsedOutput, context);
        case "ReportInProgress":
        case "com.amazonaws.iam#CredentialReportNotReadyException":
            throw await de_CredentialReportNotReadyExceptionRes(parsedOutput, context);
        case "ReportNotPresent":
        case "com.amazonaws.iam#CredentialReportNotPresentException":
            throw await de_CredentialReportNotPresentExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetGroupResponse(data.GetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetGroupCommand = de_GetGroupCommand;
const de_GetGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetGroupPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetGroupPolicyResponse(data.GetGroupPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetGroupPolicyCommand = de_GetGroupPolicyCommand;
const de_GetGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetInstanceProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInstanceProfileResponse(data.GetInstanceProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetInstanceProfileCommand = de_GetInstanceProfileCommand;
const de_GetInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetLoginProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetLoginProfileResponse(data.GetLoginProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetLoginProfileCommand = de_GetLoginProfileCommand;
const de_GetLoginProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMFADeviceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMFADeviceResponse(data.GetMFADeviceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetMFADeviceCommand = de_GetMFADeviceCommand;
const de_GetMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetOpenIDConnectProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOpenIDConnectProviderResponse(data.GetOpenIDConnectProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetOpenIDConnectProviderCommand = de_GetOpenIDConnectProviderCommand;
const de_GetOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOrganizationsAccessReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetOrganizationsAccessReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOrganizationsAccessReportResponse(data.GetOrganizationsAccessReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetOrganizationsAccessReportCommand = de_GetOrganizationsAccessReportCommand;
const de_GetOrganizationsAccessReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPolicyResponse(data.GetPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetPolicyCommand = de_GetPolicyCommand;
const de_GetPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetPolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPolicyVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPolicyVersionResponse(data.GetPolicyVersionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetPolicyVersionCommand = de_GetPolicyVersionCommand;
const de_GetPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRoleResponse(data.GetRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetRoleCommand = de_GetRoleCommand;
const de_GetRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetRolePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRolePolicyResponse(data.GetRolePolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetRolePolicyCommand = de_GetRolePolicyCommand;
const de_GetRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetSAMLProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSAMLProviderResponse(data.GetSAMLProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetSAMLProviderCommand = de_GetSAMLProviderCommand;
const de_GetSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServerCertificateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServerCertificateResponse(data.GetServerCertificateResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetServerCertificateCommand = de_GetServerCertificateCommand;
const de_GetServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetServiceLastAccessedDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServiceLastAccessedDetailsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLastAccessedDetailsResponse(data.GetServiceLastAccessedDetailsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetServiceLastAccessedDetailsCommand = de_GetServiceLastAccessedDetailsCommand;
const de_GetServiceLastAccessedDetailsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetServiceLastAccessedDetailsWithEntitiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServiceLastAccessedDetailsWithEntitiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLastAccessedDetailsWithEntitiesResponse(data.GetServiceLastAccessedDetailsWithEntitiesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetServiceLastAccessedDetailsWithEntitiesCommand = de_GetServiceLastAccessedDetailsWithEntitiesCommand;
const de_GetServiceLastAccessedDetailsWithEntitiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetServiceLinkedRoleDeletionStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServiceLinkedRoleDeletionStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLinkedRoleDeletionStatusResponse(data.GetServiceLinkedRoleDeletionStatusResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetServiceLinkedRoleDeletionStatusCommand = de_GetServiceLinkedRoleDeletionStatusCommand;
const de_GetServiceLinkedRoleDeletionStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetSSHPublicKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSSHPublicKeyResponse(data.GetSSHPublicKeyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetSSHPublicKeyCommand = de_GetSSHPublicKeyCommand;
const de_GetSSHPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "UnrecognizedPublicKeyEncoding":
        case "com.amazonaws.iam#UnrecognizedPublicKeyEncodingException":
            throw await de_UnrecognizedPublicKeyEncodingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetUserResponse(data.GetUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetUserCommand = de_GetUserCommand;
const de_GetUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetUserPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetUserPolicyResponse(data.GetUserPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetUserPolicyCommand = de_GetUserPolicyCommand;
const de_GetUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListAccessKeysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAccessKeysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAccessKeysResponse(data.ListAccessKeysResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAccessKeysCommand = de_ListAccessKeysCommand;
const de_ListAccessKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListAccountAliasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAccountAliasesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAccountAliasesResponse(data.ListAccountAliasesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAccountAliasesCommand = de_ListAccountAliasesCommand;
const de_ListAccountAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListAttachedGroupPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAttachedGroupPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedGroupPoliciesResponse(data.ListAttachedGroupPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAttachedGroupPoliciesCommand = de_ListAttachedGroupPoliciesCommand;
const de_ListAttachedGroupPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListAttachedRolePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAttachedRolePoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedRolePoliciesResponse(data.ListAttachedRolePoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAttachedRolePoliciesCommand = de_ListAttachedRolePoliciesCommand;
const de_ListAttachedRolePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListAttachedUserPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAttachedUserPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedUserPoliciesResponse(data.ListAttachedUserPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAttachedUserPoliciesCommand = de_ListAttachedUserPoliciesCommand;
const de_ListAttachedUserPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListEntitiesForPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListEntitiesForPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListEntitiesForPolicyResponse(data.ListEntitiesForPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListEntitiesForPolicyCommand = de_ListEntitiesForPolicyCommand;
const de_ListEntitiesForPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListGroupPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGroupPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupPoliciesResponse(data.ListGroupPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListGroupPoliciesCommand = de_ListGroupPoliciesCommand;
const de_ListGroupPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupsResponse(data.ListGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListGroupsCommand = de_ListGroupsCommand;
const de_ListGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListGroupsForUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGroupsForUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupsForUserResponse(data.ListGroupsForUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListGroupsForUserCommand = de_ListGroupsForUserCommand;
const de_ListGroupsForUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListInstanceProfilesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListInstanceProfilesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfilesResponse(data.ListInstanceProfilesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListInstanceProfilesCommand = de_ListInstanceProfilesCommand;
const de_ListInstanceProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListInstanceProfilesForRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListInstanceProfilesForRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfilesForRoleResponse(data.ListInstanceProfilesForRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListInstanceProfilesForRoleCommand = de_ListInstanceProfilesForRoleCommand;
const de_ListInstanceProfilesForRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListInstanceProfileTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListInstanceProfileTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfileTagsResponse(data.ListInstanceProfileTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListInstanceProfileTagsCommand = de_ListInstanceProfileTagsCommand;
const de_ListInstanceProfileTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListMFADevicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListMFADevicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMFADevicesResponse(data.ListMFADevicesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListMFADevicesCommand = de_ListMFADevicesCommand;
const de_ListMFADevicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListMFADeviceTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListMFADeviceTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMFADeviceTagsResponse(data.ListMFADeviceTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListMFADeviceTagsCommand = de_ListMFADeviceTagsCommand;
const de_ListMFADeviceTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListOpenIDConnectProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListOpenIDConnectProvidersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpenIDConnectProvidersResponse(data.ListOpenIDConnectProvidersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListOpenIDConnectProvidersCommand = de_ListOpenIDConnectProvidersCommand;
const de_ListOpenIDConnectProvidersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListOpenIDConnectProviderTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListOpenIDConnectProviderTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpenIDConnectProviderTagsResponse(data.ListOpenIDConnectProviderTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListOpenIDConnectProviderTagsCommand = de_ListOpenIDConnectProviderTagsCommand;
const de_ListOpenIDConnectProviderTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPoliciesResponse(data.ListPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListPoliciesCommand = de_ListPoliciesCommand;
const de_ListPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListPoliciesGrantingServiceAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPoliciesGrantingServiceAccessCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPoliciesGrantingServiceAccessResponse(data.ListPoliciesGrantingServiceAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListPoliciesGrantingServiceAccessCommand = de_ListPoliciesGrantingServiceAccessCommand;
const de_ListPoliciesGrantingServiceAccessCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListPolicyTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPolicyTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPolicyTagsResponse(data.ListPolicyTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListPolicyTagsCommand = de_ListPolicyTagsCommand;
const de_ListPolicyTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListPolicyVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPolicyVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPolicyVersionsResponse(data.ListPolicyVersionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListPolicyVersionsCommand = de_ListPolicyVersionsCommand;
const de_ListPolicyVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListRolePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRolePoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRolePoliciesResponse(data.ListRolePoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListRolePoliciesCommand = de_ListRolePoliciesCommand;
const de_ListRolePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListRolesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRolesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRolesResponse(data.ListRolesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListRolesCommand = de_ListRolesCommand;
const de_ListRolesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListRoleTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRoleTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRoleTagsResponse(data.ListRoleTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListRoleTagsCommand = de_ListRoleTagsCommand;
const de_ListRoleTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListSAMLProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListSAMLProvidersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSAMLProvidersResponse(data.ListSAMLProvidersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListSAMLProvidersCommand = de_ListSAMLProvidersCommand;
const de_ListSAMLProvidersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListSAMLProviderTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListSAMLProviderTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSAMLProviderTagsResponse(data.ListSAMLProviderTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListSAMLProviderTagsCommand = de_ListSAMLProviderTagsCommand;
const de_ListSAMLProviderTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListServerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListServerCertificatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServerCertificatesResponse(data.ListServerCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListServerCertificatesCommand = de_ListServerCertificatesCommand;
const de_ListServerCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListServerCertificateTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListServerCertificateTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServerCertificateTagsResponse(data.ListServerCertificateTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListServerCertificateTagsCommand = de_ListServerCertificateTagsCommand;
const de_ListServerCertificateTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListServiceSpecificCredentialsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListServiceSpecificCredentialsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServiceSpecificCredentialsResponse(data.ListServiceSpecificCredentialsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListServiceSpecificCredentialsCommand = de_ListServiceSpecificCredentialsCommand;
const de_ListServiceSpecificCredentialsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "NotSupportedService":
        case "com.amazonaws.iam#ServiceNotSupportedException":
            throw await de_ServiceNotSupportedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListSigningCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListSigningCertificatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSigningCertificatesResponse(data.ListSigningCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListSigningCertificatesCommand = de_ListSigningCertificatesCommand;
const de_ListSigningCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListSSHPublicKeysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListSSHPublicKeysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSSHPublicKeysResponse(data.ListSSHPublicKeysResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListSSHPublicKeysCommand = de_ListSSHPublicKeysCommand;
const de_ListSSHPublicKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListUserPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListUserPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUserPoliciesResponse(data.ListUserPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListUserPoliciesCommand = de_ListUserPoliciesCommand;
const de_ListUserPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListUsersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListUsersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUsersResponse(data.ListUsersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListUsersCommand = de_ListUsersCommand;
const de_ListUsersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListUserTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListUserTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUserTagsResponse(data.ListUserTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListUserTagsCommand = de_ListUserTagsCommand;
const de_ListUserTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListVirtualMFADevicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListVirtualMFADevicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListVirtualMFADevicesResponse(data.ListVirtualMFADevicesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListVirtualMFADevicesCommand = de_ListVirtualMFADevicesCommand;
const de_ListVirtualMFADevicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_PutGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutGroupPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_PutGroupPolicyCommand = de_PutGroupPolicyCommand;
const de_PutGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutRolePermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutRolePermissionsBoundaryCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_PutRolePermissionsBoundaryCommand = de_PutRolePermissionsBoundaryCommand;
const de_PutRolePermissionsBoundaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutRolePolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_PutRolePolicyCommand = de_PutRolePolicyCommand;
const de_PutRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutUserPermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutUserPermissionsBoundaryCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_PutUserPermissionsBoundaryCommand = de_PutUserPermissionsBoundaryCommand;
const de_PutUserPermissionsBoundaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutUserPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_PutUserPolicyCommand = de_PutUserPolicyCommand;
const de_PutUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_RemoveClientIDFromOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveClientIDFromOpenIDConnectProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_RemoveClientIDFromOpenIDConnectProviderCommand = de_RemoveClientIDFromOpenIDConnectProviderCommand;
const de_RemoveClientIDFromOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_RemoveRoleFromInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveRoleFromInstanceProfileCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_RemoveRoleFromInstanceProfileCommand = de_RemoveRoleFromInstanceProfileCommand;
const de_RemoveRoleFromInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_RemoveUserFromGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveUserFromGroupCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_RemoveUserFromGroupCommand = de_RemoveUserFromGroupCommand;
const de_RemoveUserFromGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ResetServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ResetServiceSpecificCredentialCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResetServiceSpecificCredentialResponse(data.ResetServiceSpecificCredentialResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ResetServiceSpecificCredentialCommand = de_ResetServiceSpecificCredentialCommand;
const de_ResetServiceSpecificCredentialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ResyncMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ResyncMFADeviceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_ResyncMFADeviceCommand = de_ResyncMFADeviceCommand;
const de_ResyncMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidAuthenticationCode":
        case "com.amazonaws.iam#InvalidAuthenticationCodeException":
            throw await de_InvalidAuthenticationCodeExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SetDefaultPolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetDefaultPolicyVersionCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_SetDefaultPolicyVersionCommand = de_SetDefaultPolicyVersionCommand;
const de_SetDefaultPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SetSecurityTokenServicePreferencesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetSecurityTokenServicePreferencesCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_SetSecurityTokenServicePreferencesCommand = de_SetSecurityTokenServicePreferencesCommand;
const de_SetSecurityTokenServicePreferencesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SimulateCustomPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SimulateCustomPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SimulatePolicyResponse(data.SimulateCustomPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_SimulateCustomPolicyCommand = de_SimulateCustomPolicyCommand;
const de_SimulateCustomPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "PolicyEvaluation":
        case "com.amazonaws.iam#PolicyEvaluationException":
            throw await de_PolicyEvaluationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SimulatePrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SimulatePrincipalPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SimulatePolicyResponse(data.SimulatePrincipalPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_SimulatePrincipalPolicyCommand = de_SimulatePrincipalPolicyCommand;
const de_SimulatePrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyEvaluation":
        case "com.amazonaws.iam#PolicyEvaluationException":
            throw await de_PolicyEvaluationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagInstanceProfileCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagInstanceProfileCommand = de_TagInstanceProfileCommand;
const de_TagInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagMFADeviceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagMFADeviceCommand = de_TagMFADeviceCommand;
const de_TagMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagOpenIDConnectProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagOpenIDConnectProviderCommand = de_TagOpenIDConnectProviderCommand;
const de_TagOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagPolicyCommand = de_TagPolicyCommand;
const de_TagPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagRoleCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagRoleCommand = de_TagRoleCommand;
const de_TagRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagSAMLProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagSAMLProviderCommand = de_TagSAMLProviderCommand;
const de_TagSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagServerCertificateCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagServerCertificateCommand = de_TagServerCertificateCommand;
const de_TagServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagUserCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagUserCommand = de_TagUserCommand;
const de_TagUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagInstanceProfileCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagInstanceProfileCommand = de_UntagInstanceProfileCommand;
const de_UntagInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagMFADeviceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagMFADeviceCommand = de_UntagMFADeviceCommand;
const de_UntagMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagOpenIDConnectProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagOpenIDConnectProviderCommand = de_UntagOpenIDConnectProviderCommand;
const de_UntagOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagPolicyCommand = de_UntagPolicyCommand;
const de_UntagPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagRoleCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagRoleCommand = de_UntagRoleCommand;
const de_UntagRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagSAMLProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagSAMLProviderCommand = de_UntagSAMLProviderCommand;
const de_UntagSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagServerCertificateCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagServerCertificateCommand = de_UntagServerCertificateCommand;
const de_UntagServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagUserCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagUserCommand = de_UntagUserCommand;
const de_UntagUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAccessKeyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateAccessKeyCommand = de_UpdateAccessKeyCommand;
const de_UpdateAccessKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAccountPasswordPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateAccountPasswordPolicyCommand = de_UpdateAccountPasswordPolicyCommand;
const de_UpdateAccountPasswordPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateAssumeRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAssumeRolePolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateAssumeRolePolicyCommand = de_UpdateAssumeRolePolicyCommand;
const de_UpdateAssumeRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateGroupCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateGroupCommand = de_UpdateGroupCommand;
const de_UpdateGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateLoginProfileCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateLoginProfileCommand = de_UpdateLoginProfileCommand;
const de_UpdateLoginProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PasswordPolicyViolation":
        case "com.amazonaws.iam#PasswordPolicyViolationException":
            throw await de_PasswordPolicyViolationExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateOpenIDConnectProviderThumbprintCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateOpenIDConnectProviderThumbprintCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateOpenIDConnectProviderThumbprintCommand = de_UpdateOpenIDConnectProviderThumbprintCommand;
const de_UpdateOpenIDConnectProviderThumbprintCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateRoleResponse(data.UpdateRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateRoleCommand = de_UpdateRoleCommand;
const de_UpdateRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateRoleDescriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateRoleDescriptionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateRoleDescriptionResponse(data.UpdateRoleDescriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateRoleDescriptionCommand = de_UpdateRoleDescriptionCommand;
const de_UpdateRoleDescriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateSAMLProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateSAMLProviderResponse(data.UpdateSAMLProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateSAMLProviderCommand = de_UpdateSAMLProviderCommand;
const de_UpdateSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateServerCertificateCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateServerCertificateCommand = de_UpdateServerCertificateCommand;
const de_UpdateServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateServiceSpecificCredentialCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateServiceSpecificCredentialCommand = de_UpdateServiceSpecificCredentialCommand;
const de_UpdateServiceSpecificCredentialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateSigningCertificateCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateSigningCertificateCommand = de_UpdateSigningCertificateCommand;
const de_UpdateSigningCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateSSHPublicKeyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateSSHPublicKeyCommand = de_UpdateSSHPublicKeyCommand;
const de_UpdateSSHPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateUserCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateUserCommand = de_UpdateUserCommand;
const de_UpdateUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UploadServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UploadServerCertificateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadServerCertificateResponse(data.UploadServerCertificateResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UploadServerCertificateCommand = de_UploadServerCertificateCommand;
const de_UploadServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "KeyPairMismatch":
        case "com.amazonaws.iam#KeyPairMismatchException":
            throw await de_KeyPairMismatchExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedCertificate":
        case "com.amazonaws.iam#MalformedCertificateException":
            throw await de_MalformedCertificateExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UploadSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UploadSigningCertificateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadSigningCertificateResponse(data.UploadSigningCertificateResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UploadSigningCertificateCommand = de_UploadSigningCertificateCommand;
const de_UploadSigningCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "DuplicateCertificate":
        case "com.amazonaws.iam#DuplicateCertificateException":
            throw await de_DuplicateCertificateExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidCertificate":
        case "com.amazonaws.iam#InvalidCertificateException":
            throw await de_InvalidCertificateExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedCertificate":
        case "com.amazonaws.iam#MalformedCertificateException":
            throw await de_MalformedCertificateExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UploadSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UploadSSHPublicKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadSSHPublicKeyResponse(data.UploadSSHPublicKeyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UploadSSHPublicKeyCommand = de_UploadSSHPublicKeyCommand;
const de_UploadSSHPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DuplicateSSHPublicKey":
        case "com.amazonaws.iam#DuplicateSSHPublicKeyException":
            throw await de_DuplicateSSHPublicKeyExceptionRes(parsedOutput, context);
        case "InvalidPublicKey":
        case "com.amazonaws.iam#InvalidPublicKeyException":
            throw await de_InvalidPublicKeyExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "UnrecognizedPublicKeyEncoding":
        case "com.amazonaws.iam#UnrecognizedPublicKeyEncodingException":
            throw await de_UnrecognizedPublicKeyEncodingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConcurrentModificationException(body.Error, context);
    const exception = new models_0_1.ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CredentialReportExpiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportExpiredException(body.Error, context);
    const exception = new models_0_1.CredentialReportExpiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CredentialReportNotPresentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportNotPresentException(body.Error, context);
    const exception = new models_0_1.CredentialReportNotPresentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CredentialReportNotReadyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportNotReadyException(body.Error, context);
    const exception = new models_0_1.CredentialReportNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DeleteConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DeleteConflictException(body.Error, context);
    const exception = new models_0_1.DeleteConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DuplicateCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateCertificateException(body.Error, context);
    const exception = new models_1_1.DuplicateCertificateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DuplicateSSHPublicKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateSSHPublicKeyException(body.Error, context);
    const exception = new models_1_1.DuplicateSSHPublicKeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_EntityAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EntityAlreadyExistsException(body.Error, context);
    const exception = new models_0_1.EntityAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_EntityTemporarilyUnmodifiableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EntityTemporarilyUnmodifiableException(body.Error, context);
    const exception = new models_0_1.EntityTemporarilyUnmodifiableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAuthenticationCodeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthenticationCodeException(body.Error, context);
    const exception = new models_0_1.InvalidAuthenticationCodeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCertificateException(body.Error, context);
    const exception = new models_1_1.InvalidCertificateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidInputExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidInputException(body.Error, context);
    const exception = new models_0_1.InvalidInputException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidPublicKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidPublicKeyException(body.Error, context);
    const exception = new models_1_1.InvalidPublicKeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidUserTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidUserTypeException(body.Error, context);
    const exception = new models_0_1.InvalidUserTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_KeyPairMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_KeyPairMismatchException(body.Error, context);
    const exception = new models_1_1.KeyPairMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededException(body.Error, context);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MalformedCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedCertificateException(body.Error, context);
    const exception = new models_1_1.MalformedCertificateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new models_0_1.MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_NoSuchEntityExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NoSuchEntityException(body.Error, context);
    const exception = new models_0_1.NoSuchEntityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PasswordPolicyViolationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PasswordPolicyViolationException(body.Error, context);
    const exception = new models_0_1.PasswordPolicyViolationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PolicyEvaluationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PolicyEvaluationException(body.Error, context);
    const exception = new models_0_1.PolicyEvaluationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PolicyNotAttachableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PolicyNotAttachableException(body.Error, context);
    const exception = new models_0_1.PolicyNotAttachableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReportGenerationLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReportGenerationLimitExceededException(body.Error, context);
    const exception = new models_0_1.ReportGenerationLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ServiceFailureExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceFailureException(body.Error, context);
    const exception = new models_0_1.ServiceFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ServiceNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceNotSupportedException(body.Error, context);
    const exception = new models_0_1.ServiceNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnmodifiableEntityExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnmodifiableEntityException(body.Error, context);
    const exception = new models_0_1.UnmodifiableEntityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnrecognizedPublicKeyEncodingExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnrecognizedPublicKeyEncodingException(body.Error, context);
    const exception = new models_0_1.UnrecognizedPublicKeyEncodingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_ActionNameListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AddClientIDToOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.ClientID != null) {
        entries["ClientID"] = input.ClientID;
    }
    return entries;
};
const se_AddRoleToInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_AddUserToGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_AttachGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_AttachRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_AttachUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_ChangePasswordRequest = (input, context) => {
    const entries = {};
    if (input.OldPassword != null) {
        entries["OldPassword"] = input.OldPassword;
    }
    if (input.NewPassword != null) {
        entries["NewPassword"] = input.NewPassword;
    }
    return entries;
};
const se_clientIDListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ContextEntry = (input, context) => {
    const entries = {};
    if (input.ContextKeyName != null) {
        entries["ContextKeyName"] = input.ContextKeyName;
    }
    if (input.ContextKeyValues != null) {
        const memberEntries = se_ContextKeyValueListType(input.ContextKeyValues, context);
        if (input.ContextKeyValues?.length === 0) {
            entries.ContextKeyValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextKeyValues.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ContextKeyType != null) {
        entries["ContextKeyType"] = input.ContextKeyType;
    }
    return entries;
};
const se_ContextEntryListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ContextEntry(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ContextKeyValueListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CreateAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_CreateAccountAliasRequest = (input, context) => {
    const entries = {};
    if (input.AccountAlias != null) {
        entries["AccountAlias"] = input.AccountAlias;
    }
    return entries;
};
const se_CreateGroupRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    return entries;
};
const se_CreateInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Password != null) {
        entries["Password"] = input.Password;
    }
    if (input.PasswordResetRequired != null) {
        entries["PasswordResetRequired"] = input.PasswordResetRequired;
    }
    return entries;
};
const se_CreateOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.Url != null) {
        entries["Url"] = input.Url;
    }
    if (input.ClientIDList != null) {
        const memberEntries = se_clientIDListType(input.ClientIDList, context);
        if (input.ClientIDList?.length === 0) {
            entries.ClientIDList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientIDList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ThumbprintList != null) {
        const memberEntries = se_thumbprintListType(input.ThumbprintList, context);
        if (input.ThumbprintList?.length === 0) {
            entries.ThumbprintList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ThumbprintList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreatePolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreatePolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    if (input.SetAsDefault != null) {
        entries["SetAsDefault"] = input.SetAsDefault;
    }
    return entries;
};
const se_CreateRoleRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.AssumeRolePolicyDocument != null) {
        entries["AssumeRolePolicyDocument"] = input.AssumeRolePolicyDocument;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    if (input.MaxSessionDuration != null) {
        entries["MaxSessionDuration"] = input.MaxSessionDuration;
    }
    if (input.PermissionsBoundary != null) {
        entries["PermissionsBoundary"] = input.PermissionsBoundary;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLMetadataDocument != null) {
        entries["SAMLMetadataDocument"] = input.SAMLMetadataDocument;
    }
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateServiceLinkedRoleRequest = (input, context) => {
    const entries = {};
    if (input.AWSServiceName != null) {
        entries["AWSServiceName"] = input.AWSServiceName;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    if (input.CustomSuffix != null) {
        entries["CustomSuffix"] = input.CustomSuffix;
    }
    return entries;
};
const se_CreateServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceName != null) {
        entries["ServiceName"] = input.ServiceName;
    }
    return entries;
};
const se_CreateUserRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PermissionsBoundary != null) {
        entries["PermissionsBoundary"] = input.PermissionsBoundary;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVirtualMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.VirtualMFADeviceName != null) {
        entries["VirtualMFADeviceName"] = input.VirtualMFADeviceName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeactivateMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    return entries;
};
const se_DeleteAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    return entries;
};
const se_DeleteAccountAliasRequest = (input, context) => {
    const entries = {};
    if (input.AccountAlias != null) {
        entries["AccountAlias"] = input.AccountAlias;
    }
    return entries;
};
const se_DeleteGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_DeleteGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    return entries;
};
const se_DeleteInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    return entries;
};
const se_DeleteLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_DeleteOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    return entries;
};
const se_DeletePolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_DeletePolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.VersionId != null) {
        entries["VersionId"] = input.VersionId;
    }
    return entries;
};
const se_DeleteRolePermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_DeleteRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_DeleteRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_DeleteSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    return entries;
};
const se_DeleteServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    return entries;
};
const se_DeleteServiceLinkedRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_DeleteServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceSpecificCredentialId != null) {
        entries["ServiceSpecificCredentialId"] = input.ServiceSpecificCredentialId;
    }
    return entries;
};
const se_DeleteSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.CertificateId != null) {
        entries["CertificateId"] = input.CertificateId;
    }
    return entries;
};
const se_DeleteSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SSHPublicKeyId != null) {
        entries["SSHPublicKeyId"] = input.SSHPublicKeyId;
    }
    return entries;
};
const se_DeleteUserPermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_DeleteUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_DeleteUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_DeleteVirtualMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    return entries;
};
const se_DetachGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_DetachRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_DetachUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_EnableMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.AuthenticationCode1 != null) {
        entries["AuthenticationCode1"] = input.AuthenticationCode1;
    }
    if (input.AuthenticationCode2 != null) {
        entries["AuthenticationCode2"] = input.AuthenticationCode2;
    }
    return entries;
};
const se_entityListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GenerateOrganizationsAccessReportRequest = (input, context) => {
    const entries = {};
    if (input.EntityPath != null) {
        entries["EntityPath"] = input.EntityPath;
    }
    if (input.OrganizationsPolicyId != null) {
        entries["OrganizationsPolicyId"] = input.OrganizationsPolicyId;
    }
    return entries;
};
const se_GenerateServiceLastAccessedDetailsRequest = (input, context) => {
    const entries = {};
    if (input.Arn != null) {
        entries["Arn"] = input.Arn;
    }
    if (input.Granularity != null) {
        entries["Granularity"] = input.Granularity;
    }
    return entries;
};
const se_GetAccessKeyLastUsedRequest = (input, context) => {
    const entries = {};
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    return entries;
};
const se_GetAccountAuthorizationDetailsRequest = (input, context) => {
    const entries = {};
    if (input.Filter != null) {
        const memberEntries = se_entityListType(input.Filter, context);
        if (input.Filter?.length === 0) {
            entries.Filter = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_GetContextKeysForCustomPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PolicyInputList, context);
        if (input.PolicyInputList?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetContextKeysForPrincipalPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicySourceArn != null) {
        entries["PolicySourceArn"] = input.PolicySourceArn;
    }
    if (input.PolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PolicyInputList, context);
        if (input.PolicyInputList?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_GetGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_GetInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    return entries;
};
const se_GetLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_GetMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_GetOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    return entries;
};
const se_GetOrganizationsAccessReportRequest = (input, context) => {
    const entries = {};
    if (input.JobId != null) {
        entries["JobId"] = input.JobId;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.SortKey != null) {
        entries["SortKey"] = input.SortKey;
    }
    return entries;
};
const se_GetPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_GetPolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.VersionId != null) {
        entries["VersionId"] = input.VersionId;
    }
    return entries;
};
const se_GetRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_GetRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_GetSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    return entries;
};
const se_GetServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    return entries;
};
const se_GetServiceLastAccessedDetailsRequest = (input, context) => {
    const entries = {};
    if (input.JobId != null) {
        entries["JobId"] = input.JobId;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_GetServiceLastAccessedDetailsWithEntitiesRequest = (input, context) => {
    const entries = {};
    if (input.JobId != null) {
        entries["JobId"] = input.JobId;
    }
    if (input.ServiceNamespace != null) {
        entries["ServiceNamespace"] = input.ServiceNamespace;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_GetServiceLinkedRoleDeletionStatusRequest = (input, context) => {
    const entries = {};
    if (input.DeletionTaskId != null) {
        entries["DeletionTaskId"] = input.DeletionTaskId;
    }
    return entries;
};
const se_GetSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SSHPublicKeyId != null) {
        entries["SSHPublicKeyId"] = input.SSHPublicKeyId;
    }
    if (input.Encoding != null) {
        entries["Encoding"] = input.Encoding;
    }
    return entries;
};
const se_GetUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_GetUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_ListAccessKeysRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListAccountAliasesRequest = (input, context) => {
    const entries = {};
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListAttachedGroupPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListAttachedRolePoliciesRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListAttachedUserPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListEntitiesForPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.EntityFilter != null) {
        entries["EntityFilter"] = input.EntityFilter;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.PolicyUsageFilter != null) {
        entries["PolicyUsageFilter"] = input.PolicyUsageFilter;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListGroupPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListGroupsForUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListGroupsRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListInstanceProfilesForRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListInstanceProfilesRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListInstanceProfileTagsRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListMFADevicesRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListMFADeviceTagsRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListOpenIDConnectProvidersRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_ListOpenIDConnectProviderTagsRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListPoliciesGrantingServiceAccessRequest = (input, context) => {
    const entries = {};
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.Arn != null) {
        entries["Arn"] = input.Arn;
    }
    if (input.ServiceNamespaces != null) {
        const memberEntries = se_serviceNamespaceListType(input.ServiceNamespaces, context);
        if (input.ServiceNamespaces?.length === 0) {
            entries.ServiceNamespaces = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceNamespaces.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ListPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.Scope != null) {
        entries["Scope"] = input.Scope;
    }
    if (input.OnlyAttached != null) {
        entries["OnlyAttached"] = input.OnlyAttached;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.PolicyUsageFilter != null) {
        entries["PolicyUsageFilter"] = input.PolicyUsageFilter;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListPolicyTagsRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListPolicyVersionsRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListRolePoliciesRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListRolesRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListRoleTagsRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListSAMLProvidersRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_ListSAMLProviderTagsRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListServerCertificatesRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListServerCertificateTagsRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListServiceSpecificCredentialsRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceName != null) {
        entries["ServiceName"] = input.ServiceName;
    }
    return entries;
};
const se_ListSigningCertificatesRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListSSHPublicKeysRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListUserPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListUsersRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListUserTagsRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListVirtualMFADevicesRequest = (input, context) => {
    const entries = {};
    if (input.AssignmentStatus != null) {
        entries["AssignmentStatus"] = input.AssignmentStatus;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_PutGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    return entries;
};
const se_PutRolePermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PermissionsBoundary != null) {
        entries["PermissionsBoundary"] = input.PermissionsBoundary;
    }
    return entries;
};
const se_PutRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    return entries;
};
const se_PutUserPermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PermissionsBoundary != null) {
        entries["PermissionsBoundary"] = input.PermissionsBoundary;
    }
    return entries;
};
const se_PutUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    return entries;
};
const se_RemoveClientIDFromOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.ClientID != null) {
        entries["ClientID"] = input.ClientID;
    }
    return entries;
};
const se_RemoveRoleFromInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_RemoveUserFromGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_ResetServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceSpecificCredentialId != null) {
        entries["ServiceSpecificCredentialId"] = input.ServiceSpecificCredentialId;
    }
    return entries;
};
const se_ResourceNameListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ResyncMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.AuthenticationCode1 != null) {
        entries["AuthenticationCode1"] = input.AuthenticationCode1;
    }
    if (input.AuthenticationCode2 != null) {
        entries["AuthenticationCode2"] = input.AuthenticationCode2;
    }
    return entries;
};
const se_serviceNamespaceListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetDefaultPolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.VersionId != null) {
        entries["VersionId"] = input.VersionId;
    }
    return entries;
};
const se_SetSecurityTokenServicePreferencesRequest = (input, context) => {
    const entries = {};
    if (input.GlobalEndpointTokenVersion != null) {
        entries["GlobalEndpointTokenVersion"] = input.GlobalEndpointTokenVersion;
    }
    return entries;
};
const se_SimulateCustomPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PolicyInputList, context);
        if (input.PolicyInputList?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.PermissionsBoundaryPolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PermissionsBoundaryPolicyInputList, context);
        if (input.PermissionsBoundaryPolicyInputList?.length === 0) {
            entries.PermissionsBoundaryPolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PermissionsBoundaryPolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ActionNames != null) {
        const memberEntries = se_ActionNameListType(input.ActionNames, context);
        if (input.ActionNames?.length === 0) {
            entries.ActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourceArns != null) {
        const memberEntries = se_ResourceNameListType(input.ResourceArns, context);
        if (input.ResourceArns?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourcePolicy != null) {
        entries["ResourcePolicy"] = input.ResourcePolicy;
    }
    if (input.ResourceOwner != null) {
        entries["ResourceOwner"] = input.ResourceOwner;
    }
    if (input.CallerArn != null) {
        entries["CallerArn"] = input.CallerArn;
    }
    if (input.ContextEntries != null) {
        const memberEntries = se_ContextEntryListType(input.ContextEntries, context);
        if (input.ContextEntries?.length === 0) {
            entries.ContextEntries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextEntries.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourceHandlingOption != null) {
        entries["ResourceHandlingOption"] = input.ResourceHandlingOption;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_SimulatePrincipalPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicySourceArn != null) {
        entries["PolicySourceArn"] = input.PolicySourceArn;
    }
    if (input.PolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PolicyInputList, context);
        if (input.PolicyInputList?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.PermissionsBoundaryPolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PermissionsBoundaryPolicyInputList, context);
        if (input.PermissionsBoundaryPolicyInputList?.length === 0) {
            entries.PermissionsBoundaryPolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PermissionsBoundaryPolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ActionNames != null) {
        const memberEntries = se_ActionNameListType(input.ActionNames, context);
        if (input.ActionNames?.length === 0) {
            entries.ActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourceArns != null) {
        const memberEntries = se_ResourceNameListType(input.ResourceArns, context);
        if (input.ResourceArns?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourcePolicy != null) {
        entries["ResourcePolicy"] = input.ResourcePolicy;
    }
    if (input.ResourceOwner != null) {
        entries["ResourceOwner"] = input.ResourceOwner;
    }
    if (input.CallerArn != null) {
        entries["CallerArn"] = input.CallerArn;
    }
    if (input.ContextEntries != null) {
        const memberEntries = se_ContextEntryListType(input.ContextEntries, context);
        if (input.ContextEntries?.length === 0) {
            entries.ContextEntries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextEntries.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourceHandlingOption != null) {
        entries["ResourceHandlingOption"] = input.ResourceHandlingOption;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_SimulationPolicyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_TagInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_tagKeyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_tagListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TagMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_thumbprintListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UntagInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    if (input.Status != null) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const se_UpdateAccountPasswordPolicyRequest = (input, context) => {
    const entries = {};
    if (input.MinimumPasswordLength != null) {
        entries["MinimumPasswordLength"] = input.MinimumPasswordLength;
    }
    if (input.RequireSymbols != null) {
        entries["RequireSymbols"] = input.RequireSymbols;
    }
    if (input.RequireNumbers != null) {
        entries["RequireNumbers"] = input.RequireNumbers;
    }
    if (input.RequireUppercaseCharacters != null) {
        entries["RequireUppercaseCharacters"] = input.RequireUppercaseCharacters;
    }
    if (input.RequireLowercaseCharacters != null) {
        entries["RequireLowercaseCharacters"] = input.RequireLowercaseCharacters;
    }
    if (input.AllowUsersToChangePassword != null) {
        entries["AllowUsersToChangePassword"] = input.AllowUsersToChangePassword;
    }
    if (input.MaxPasswordAge != null) {
        entries["MaxPasswordAge"] = input.MaxPasswordAge;
    }
    if (input.PasswordReusePrevention != null) {
        entries["PasswordReusePrevention"] = input.PasswordReusePrevention;
    }
    if (input.HardExpiry != null) {
        entries["HardExpiry"] = input.HardExpiry;
    }
    return entries;
};
const se_UpdateAssumeRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    return entries;
};
const se_UpdateGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.NewPath != null) {
        entries["NewPath"] = input.NewPath;
    }
    if (input.NewGroupName != null) {
        entries["NewGroupName"] = input.NewGroupName;
    }
    return entries;
};
const se_UpdateLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Password != null) {
        entries["Password"] = input.Password;
    }
    if (input.PasswordResetRequired != null) {
        entries["PasswordResetRequired"] = input.PasswordResetRequired;
    }
    return entries;
};
const se_UpdateOpenIDConnectProviderThumbprintRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.ThumbprintList != null) {
        const memberEntries = se_thumbprintListType(input.ThumbprintList, context);
        if (input.ThumbprintList?.length === 0) {
            entries.ThumbprintList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ThumbprintList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateRoleDescriptionRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    return entries;
};
const se_UpdateRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    if (input.MaxSessionDuration != null) {
        entries["MaxSessionDuration"] = input.MaxSessionDuration;
    }
    return entries;
};
const se_UpdateSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLMetadataDocument != null) {
        entries["SAMLMetadataDocument"] = input.SAMLMetadataDocument;
    }
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    return entries;
};
const se_UpdateServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.NewPath != null) {
        entries["NewPath"] = input.NewPath;
    }
    if (input.NewServerCertificateName != null) {
        entries["NewServerCertificateName"] = input.NewServerCertificateName;
    }
    return entries;
};
const se_UpdateServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceSpecificCredentialId != null) {
        entries["ServiceSpecificCredentialId"] = input.ServiceSpecificCredentialId;
    }
    if (input.Status != null) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const se_UpdateSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.CertificateId != null) {
        entries["CertificateId"] = input.CertificateId;
    }
    if (input.Status != null) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const se_UpdateSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SSHPublicKeyId != null) {
        entries["SSHPublicKeyId"] = input.SSHPublicKeyId;
    }
    if (input.Status != null) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const se_UpdateUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.NewPath != null) {
        entries["NewPath"] = input.NewPath;
    }
    if (input.NewUserName != null) {
        entries["NewUserName"] = input.NewUserName;
    }
    return entries;
};
const se_UploadServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.CertificateBody != null) {
        entries["CertificateBody"] = input.CertificateBody;
    }
    if (input.PrivateKey != null) {
        entries["PrivateKey"] = input.PrivateKey;
    }
    if (input.CertificateChain != null) {
        entries["CertificateChain"] = input.CertificateChain;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UploadSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.CertificateBody != null) {
        entries["CertificateBody"] = input.CertificateBody;
    }
    return entries;
};
const se_UploadSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SSHPublicKeyBody != null) {
        entries["SSHPublicKeyBody"] = input.SSHPublicKeyBody;
    }
    return entries;
};
const de_AccessDetail = (output, context) => {
    const contents = {};
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = (0, smithy_client_1.expectString)(output["ServiceName"]);
    }
    if (output["ServiceNamespace"] !== undefined) {
        contents.ServiceNamespace = (0, smithy_client_1.expectString)(output["ServiceNamespace"]);
    }
    if (output["Region"] !== undefined) {
        contents.Region = (0, smithy_client_1.expectString)(output["Region"]);
    }
    if (output["EntityPath"] !== undefined) {
        contents.EntityPath = (0, smithy_client_1.expectString)(output["EntityPath"]);
    }
    if (output["LastAuthenticatedTime"] !== undefined) {
        contents.LastAuthenticatedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastAuthenticatedTime"]));
    }
    if (output["TotalAuthenticatedEntities"] !== undefined) {
        contents.TotalAuthenticatedEntities = (0, smithy_client_1.strictParseInt32)(output["TotalAuthenticatedEntities"]);
    }
    return contents;
};
const de_AccessDetails = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessDetail(entry, context);
    });
};
const de_AccessKey = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["AccessKeyId"] !== undefined) {
        contents.AccessKeyId = (0, smithy_client_1.expectString)(output["AccessKeyId"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["SecretAccessKey"] !== undefined) {
        contents.SecretAccessKey = (0, smithy_client_1.expectString)(output["SecretAccessKey"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    return contents;
};
const de_AccessKeyLastUsed = (output, context) => {
    const contents = {};
    if (output["LastUsedDate"] !== undefined) {
        contents.LastUsedDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastUsedDate"]));
    }
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = (0, smithy_client_1.expectString)(output["ServiceName"]);
    }
    if (output["Region"] !== undefined) {
        contents.Region = (0, smithy_client_1.expectString)(output["Region"]);
    }
    return contents;
};
const de_AccessKeyMetadata = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["AccessKeyId"] !== undefined) {
        contents.AccessKeyId = (0, smithy_client_1.expectString)(output["AccessKeyId"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    return contents;
};
const de_accessKeyMetadataListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessKeyMetadata(entry, context);
    });
};
const de_accountAliasListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_ArnListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AttachedPermissionsBoundary = (output, context) => {
    const contents = {};
    if (output["PermissionsBoundaryType"] !== undefined) {
        contents.PermissionsBoundaryType = (0, smithy_client_1.expectString)(output["PermissionsBoundaryType"]);
    }
    if (output["PermissionsBoundaryArn"] !== undefined) {
        contents.PermissionsBoundaryArn = (0, smithy_client_1.expectString)(output["PermissionsBoundaryArn"]);
    }
    return contents;
};
const de_attachedPoliciesListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttachedPolicy(entry, context);
    });
};
const de_AttachedPolicy = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = (0, smithy_client_1.expectString)(output["PolicyName"]);
    }
    if (output["PolicyArn"] !== undefined) {
        contents.PolicyArn = (0, smithy_client_1.expectString)(output["PolicyArn"]);
    }
    return contents;
};
const de_certificateListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SigningCertificate(entry, context);
    });
};
const de_CertificationMapType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = (0, smithy_client_1.expectString)(pair["value"]);
        return acc;
    }, {});
};
const de_clientIDListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_ConcurrentModificationException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_ContextKeyNamesResultListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_CreateAccessKeyResponse = (output, context) => {
    const contents = {};
    if (output["AccessKey"] !== undefined) {
        contents.AccessKey = de_AccessKey(output["AccessKey"], context);
    }
    return contents;
};
const de_CreateGroupResponse = (output, context) => {
    const contents = {};
    if (output["Group"] !== undefined) {
        contents.Group = de_Group(output["Group"], context);
    }
    return contents;
};
const de_CreateInstanceProfileResponse = (output, context) => {
    const contents = {};
    if (output["InstanceProfile"] !== undefined) {
        contents.InstanceProfile = de_InstanceProfile(output["InstanceProfile"], context);
    }
    return contents;
};
const de_CreateLoginProfileResponse = (output, context) => {
    const contents = {};
    if (output["LoginProfile"] !== undefined) {
        contents.LoginProfile = de_LoginProfile(output["LoginProfile"], context);
    }
    return contents;
};
const de_CreateOpenIDConnectProviderResponse = (output, context) => {
    const contents = {};
    if (output["OpenIDConnectProviderArn"] !== undefined) {
        contents.OpenIDConnectProviderArn = (0, smithy_client_1.expectString)(output["OpenIDConnectProviderArn"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_CreatePolicyResponse = (output, context) => {
    const contents = {};
    if (output["Policy"] !== undefined) {
        contents.Policy = de_Policy(output["Policy"], context);
    }
    return contents;
};
const de_CreatePolicyVersionResponse = (output, context) => {
    const contents = {};
    if (output["PolicyVersion"] !== undefined) {
        contents.PolicyVersion = de_PolicyVersion(output["PolicyVersion"], context);
    }
    return contents;
};
const de_CreateRoleResponse = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = de_Role(output["Role"], context);
    }
    return contents;
};
const de_CreateSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output["SAMLProviderArn"] !== undefined) {
        contents.SAMLProviderArn = (0, smithy_client_1.expectString)(output["SAMLProviderArn"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_CreateServiceLinkedRoleResponse = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = de_Role(output["Role"], context);
    }
    return contents;
};
const de_CreateServiceSpecificCredentialResponse = (output, context) => {
    const contents = {};
    if (output["ServiceSpecificCredential"] !== undefined) {
        contents.ServiceSpecificCredential = de_ServiceSpecificCredential(output["ServiceSpecificCredential"], context);
    }
    return contents;
};
const de_CreateUserResponse = (output, context) => {
    const contents = {};
    if (output["User"] !== undefined) {
        contents.User = de_User(output["User"], context);
    }
    return contents;
};
const de_CreateVirtualMFADeviceResponse = (output, context) => {
    const contents = {};
    if (output["VirtualMFADevice"] !== undefined) {
        contents.VirtualMFADevice = de_VirtualMFADevice(output["VirtualMFADevice"], context);
    }
    return contents;
};
const de_CredentialReportExpiredException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_CredentialReportNotPresentException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_CredentialReportNotReadyException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_DeleteConflictException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_DeleteServiceLinkedRoleResponse = (output, context) => {
    const contents = {};
    if (output["DeletionTaskId"] !== undefined) {
        contents.DeletionTaskId = (0, smithy_client_1.expectString)(output["DeletionTaskId"]);
    }
    return contents;
};
const de_DeletionTaskFailureReasonType = (output, context) => {
    const contents = {};
    if (output["Reason"] !== undefined) {
        contents.Reason = (0, smithy_client_1.expectString)(output["Reason"]);
    }
    if (output.RoleUsageList === "") {
        contents.RoleUsageList = [];
    }
    else if (output["RoleUsageList"] !== undefined && output["RoleUsageList"]["member"] !== undefined) {
        contents.RoleUsageList = de_RoleUsageListType((0, smithy_client_1.getArrayIfSingleItem)(output["RoleUsageList"]["member"]), context);
    }
    return contents;
};
const de_DuplicateCertificateException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_DuplicateSSHPublicKeyException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_EntityAlreadyExistsException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_EntityDetails = (output, context) => {
    const contents = {};
    if (output["EntityInfo"] !== undefined) {
        contents.EntityInfo = de_EntityInfo(output["EntityInfo"], context);
    }
    if (output["LastAuthenticated"] !== undefined) {
        contents.LastAuthenticated = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastAuthenticated"]));
    }
    return contents;
};
const de_entityDetailsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EntityDetails(entry, context);
    });
};
const de_EntityInfo = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["Type"] !== undefined) {
        contents.Type = (0, smithy_client_1.expectString)(output["Type"]);
    }
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    return contents;
};
const de_EntityTemporarilyUnmodifiableException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_ErrorDetails = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    if (output["Code"] !== undefined) {
        contents.Code = (0, smithy_client_1.expectString)(output["Code"]);
    }
    return contents;
};
const de_EvalDecisionDetailsType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = (0, smithy_client_1.expectString)(pair["value"]);
        return acc;
    }, {});
};
const de_EvaluationResult = (output, context) => {
    const contents = {};
    if (output["EvalActionName"] !== undefined) {
        contents.EvalActionName = (0, smithy_client_1.expectString)(output["EvalActionName"]);
    }
    if (output["EvalResourceName"] !== undefined) {
        contents.EvalResourceName = (0, smithy_client_1.expectString)(output["EvalResourceName"]);
    }
    if (output["EvalDecision"] !== undefined) {
        contents.EvalDecision = (0, smithy_client_1.expectString)(output["EvalDecision"]);
    }
    if (output.MatchedStatements === "") {
        contents.MatchedStatements = [];
    }
    else if (output["MatchedStatements"] !== undefined && output["MatchedStatements"]["member"] !== undefined) {
        contents.MatchedStatements = de_StatementListType((0, smithy_client_1.getArrayIfSingleItem)(output["MatchedStatements"]["member"]), context);
    }
    if (output.MissingContextValues === "") {
        contents.MissingContextValues = [];
    }
    else if (output["MissingContextValues"] !== undefined && output["MissingContextValues"]["member"] !== undefined) {
        contents.MissingContextValues = de_ContextKeyNamesResultListType((0, smithy_client_1.getArrayIfSingleItem)(output["MissingContextValues"]["member"]), context);
    }
    if (output["OrganizationsDecisionDetail"] !== undefined) {
        contents.OrganizationsDecisionDetail = de_OrganizationsDecisionDetail(output["OrganizationsDecisionDetail"], context);
    }
    if (output["PermissionsBoundaryDecisionDetail"] !== undefined) {
        contents.PermissionsBoundaryDecisionDetail = de_PermissionsBoundaryDecisionDetail(output["PermissionsBoundaryDecisionDetail"], context);
    }
    if (output.EvalDecisionDetails === "") {
        contents.EvalDecisionDetails = {};
    }
    else if (output["EvalDecisionDetails"] !== undefined && output["EvalDecisionDetails"]["entry"] !== undefined) {
        contents.EvalDecisionDetails = de_EvalDecisionDetailsType((0, smithy_client_1.getArrayIfSingleItem)(output["EvalDecisionDetails"]["entry"]), context);
    }
    if (output.ResourceSpecificResults === "") {
        contents.ResourceSpecificResults = [];
    }
    else if (output["ResourceSpecificResults"] !== undefined &&
        output["ResourceSpecificResults"]["member"] !== undefined) {
        contents.ResourceSpecificResults = de_ResourceSpecificResultListType((0, smithy_client_1.getArrayIfSingleItem)(output["ResourceSpecificResults"]["member"]), context);
    }
    return contents;
};
const de_EvaluationResultsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EvaluationResult(entry, context);
    });
};
const de_GenerateCredentialReportResponse = (output, context) => {
    const contents = {};
    if (output["State"] !== undefined) {
        contents.State = (0, smithy_client_1.expectString)(output["State"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = (0, smithy_client_1.expectString)(output["Description"]);
    }
    return contents;
};
const de_GenerateOrganizationsAccessReportResponse = (output, context) => {
    const contents = {};
    if (output["JobId"] !== undefined) {
        contents.JobId = (0, smithy_client_1.expectString)(output["JobId"]);
    }
    return contents;
};
const de_GenerateServiceLastAccessedDetailsResponse = (output, context) => {
    const contents = {};
    if (output["JobId"] !== undefined) {
        contents.JobId = (0, smithy_client_1.expectString)(output["JobId"]);
    }
    return contents;
};
const de_GetAccessKeyLastUsedResponse = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["AccessKeyLastUsed"] !== undefined) {
        contents.AccessKeyLastUsed = de_AccessKeyLastUsed(output["AccessKeyLastUsed"], context);
    }
    return contents;
};
const de_GetAccountAuthorizationDetailsResponse = (output, context) => {
    const contents = {};
    if (output.UserDetailList === "") {
        contents.UserDetailList = [];
    }
    else if (output["UserDetailList"] !== undefined && output["UserDetailList"]["member"] !== undefined) {
        contents.UserDetailList = de_userDetailListType((0, smithy_client_1.getArrayIfSingleItem)(output["UserDetailList"]["member"]), context);
    }
    if (output.GroupDetailList === "") {
        contents.GroupDetailList = [];
    }
    else if (output["GroupDetailList"] !== undefined && output["GroupDetailList"]["member"] !== undefined) {
        contents.GroupDetailList = de_groupDetailListType((0, smithy_client_1.getArrayIfSingleItem)(output["GroupDetailList"]["member"]), context);
    }
    if (output.RoleDetailList === "") {
        contents.RoleDetailList = [];
    }
    else if (output["RoleDetailList"] !== undefined && output["RoleDetailList"]["member"] !== undefined) {
        contents.RoleDetailList = de_roleDetailListType((0, smithy_client_1.getArrayIfSingleItem)(output["RoleDetailList"]["member"]), context);
    }
    if (output.Policies === "") {
        contents.Policies = [];
    }
    else if (output["Policies"] !== undefined && output["Policies"]["member"] !== undefined) {
        contents.Policies = de_ManagedPolicyDetailListType((0, smithy_client_1.getArrayIfSingleItem)(output["Policies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_GetAccountPasswordPolicyResponse = (output, context) => {
    const contents = {};
    if (output["PasswordPolicy"] !== undefined) {
        contents.PasswordPolicy = de_PasswordPolicy(output["PasswordPolicy"], context);
    }
    return contents;
};
const de_GetAccountSummaryResponse = (output, context) => {
    const contents = {};
    if (output.SummaryMap === "") {
        contents.SummaryMap = {};
    }
    else if (output["SummaryMap"] !== undefined && output["SummaryMap"]["entry"] !== undefined) {
        contents.SummaryMap = de_summaryMapType((0, smithy_client_1.getArrayIfSingleItem)(output["SummaryMap"]["entry"]), context);
    }
    return contents;
};
const de_GetContextKeysForPolicyResponse = (output, context) => {
    const contents = {};
    if (output.ContextKeyNames === "") {
        contents.ContextKeyNames = [];
    }
    else if (output["ContextKeyNames"] !== undefined && output["ContextKeyNames"]["member"] !== undefined) {
        contents.ContextKeyNames = de_ContextKeyNamesResultListType((0, smithy_client_1.getArrayIfSingleItem)(output["ContextKeyNames"]["member"]), context);
    }
    return contents;
};
const de_GetCredentialReportResponse = (output, context) => {
    const contents = {};
    if (output["Content"] !== undefined) {
        contents.Content = context.base64Decoder(output["Content"]);
    }
    if (output["ReportFormat"] !== undefined) {
        contents.ReportFormat = (0, smithy_client_1.expectString)(output["ReportFormat"]);
    }
    if (output["GeneratedTime"] !== undefined) {
        contents.GeneratedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["GeneratedTime"]));
    }
    return contents;
};
const de_GetGroupPolicyResponse = (output, context) => {
    const contents = {};
    if (output["GroupName"] !== undefined) {
        contents.GroupName = (0, smithy_client_1.expectString)(output["GroupName"]);
    }
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = (0, smithy_client_1.expectString)(output["PolicyName"]);
    }
    if (output["PolicyDocument"] !== undefined) {
        contents.PolicyDocument = (0, smithy_client_1.expectString)(output["PolicyDocument"]);
    }
    return contents;
};
const de_GetGroupResponse = (output, context) => {
    const contents = {};
    if (output["Group"] !== undefined) {
        contents.Group = de_Group(output["Group"], context);
    }
    if (output.Users === "") {
        contents.Users = [];
    }
    else if (output["Users"] !== undefined && output["Users"]["member"] !== undefined) {
        contents.Users = de_userListType((0, smithy_client_1.getArrayIfSingleItem)(output["Users"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_GetInstanceProfileResponse = (output, context) => {
    const contents = {};
    if (output["InstanceProfile"] !== undefined) {
        contents.InstanceProfile = de_InstanceProfile(output["InstanceProfile"], context);
    }
    return contents;
};
const de_GetLoginProfileResponse = (output, context) => {
    const contents = {};
    if (output["LoginProfile"] !== undefined) {
        contents.LoginProfile = de_LoginProfile(output["LoginProfile"], context);
    }
    return contents;
};
const de_GetMFADeviceResponse = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["SerialNumber"] !== undefined) {
        contents.SerialNumber = (0, smithy_client_1.expectString)(output["SerialNumber"]);
    }
    if (output["EnableDate"] !== undefined) {
        contents.EnableDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["EnableDate"]));
    }
    if (output.Certifications === "") {
        contents.Certifications = {};
    }
    else if (output["Certifications"] !== undefined && output["Certifications"]["entry"] !== undefined) {
        contents.Certifications = de_CertificationMapType((0, smithy_client_1.getArrayIfSingleItem)(output["Certifications"]["entry"]), context);
    }
    return contents;
};
const de_GetOpenIDConnectProviderResponse = (output, context) => {
    const contents = {};
    if (output["Url"] !== undefined) {
        contents.Url = (0, smithy_client_1.expectString)(output["Url"]);
    }
    if (output.ClientIDList === "") {
        contents.ClientIDList = [];
    }
    else if (output["ClientIDList"] !== undefined && output["ClientIDList"]["member"] !== undefined) {
        contents.ClientIDList = de_clientIDListType((0, smithy_client_1.getArrayIfSingleItem)(output["ClientIDList"]["member"]), context);
    }
    if (output.ThumbprintList === "") {
        contents.ThumbprintList = [];
    }
    else if (output["ThumbprintList"] !== undefined && output["ThumbprintList"]["member"] !== undefined) {
        contents.ThumbprintList = de_thumbprintListType((0, smithy_client_1.getArrayIfSingleItem)(output["ThumbprintList"]["member"]), context);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_GetOrganizationsAccessReportResponse = (output, context) => {
    const contents = {};
    if (output["JobStatus"] !== undefined) {
        contents.JobStatus = (0, smithy_client_1.expectString)(output["JobStatus"]);
    }
    if (output["JobCreationDate"] !== undefined) {
        contents.JobCreationDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["JobCreationDate"]));
    }
    if (output["JobCompletionDate"] !== undefined) {
        contents.JobCompletionDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["JobCompletionDate"]));
    }
    if (output["NumberOfServicesAccessible"] !== undefined) {
        contents.NumberOfServicesAccessible = (0, smithy_client_1.strictParseInt32)(output["NumberOfServicesAccessible"]);
    }
    if (output["NumberOfServicesNotAccessed"] !== undefined) {
        contents.NumberOfServicesNotAccessed = (0, smithy_client_1.strictParseInt32)(output["NumberOfServicesNotAccessed"]);
    }
    if (output.AccessDetails === "") {
        contents.AccessDetails = [];
    }
    else if (output["AccessDetails"] !== undefined && output["AccessDetails"]["member"] !== undefined) {
        contents.AccessDetails = de_AccessDetails((0, smithy_client_1.getArrayIfSingleItem)(output["AccessDetails"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["ErrorDetails"] !== undefined) {
        contents.ErrorDetails = de_ErrorDetails(output["ErrorDetails"], context);
    }
    return contents;
};
const de_GetPolicyResponse = (output, context) => {
    const contents = {};
    if (output["Policy"] !== undefined) {
        contents.Policy = de_Policy(output["Policy"], context);
    }
    return contents;
};
const de_GetPolicyVersionResponse = (output, context) => {
    const contents = {};
    if (output["PolicyVersion"] !== undefined) {
        contents.PolicyVersion = de_PolicyVersion(output["PolicyVersion"], context);
    }
    return contents;
};
const de_GetRolePolicyResponse = (output, context) => {
    const contents = {};
    if (output["RoleName"] !== undefined) {
        contents.RoleName = (0, smithy_client_1.expectString)(output["RoleName"]);
    }
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = (0, smithy_client_1.expectString)(output["PolicyName"]);
    }
    if (output["PolicyDocument"] !== undefined) {
        contents.PolicyDocument = (0, smithy_client_1.expectString)(output["PolicyDocument"]);
    }
    return contents;
};
const de_GetRoleResponse = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = de_Role(output["Role"], context);
    }
    return contents;
};
const de_GetSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output["SAMLMetadataDocument"] !== undefined) {
        contents.SAMLMetadataDocument = (0, smithy_client_1.expectString)(output["SAMLMetadataDocument"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["ValidUntil"] !== undefined) {
        contents.ValidUntil = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["ValidUntil"]));
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_GetServerCertificateResponse = (output, context) => {
    const contents = {};
    if (output["ServerCertificate"] !== undefined) {
        contents.ServerCertificate = de_ServerCertificate(output["ServerCertificate"], context);
    }
    return contents;
};
const de_GetServiceLastAccessedDetailsResponse = (output, context) => {
    const contents = {};
    if (output["JobStatus"] !== undefined) {
        contents.JobStatus = (0, smithy_client_1.expectString)(output["JobStatus"]);
    }
    if (output["JobType"] !== undefined) {
        contents.JobType = (0, smithy_client_1.expectString)(output["JobType"]);
    }
    if (output["JobCreationDate"] !== undefined) {
        contents.JobCreationDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["JobCreationDate"]));
    }
    if (output.ServicesLastAccessed === "") {
        contents.ServicesLastAccessed = [];
    }
    else if (output["ServicesLastAccessed"] !== undefined && output["ServicesLastAccessed"]["member"] !== undefined) {
        contents.ServicesLastAccessed = de_ServicesLastAccessed((0, smithy_client_1.getArrayIfSingleItem)(output["ServicesLastAccessed"]["member"]), context);
    }
    if (output["JobCompletionDate"] !== undefined) {
        contents.JobCompletionDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["JobCompletionDate"]));
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["Error"] !== undefined) {
        contents.Error = de_ErrorDetails(output["Error"], context);
    }
    return contents;
};
const de_GetServiceLastAccessedDetailsWithEntitiesResponse = (output, context) => {
    const contents = {};
    if (output["JobStatus"] !== undefined) {
        contents.JobStatus = (0, smithy_client_1.expectString)(output["JobStatus"]);
    }
    if (output["JobCreationDate"] !== undefined) {
        contents.JobCreationDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["JobCreationDate"]));
    }
    if (output["JobCompletionDate"] !== undefined) {
        contents.JobCompletionDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["JobCompletionDate"]));
    }
    if (output.EntityDetailsList === "") {
        contents.EntityDetailsList = [];
    }
    else if (output["EntityDetailsList"] !== undefined && output["EntityDetailsList"]["member"] !== undefined) {
        contents.EntityDetailsList = de_entityDetailsListType((0, smithy_client_1.getArrayIfSingleItem)(output["EntityDetailsList"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["Error"] !== undefined) {
        contents.Error = de_ErrorDetails(output["Error"], context);
    }
    return contents;
};
const de_GetServiceLinkedRoleDeletionStatusResponse = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["Reason"] !== undefined) {
        contents.Reason = de_DeletionTaskFailureReasonType(output["Reason"], context);
    }
    return contents;
};
const de_GetSSHPublicKeyResponse = (output, context) => {
    const contents = {};
    if (output["SSHPublicKey"] !== undefined) {
        contents.SSHPublicKey = de_SSHPublicKey(output["SSHPublicKey"], context);
    }
    return contents;
};
const de_GetUserPolicyResponse = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = (0, smithy_client_1.expectString)(output["PolicyName"]);
    }
    if (output["PolicyDocument"] !== undefined) {
        contents.PolicyDocument = (0, smithy_client_1.expectString)(output["PolicyDocument"]);
    }
    return contents;
};
const de_GetUserResponse = (output, context) => {
    const contents = {};
    if (output["User"] !== undefined) {
        contents.User = de_User(output["User"], context);
    }
    return contents;
};
const de_Group = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["GroupName"] !== undefined) {
        contents.GroupName = (0, smithy_client_1.expectString)(output["GroupName"]);
    }
    if (output["GroupId"] !== undefined) {
        contents.GroupId = (0, smithy_client_1.expectString)(output["GroupId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    return contents;
};
const de_GroupDetail = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["GroupName"] !== undefined) {
        contents.GroupName = (0, smithy_client_1.expectString)(output["GroupName"]);
    }
    if (output["GroupId"] !== undefined) {
        contents.GroupId = (0, smithy_client_1.expectString)(output["GroupId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output.GroupPolicyList === "") {
        contents.GroupPolicyList = [];
    }
    else if (output["GroupPolicyList"] !== undefined && output["GroupPolicyList"]["member"] !== undefined) {
        contents.GroupPolicyList = de_policyDetailListType((0, smithy_client_1.getArrayIfSingleItem)(output["GroupPolicyList"]["member"]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents.AttachedManagedPolicies = [];
    }
    else if (output["AttachedManagedPolicies"] !== undefined &&
        output["AttachedManagedPolicies"]["member"] !== undefined) {
        contents.AttachedManagedPolicies = de_attachedPoliciesListType((0, smithy_client_1.getArrayIfSingleItem)(output["AttachedManagedPolicies"]["member"]), context);
    }
    return contents;
};
const de_groupDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GroupDetail(entry, context);
    });
};
const de_groupListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Group(entry, context);
    });
};
const de_groupNameListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_InstanceProfile = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["InstanceProfileName"] !== undefined) {
        contents.InstanceProfileName = (0, smithy_client_1.expectString)(output["InstanceProfileName"]);
    }
    if (output["InstanceProfileId"] !== undefined) {
        contents.InstanceProfileId = (0, smithy_client_1.expectString)(output["InstanceProfileId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output.Roles === "") {
        contents.Roles = [];
    }
    else if (output["Roles"] !== undefined && output["Roles"]["member"] !== undefined) {
        contents.Roles = de_roleListType((0, smithy_client_1.getArrayIfSingleItem)(output["Roles"]["member"]), context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_instanceProfileListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceProfile(entry, context);
    });
};
const de_InvalidAuthenticationCodeException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_InvalidCertificateException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_InvalidInputException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_InvalidPublicKeyException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_InvalidUserTypeException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_KeyPairMismatchException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_LimitExceededException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_ListAccessKeysResponse = (output, context) => {
    const contents = {};
    if (output.AccessKeyMetadata === "") {
        contents.AccessKeyMetadata = [];
    }
    else if (output["AccessKeyMetadata"] !== undefined && output["AccessKeyMetadata"]["member"] !== undefined) {
        contents.AccessKeyMetadata = de_accessKeyMetadataListType((0, smithy_client_1.getArrayIfSingleItem)(output["AccessKeyMetadata"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListAccountAliasesResponse = (output, context) => {
    const contents = {};
    if (output.AccountAliases === "") {
        contents.AccountAliases = [];
    }
    else if (output["AccountAliases"] !== undefined && output["AccountAliases"]["member"] !== undefined) {
        contents.AccountAliases = de_accountAliasListType((0, smithy_client_1.getArrayIfSingleItem)(output["AccountAliases"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListAttachedGroupPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents.AttachedPolicies = [];
    }
    else if (output["AttachedPolicies"] !== undefined && output["AttachedPolicies"]["member"] !== undefined) {
        contents.AttachedPolicies = de_attachedPoliciesListType((0, smithy_client_1.getArrayIfSingleItem)(output["AttachedPolicies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListAttachedRolePoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents.AttachedPolicies = [];
    }
    else if (output["AttachedPolicies"] !== undefined && output["AttachedPolicies"]["member"] !== undefined) {
        contents.AttachedPolicies = de_attachedPoliciesListType((0, smithy_client_1.getArrayIfSingleItem)(output["AttachedPolicies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListAttachedUserPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents.AttachedPolicies = [];
    }
    else if (output["AttachedPolicies"] !== undefined && output["AttachedPolicies"]["member"] !== undefined) {
        contents.AttachedPolicies = de_attachedPoliciesListType((0, smithy_client_1.getArrayIfSingleItem)(output["AttachedPolicies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListEntitiesForPolicyResponse = (output, context) => {
    const contents = {};
    if (output.PolicyGroups === "") {
        contents.PolicyGroups = [];
    }
    else if (output["PolicyGroups"] !== undefined && output["PolicyGroups"]["member"] !== undefined) {
        contents.PolicyGroups = de_PolicyGroupListType((0, smithy_client_1.getArrayIfSingleItem)(output["PolicyGroups"]["member"]), context);
    }
    if (output.PolicyUsers === "") {
        contents.PolicyUsers = [];
    }
    else if (output["PolicyUsers"] !== undefined && output["PolicyUsers"]["member"] !== undefined) {
        contents.PolicyUsers = de_PolicyUserListType((0, smithy_client_1.getArrayIfSingleItem)(output["PolicyUsers"]["member"]), context);
    }
    if (output.PolicyRoles === "") {
        contents.PolicyRoles = [];
    }
    else if (output["PolicyRoles"] !== undefined && output["PolicyRoles"]["member"] !== undefined) {
        contents.PolicyRoles = de_PolicyRoleListType((0, smithy_client_1.getArrayIfSingleItem)(output["PolicyRoles"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListGroupPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents.PolicyNames = [];
    }
    else if (output["PolicyNames"] !== undefined && output["PolicyNames"]["member"] !== undefined) {
        contents.PolicyNames = de_policyNameListType((0, smithy_client_1.getArrayIfSingleItem)(output["PolicyNames"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListGroupsForUserResponse = (output, context) => {
    const contents = {};
    if (output.Groups === "") {
        contents.Groups = [];
    }
    else if (output["Groups"] !== undefined && output["Groups"]["member"] !== undefined) {
        contents.Groups = de_groupListType((0, smithy_client_1.getArrayIfSingleItem)(output["Groups"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListGroupsResponse = (output, context) => {
    const contents = {};
    if (output.Groups === "") {
        contents.Groups = [];
    }
    else if (output["Groups"] !== undefined && output["Groups"]["member"] !== undefined) {
        contents.Groups = de_groupListType((0, smithy_client_1.getArrayIfSingleItem)(output["Groups"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListInstanceProfilesForRoleResponse = (output, context) => {
    const contents = {};
    if (output.InstanceProfiles === "") {
        contents.InstanceProfiles = [];
    }
    else if (output["InstanceProfiles"] !== undefined && output["InstanceProfiles"]["member"] !== undefined) {
        contents.InstanceProfiles = de_instanceProfileListType((0, smithy_client_1.getArrayIfSingleItem)(output["InstanceProfiles"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListInstanceProfilesResponse = (output, context) => {
    const contents = {};
    if (output.InstanceProfiles === "") {
        contents.InstanceProfiles = [];
    }
    else if (output["InstanceProfiles"] !== undefined && output["InstanceProfiles"]["member"] !== undefined) {
        contents.InstanceProfiles = de_instanceProfileListType((0, smithy_client_1.getArrayIfSingleItem)(output["InstanceProfiles"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListInstanceProfileTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListMFADevicesResponse = (output, context) => {
    const contents = {};
    if (output.MFADevices === "") {
        contents.MFADevices = [];
    }
    else if (output["MFADevices"] !== undefined && output["MFADevices"]["member"] !== undefined) {
        contents.MFADevices = de_mfaDeviceListType((0, smithy_client_1.getArrayIfSingleItem)(output["MFADevices"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListMFADeviceTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListOpenIDConnectProvidersResponse = (output, context) => {
    const contents = {};
    if (output.OpenIDConnectProviderList === "") {
        contents.OpenIDConnectProviderList = [];
    }
    else if (output["OpenIDConnectProviderList"] !== undefined &&
        output["OpenIDConnectProviderList"]["member"] !== undefined) {
        contents.OpenIDConnectProviderList = de_OpenIDConnectProviderListType((0, smithy_client_1.getArrayIfSingleItem)(output["OpenIDConnectProviderList"]["member"]), context);
    }
    return contents;
};
const de_ListOpenIDConnectProviderTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListPoliciesGrantingServiceAccessEntry = (output, context) => {
    const contents = {};
    if (output["ServiceNamespace"] !== undefined) {
        contents.ServiceNamespace = (0, smithy_client_1.expectString)(output["ServiceNamespace"]);
    }
    if (output.Policies === "") {
        contents.Policies = [];
    }
    else if (output["Policies"] !== undefined && output["Policies"]["member"] !== undefined) {
        contents.Policies = de_policyGrantingServiceAccessListType((0, smithy_client_1.getArrayIfSingleItem)(output["Policies"]["member"]), context);
    }
    return contents;
};
const de_ListPoliciesGrantingServiceAccessResponse = (output, context) => {
    const contents = {};
    if (output.PoliciesGrantingServiceAccess === "") {
        contents.PoliciesGrantingServiceAccess = [];
    }
    else if (output["PoliciesGrantingServiceAccess"] !== undefined &&
        output["PoliciesGrantingServiceAccess"]["member"] !== undefined) {
        contents.PoliciesGrantingServiceAccess = de_listPolicyGrantingServiceAccessResponseListType((0, smithy_client_1.getArrayIfSingleItem)(output["PoliciesGrantingServiceAccess"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.Policies === "") {
        contents.Policies = [];
    }
    else if (output["Policies"] !== undefined && output["Policies"]["member"] !== undefined) {
        contents.Policies = de_policyListType((0, smithy_client_1.getArrayIfSingleItem)(output["Policies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_listPolicyGrantingServiceAccessResponseListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListPoliciesGrantingServiceAccessEntry(entry, context);
    });
};
const de_ListPolicyTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListPolicyVersionsResponse = (output, context) => {
    const contents = {};
    if (output.Versions === "") {
        contents.Versions = [];
    }
    else if (output["Versions"] !== undefined && output["Versions"]["member"] !== undefined) {
        contents.Versions = de_policyDocumentVersionListType((0, smithy_client_1.getArrayIfSingleItem)(output["Versions"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListRolePoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents.PolicyNames = [];
    }
    else if (output["PolicyNames"] !== undefined && output["PolicyNames"]["member"] !== undefined) {
        contents.PolicyNames = de_policyNameListType((0, smithy_client_1.getArrayIfSingleItem)(output["PolicyNames"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListRolesResponse = (output, context) => {
    const contents = {};
    if (output.Roles === "") {
        contents.Roles = [];
    }
    else if (output["Roles"] !== undefined && output["Roles"]["member"] !== undefined) {
        contents.Roles = de_roleListType((0, smithy_client_1.getArrayIfSingleItem)(output["Roles"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListRoleTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListSAMLProvidersResponse = (output, context) => {
    const contents = {};
    if (output.SAMLProviderList === "") {
        contents.SAMLProviderList = [];
    }
    else if (output["SAMLProviderList"] !== undefined && output["SAMLProviderList"]["member"] !== undefined) {
        contents.SAMLProviderList = de_SAMLProviderListType((0, smithy_client_1.getArrayIfSingleItem)(output["SAMLProviderList"]["member"]), context);
    }
    return contents;
};
const de_ListSAMLProviderTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListServerCertificatesResponse = (output, context) => {
    const contents = {};
    if (output.ServerCertificateMetadataList === "") {
        contents.ServerCertificateMetadataList = [];
    }
    else if (output["ServerCertificateMetadataList"] !== undefined &&
        output["ServerCertificateMetadataList"]["member"] !== undefined) {
        contents.ServerCertificateMetadataList = de_serverCertificateMetadataListType((0, smithy_client_1.getArrayIfSingleItem)(output["ServerCertificateMetadataList"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListServerCertificateTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListServiceSpecificCredentialsResponse = (output, context) => {
    const contents = {};
    if (output.ServiceSpecificCredentials === "") {
        contents.ServiceSpecificCredentials = [];
    }
    else if (output["ServiceSpecificCredentials"] !== undefined &&
        output["ServiceSpecificCredentials"]["member"] !== undefined) {
        contents.ServiceSpecificCredentials = de_ServiceSpecificCredentialsListType((0, smithy_client_1.getArrayIfSingleItem)(output["ServiceSpecificCredentials"]["member"]), context);
    }
    return contents;
};
const de_ListSigningCertificatesResponse = (output, context) => {
    const contents = {};
    if (output.Certificates === "") {
        contents.Certificates = [];
    }
    else if (output["Certificates"] !== undefined && output["Certificates"]["member"] !== undefined) {
        contents.Certificates = de_certificateListType((0, smithy_client_1.getArrayIfSingleItem)(output["Certificates"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListSSHPublicKeysResponse = (output, context) => {
    const contents = {};
    if (output.SSHPublicKeys === "") {
        contents.SSHPublicKeys = [];
    }
    else if (output["SSHPublicKeys"] !== undefined && output["SSHPublicKeys"]["member"] !== undefined) {
        contents.SSHPublicKeys = de_SSHPublicKeyListType((0, smithy_client_1.getArrayIfSingleItem)(output["SSHPublicKeys"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListUserPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents.PolicyNames = [];
    }
    else if (output["PolicyNames"] !== undefined && output["PolicyNames"]["member"] !== undefined) {
        contents.PolicyNames = de_policyNameListType((0, smithy_client_1.getArrayIfSingleItem)(output["PolicyNames"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListUsersResponse = (output, context) => {
    const contents = {};
    if (output.Users === "") {
        contents.Users = [];
    }
    else if (output["Users"] !== undefined && output["Users"]["member"] !== undefined) {
        contents.Users = de_userListType((0, smithy_client_1.getArrayIfSingleItem)(output["Users"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListUserTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_ListVirtualMFADevicesResponse = (output, context) => {
    const contents = {};
    if (output.VirtualMFADevices === "") {
        contents.VirtualMFADevices = [];
    }
    else if (output["VirtualMFADevices"] !== undefined && output["VirtualMFADevices"]["member"] !== undefined) {
        contents.VirtualMFADevices = de_virtualMFADeviceListType((0, smithy_client_1.getArrayIfSingleItem)(output["VirtualMFADevices"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_LoginProfile = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["PasswordResetRequired"] !== undefined) {
        contents.PasswordResetRequired = (0, smithy_client_1.parseBoolean)(output["PasswordResetRequired"]);
    }
    return contents;
};
const de_MalformedCertificateException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_MalformedPolicyDocumentException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_ManagedPolicyDetail = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = (0, smithy_client_1.expectString)(output["PolicyName"]);
    }
    if (output["PolicyId"] !== undefined) {
        contents.PolicyId = (0, smithy_client_1.expectString)(output["PolicyId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["DefaultVersionId"] !== undefined) {
        contents.DefaultVersionId = (0, smithy_client_1.expectString)(output["DefaultVersionId"]);
    }
    if (output["AttachmentCount"] !== undefined) {
        contents.AttachmentCount = (0, smithy_client_1.strictParseInt32)(output["AttachmentCount"]);
    }
    if (output["PermissionsBoundaryUsageCount"] !== undefined) {
        contents.PermissionsBoundaryUsageCount = (0, smithy_client_1.strictParseInt32)(output["PermissionsBoundaryUsageCount"]);
    }
    if (output["IsAttachable"] !== undefined) {
        contents.IsAttachable = (0, smithy_client_1.parseBoolean)(output["IsAttachable"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = (0, smithy_client_1.expectString)(output["Description"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["UpdateDate"] !== undefined) {
        contents.UpdateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["UpdateDate"]));
    }
    if (output.PolicyVersionList === "") {
        contents.PolicyVersionList = [];
    }
    else if (output["PolicyVersionList"] !== undefined && output["PolicyVersionList"]["member"] !== undefined) {
        contents.PolicyVersionList = de_policyDocumentVersionListType((0, smithy_client_1.getArrayIfSingleItem)(output["PolicyVersionList"]["member"]), context);
    }
    return contents;
};
const de_ManagedPolicyDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ManagedPolicyDetail(entry, context);
    });
};
const de_MFADevice = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["SerialNumber"] !== undefined) {
        contents.SerialNumber = (0, smithy_client_1.expectString)(output["SerialNumber"]);
    }
    if (output["EnableDate"] !== undefined) {
        contents.EnableDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["EnableDate"]));
    }
    return contents;
};
const de_mfaDeviceListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MFADevice(entry, context);
    });
};
const de_NoSuchEntityException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_OpenIDConnectProviderListEntry = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const de_OpenIDConnectProviderListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OpenIDConnectProviderListEntry(entry, context);
    });
};
const de_OrganizationsDecisionDetail = (output, context) => {
    const contents = {};
    if (output["AllowedByOrganizations"] !== undefined) {
        contents.AllowedByOrganizations = (0, smithy_client_1.parseBoolean)(output["AllowedByOrganizations"]);
    }
    return contents;
};
const de_PasswordPolicy = (output, context) => {
    const contents = {};
    if (output["MinimumPasswordLength"] !== undefined) {
        contents.MinimumPasswordLength = (0, smithy_client_1.strictParseInt32)(output["MinimumPasswordLength"]);
    }
    if (output["RequireSymbols"] !== undefined) {
        contents.RequireSymbols = (0, smithy_client_1.parseBoolean)(output["RequireSymbols"]);
    }
    if (output["RequireNumbers"] !== undefined) {
        contents.RequireNumbers = (0, smithy_client_1.parseBoolean)(output["RequireNumbers"]);
    }
    if (output["RequireUppercaseCharacters"] !== undefined) {
        contents.RequireUppercaseCharacters = (0, smithy_client_1.parseBoolean)(output["RequireUppercaseCharacters"]);
    }
    if (output["RequireLowercaseCharacters"] !== undefined) {
        contents.RequireLowercaseCharacters = (0, smithy_client_1.parseBoolean)(output["RequireLowercaseCharacters"]);
    }
    if (output["AllowUsersToChangePassword"] !== undefined) {
        contents.AllowUsersToChangePassword = (0, smithy_client_1.parseBoolean)(output["AllowUsersToChangePassword"]);
    }
    if (output["ExpirePasswords"] !== undefined) {
        contents.ExpirePasswords = (0, smithy_client_1.parseBoolean)(output["ExpirePasswords"]);
    }
    if (output["MaxPasswordAge"] !== undefined) {
        contents.MaxPasswordAge = (0, smithy_client_1.strictParseInt32)(output["MaxPasswordAge"]);
    }
    if (output["PasswordReusePrevention"] !== undefined) {
        contents.PasswordReusePrevention = (0, smithy_client_1.strictParseInt32)(output["PasswordReusePrevention"]);
    }
    if (output["HardExpiry"] !== undefined) {
        contents.HardExpiry = (0, smithy_client_1.parseBoolean)(output["HardExpiry"]);
    }
    return contents;
};
const de_PasswordPolicyViolationException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_PermissionsBoundaryDecisionDetail = (output, context) => {
    const contents = {};
    if (output["AllowedByPermissionsBoundary"] !== undefined) {
        contents.AllowedByPermissionsBoundary = (0, smithy_client_1.parseBoolean)(output["AllowedByPermissionsBoundary"]);
    }
    return contents;
};
const de_Policy = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = (0, smithy_client_1.expectString)(output["PolicyName"]);
    }
    if (output["PolicyId"] !== undefined) {
        contents.PolicyId = (0, smithy_client_1.expectString)(output["PolicyId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["DefaultVersionId"] !== undefined) {
        contents.DefaultVersionId = (0, smithy_client_1.expectString)(output["DefaultVersionId"]);
    }
    if (output["AttachmentCount"] !== undefined) {
        contents.AttachmentCount = (0, smithy_client_1.strictParseInt32)(output["AttachmentCount"]);
    }
    if (output["PermissionsBoundaryUsageCount"] !== undefined) {
        contents.PermissionsBoundaryUsageCount = (0, smithy_client_1.strictParseInt32)(output["PermissionsBoundaryUsageCount"]);
    }
    if (output["IsAttachable"] !== undefined) {
        contents.IsAttachable = (0, smithy_client_1.parseBoolean)(output["IsAttachable"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = (0, smithy_client_1.expectString)(output["Description"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["UpdateDate"] !== undefined) {
        contents.UpdateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["UpdateDate"]));
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_PolicyDetail = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = (0, smithy_client_1.expectString)(output["PolicyName"]);
    }
    if (output["PolicyDocument"] !== undefined) {
        contents.PolicyDocument = (0, smithy_client_1.expectString)(output["PolicyDocument"]);
    }
    return contents;
};
const de_policyDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyDetail(entry, context);
    });
};
const de_policyDocumentVersionListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyVersion(entry, context);
    });
};
const de_PolicyEvaluationException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_PolicyGrantingServiceAccess = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = (0, smithy_client_1.expectString)(output["PolicyName"]);
    }
    if (output["PolicyType"] !== undefined) {
        contents.PolicyType = (0, smithy_client_1.expectString)(output["PolicyType"]);
    }
    if (output["PolicyArn"] !== undefined) {
        contents.PolicyArn = (0, smithy_client_1.expectString)(output["PolicyArn"]);
    }
    if (output["EntityType"] !== undefined) {
        contents.EntityType = (0, smithy_client_1.expectString)(output["EntityType"]);
    }
    if (output["EntityName"] !== undefined) {
        contents.EntityName = (0, smithy_client_1.expectString)(output["EntityName"]);
    }
    return contents;
};
const de_policyGrantingServiceAccessListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyGrantingServiceAccess(entry, context);
    });
};
const de_PolicyGroup = (output, context) => {
    const contents = {};
    if (output["GroupName"] !== undefined) {
        contents.GroupName = (0, smithy_client_1.expectString)(output["GroupName"]);
    }
    if (output["GroupId"] !== undefined) {
        contents.GroupId = (0, smithy_client_1.expectString)(output["GroupId"]);
    }
    return contents;
};
const de_PolicyGroupListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyGroup(entry, context);
    });
};
const de_policyListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Policy(entry, context);
    });
};
const de_policyNameListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_PolicyNotAttachableException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_PolicyRole = (output, context) => {
    const contents = {};
    if (output["RoleName"] !== undefined) {
        contents.RoleName = (0, smithy_client_1.expectString)(output["RoleName"]);
    }
    if (output["RoleId"] !== undefined) {
        contents.RoleId = (0, smithy_client_1.expectString)(output["RoleId"]);
    }
    return contents;
};
const de_PolicyRoleListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyRole(entry, context);
    });
};
const de_PolicyUser = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["UserId"] !== undefined) {
        contents.UserId = (0, smithy_client_1.expectString)(output["UserId"]);
    }
    return contents;
};
const de_PolicyUserListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyUser(entry, context);
    });
};
const de_PolicyVersion = (output, context) => {
    const contents = {};
    if (output["Document"] !== undefined) {
        contents.Document = (0, smithy_client_1.expectString)(output["Document"]);
    }
    if (output["VersionId"] !== undefined) {
        contents.VersionId = (0, smithy_client_1.expectString)(output["VersionId"]);
    }
    if (output["IsDefaultVersion"] !== undefined) {
        contents.IsDefaultVersion = (0, smithy_client_1.parseBoolean)(output["IsDefaultVersion"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    return contents;
};
const de_Position = (output, context) => {
    const contents = {};
    if (output["Line"] !== undefined) {
        contents.Line = (0, smithy_client_1.strictParseInt32)(output["Line"]);
    }
    if (output["Column"] !== undefined) {
        contents.Column = (0, smithy_client_1.strictParseInt32)(output["Column"]);
    }
    return contents;
};
const de_ReportGenerationLimitExceededException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_ResetServiceSpecificCredentialResponse = (output, context) => {
    const contents = {};
    if (output["ServiceSpecificCredential"] !== undefined) {
        contents.ServiceSpecificCredential = de_ServiceSpecificCredential(output["ServiceSpecificCredential"], context);
    }
    return contents;
};
const de_ResourceSpecificResult = (output, context) => {
    const contents = {};
    if (output["EvalResourceName"] !== undefined) {
        contents.EvalResourceName = (0, smithy_client_1.expectString)(output["EvalResourceName"]);
    }
    if (output["EvalResourceDecision"] !== undefined) {
        contents.EvalResourceDecision = (0, smithy_client_1.expectString)(output["EvalResourceDecision"]);
    }
    if (output.MatchedStatements === "") {
        contents.MatchedStatements = [];
    }
    else if (output["MatchedStatements"] !== undefined && output["MatchedStatements"]["member"] !== undefined) {
        contents.MatchedStatements = de_StatementListType((0, smithy_client_1.getArrayIfSingleItem)(output["MatchedStatements"]["member"]), context);
    }
    if (output.MissingContextValues === "") {
        contents.MissingContextValues = [];
    }
    else if (output["MissingContextValues"] !== undefined && output["MissingContextValues"]["member"] !== undefined) {
        contents.MissingContextValues = de_ContextKeyNamesResultListType((0, smithy_client_1.getArrayIfSingleItem)(output["MissingContextValues"]["member"]), context);
    }
    if (output.EvalDecisionDetails === "") {
        contents.EvalDecisionDetails = {};
    }
    else if (output["EvalDecisionDetails"] !== undefined && output["EvalDecisionDetails"]["entry"] !== undefined) {
        contents.EvalDecisionDetails = de_EvalDecisionDetailsType((0, smithy_client_1.getArrayIfSingleItem)(output["EvalDecisionDetails"]["entry"]), context);
    }
    if (output["PermissionsBoundaryDecisionDetail"] !== undefined) {
        contents.PermissionsBoundaryDecisionDetail = de_PermissionsBoundaryDecisionDetail(output["PermissionsBoundaryDecisionDetail"], context);
    }
    return contents;
};
const de_ResourceSpecificResultListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourceSpecificResult(entry, context);
    });
};
const de_Role = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["RoleName"] !== undefined) {
        contents.RoleName = (0, smithy_client_1.expectString)(output["RoleName"]);
    }
    if (output["RoleId"] !== undefined) {
        contents.RoleId = (0, smithy_client_1.expectString)(output["RoleId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["AssumeRolePolicyDocument"] !== undefined) {
        contents.AssumeRolePolicyDocument = (0, smithy_client_1.expectString)(output["AssumeRolePolicyDocument"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = (0, smithy_client_1.expectString)(output["Description"]);
    }
    if (output["MaxSessionDuration"] !== undefined) {
        contents.MaxSessionDuration = (0, smithy_client_1.strictParseInt32)(output["MaxSessionDuration"]);
    }
    if (output["PermissionsBoundary"] !== undefined) {
        contents.PermissionsBoundary = de_AttachedPermissionsBoundary(output["PermissionsBoundary"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["RoleLastUsed"] !== undefined) {
        contents.RoleLastUsed = de_RoleLastUsed(output["RoleLastUsed"], context);
    }
    return contents;
};
const de_RoleDetail = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["RoleName"] !== undefined) {
        contents.RoleName = (0, smithy_client_1.expectString)(output["RoleName"]);
    }
    if (output["RoleId"] !== undefined) {
        contents.RoleId = (0, smithy_client_1.expectString)(output["RoleId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["AssumeRolePolicyDocument"] !== undefined) {
        contents.AssumeRolePolicyDocument = (0, smithy_client_1.expectString)(output["AssumeRolePolicyDocument"]);
    }
    if (output.InstanceProfileList === "") {
        contents.InstanceProfileList = [];
    }
    else if (output["InstanceProfileList"] !== undefined && output["InstanceProfileList"]["member"] !== undefined) {
        contents.InstanceProfileList = de_instanceProfileListType((0, smithy_client_1.getArrayIfSingleItem)(output["InstanceProfileList"]["member"]), context);
    }
    if (output.RolePolicyList === "") {
        contents.RolePolicyList = [];
    }
    else if (output["RolePolicyList"] !== undefined && output["RolePolicyList"]["member"] !== undefined) {
        contents.RolePolicyList = de_policyDetailListType((0, smithy_client_1.getArrayIfSingleItem)(output["RolePolicyList"]["member"]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents.AttachedManagedPolicies = [];
    }
    else if (output["AttachedManagedPolicies"] !== undefined &&
        output["AttachedManagedPolicies"]["member"] !== undefined) {
        contents.AttachedManagedPolicies = de_attachedPoliciesListType((0, smithy_client_1.getArrayIfSingleItem)(output["AttachedManagedPolicies"]["member"]), context);
    }
    if (output["PermissionsBoundary"] !== undefined) {
        contents.PermissionsBoundary = de_AttachedPermissionsBoundary(output["PermissionsBoundary"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    if (output["RoleLastUsed"] !== undefined) {
        contents.RoleLastUsed = de_RoleLastUsed(output["RoleLastUsed"], context);
    }
    return contents;
};
const de_roleDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoleDetail(entry, context);
    });
};
const de_RoleLastUsed = (output, context) => {
    const contents = {};
    if (output["LastUsedDate"] !== undefined) {
        contents.LastUsedDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastUsedDate"]));
    }
    if (output["Region"] !== undefined) {
        contents.Region = (0, smithy_client_1.expectString)(output["Region"]);
    }
    return contents;
};
const de_roleListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Role(entry, context);
    });
};
const de_RoleUsageListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoleUsageType(entry, context);
    });
};
const de_RoleUsageType = (output, context) => {
    const contents = {};
    if (output["Region"] !== undefined) {
        contents.Region = (0, smithy_client_1.expectString)(output["Region"]);
    }
    if (output.Resources === "") {
        contents.Resources = [];
    }
    else if (output["Resources"] !== undefined && output["Resources"]["member"] !== undefined) {
        contents.Resources = de_ArnListType((0, smithy_client_1.getArrayIfSingleItem)(output["Resources"]["member"]), context);
    }
    return contents;
};
const de_SAMLProviderListEntry = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["ValidUntil"] !== undefined) {
        contents.ValidUntil = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["ValidUntil"]));
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    return contents;
};
const de_SAMLProviderListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SAMLProviderListEntry(entry, context);
    });
};
const de_ServerCertificate = (output, context) => {
    const contents = {};
    if (output["ServerCertificateMetadata"] !== undefined) {
        contents.ServerCertificateMetadata = de_ServerCertificateMetadata(output["ServerCertificateMetadata"], context);
    }
    if (output["CertificateBody"] !== undefined) {
        contents.CertificateBody = (0, smithy_client_1.expectString)(output["CertificateBody"]);
    }
    if (output["CertificateChain"] !== undefined) {
        contents.CertificateChain = (0, smithy_client_1.expectString)(output["CertificateChain"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_ServerCertificateMetadata = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["ServerCertificateName"] !== undefined) {
        contents.ServerCertificateName = (0, smithy_client_1.expectString)(output["ServerCertificateName"]);
    }
    if (output["ServerCertificateId"] !== undefined) {
        contents.ServerCertificateId = (0, smithy_client_1.expectString)(output["ServerCertificateId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["UploadDate"] !== undefined) {
        contents.UploadDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["UploadDate"]));
    }
    if (output["Expiration"] !== undefined) {
        contents.Expiration = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["Expiration"]));
    }
    return contents;
};
const de_serverCertificateMetadataListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServerCertificateMetadata(entry, context);
    });
};
const de_ServiceFailureException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_ServiceLastAccessed = (output, context) => {
    const contents = {};
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = (0, smithy_client_1.expectString)(output["ServiceName"]);
    }
    if (output["LastAuthenticated"] !== undefined) {
        contents.LastAuthenticated = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastAuthenticated"]));
    }
    if (output["ServiceNamespace"] !== undefined) {
        contents.ServiceNamespace = (0, smithy_client_1.expectString)(output["ServiceNamespace"]);
    }
    if (output["LastAuthenticatedEntity"] !== undefined) {
        contents.LastAuthenticatedEntity = (0, smithy_client_1.expectString)(output["LastAuthenticatedEntity"]);
    }
    if (output["LastAuthenticatedRegion"] !== undefined) {
        contents.LastAuthenticatedRegion = (0, smithy_client_1.expectString)(output["LastAuthenticatedRegion"]);
    }
    if (output["TotalAuthenticatedEntities"] !== undefined) {
        contents.TotalAuthenticatedEntities = (0, smithy_client_1.strictParseInt32)(output["TotalAuthenticatedEntities"]);
    }
    if (output.TrackedActionsLastAccessed === "") {
        contents.TrackedActionsLastAccessed = [];
    }
    else if (output["TrackedActionsLastAccessed"] !== undefined &&
        output["TrackedActionsLastAccessed"]["member"] !== undefined) {
        contents.TrackedActionsLastAccessed = de_TrackedActionsLastAccessed((0, smithy_client_1.getArrayIfSingleItem)(output["TrackedActionsLastAccessed"]["member"]), context);
    }
    return contents;
};
const de_ServiceNotSupportedException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_ServicesLastAccessed = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceLastAccessed(entry, context);
    });
};
const de_ServiceSpecificCredential = (output, context) => {
    const contents = {};
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = (0, smithy_client_1.expectString)(output["ServiceName"]);
    }
    if (output["ServiceUserName"] !== undefined) {
        contents.ServiceUserName = (0, smithy_client_1.expectString)(output["ServiceUserName"]);
    }
    if (output["ServicePassword"] !== undefined) {
        contents.ServicePassword = (0, smithy_client_1.expectString)(output["ServicePassword"]);
    }
    if (output["ServiceSpecificCredentialId"] !== undefined) {
        contents.ServiceSpecificCredentialId = (0, smithy_client_1.expectString)(output["ServiceSpecificCredentialId"]);
    }
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    return contents;
};
const de_ServiceSpecificCredentialMetadata = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["ServiceUserName"] !== undefined) {
        contents.ServiceUserName = (0, smithy_client_1.expectString)(output["ServiceUserName"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["ServiceSpecificCredentialId"] !== undefined) {
        contents.ServiceSpecificCredentialId = (0, smithy_client_1.expectString)(output["ServiceSpecificCredentialId"]);
    }
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = (0, smithy_client_1.expectString)(output["ServiceName"]);
    }
    return contents;
};
const de_ServiceSpecificCredentialsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceSpecificCredentialMetadata(entry, context);
    });
};
const de_SigningCertificate = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["CertificateId"] !== undefined) {
        contents.CertificateId = (0, smithy_client_1.expectString)(output["CertificateId"]);
    }
    if (output["CertificateBody"] !== undefined) {
        contents.CertificateBody = (0, smithy_client_1.expectString)(output["CertificateBody"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["UploadDate"] !== undefined) {
        contents.UploadDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["UploadDate"]));
    }
    return contents;
};
const de_SimulatePolicyResponse = (output, context) => {
    const contents = {};
    if (output.EvaluationResults === "") {
        contents.EvaluationResults = [];
    }
    else if (output["EvaluationResults"] !== undefined && output["EvaluationResults"]["member"] !== undefined) {
        contents.EvaluationResults = de_EvaluationResultsListType((0, smithy_client_1.getArrayIfSingleItem)(output["EvaluationResults"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    return contents;
};
const de_SSHPublicKey = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["SSHPublicKeyId"] !== undefined) {
        contents.SSHPublicKeyId = (0, smithy_client_1.expectString)(output["SSHPublicKeyId"]);
    }
    if (output["Fingerprint"] !== undefined) {
        contents.Fingerprint = (0, smithy_client_1.expectString)(output["Fingerprint"]);
    }
    if (output["SSHPublicKeyBody"] !== undefined) {
        contents.SSHPublicKeyBody = (0, smithy_client_1.expectString)(output["SSHPublicKeyBody"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["UploadDate"] !== undefined) {
        contents.UploadDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["UploadDate"]));
    }
    return contents;
};
const de_SSHPublicKeyListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SSHPublicKeyMetadata(entry, context);
    });
};
const de_SSHPublicKeyMetadata = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["SSHPublicKeyId"] !== undefined) {
        contents.SSHPublicKeyId = (0, smithy_client_1.expectString)(output["SSHPublicKeyId"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["UploadDate"] !== undefined) {
        contents.UploadDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["UploadDate"]));
    }
    return contents;
};
const de_Statement = (output, context) => {
    const contents = {};
    if (output["SourcePolicyId"] !== undefined) {
        contents.SourcePolicyId = (0, smithy_client_1.expectString)(output["SourcePolicyId"]);
    }
    if (output["SourcePolicyType"] !== undefined) {
        contents.SourcePolicyType = (0, smithy_client_1.expectString)(output["SourcePolicyType"]);
    }
    if (output["StartPosition"] !== undefined) {
        contents.StartPosition = de_Position(output["StartPosition"], context);
    }
    if (output["EndPosition"] !== undefined) {
        contents.EndPosition = de_Position(output["EndPosition"], context);
    }
    return contents;
};
const de_StatementListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Statement(entry, context);
    });
};
const de_summaryMapType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = (0, smithy_client_1.strictParseInt32)(pair["value"]);
        return acc;
    }, {});
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
};
const de_tagListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_thumbprintListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_TrackedActionLastAccessed = (output, context) => {
    const contents = {};
    if (output["ActionName"] !== undefined) {
        contents.ActionName = (0, smithy_client_1.expectString)(output["ActionName"]);
    }
    if (output["LastAccessedEntity"] !== undefined) {
        contents.LastAccessedEntity = (0, smithy_client_1.expectString)(output["LastAccessedEntity"]);
    }
    if (output["LastAccessedTime"] !== undefined) {
        contents.LastAccessedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["LastAccessedTime"]));
    }
    if (output["LastAccessedRegion"] !== undefined) {
        contents.LastAccessedRegion = (0, smithy_client_1.expectString)(output["LastAccessedRegion"]);
    }
    return contents;
};
const de_TrackedActionsLastAccessed = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrackedActionLastAccessed(entry, context);
    });
};
const de_UnmodifiableEntityException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_UnrecognizedPublicKeyEncodingException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_UpdateRoleDescriptionResponse = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = de_Role(output["Role"], context);
    }
    return contents;
};
const de_UpdateRoleResponse = (output, context) => {
    const contents = {};
    return contents;
};
const de_UpdateSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output["SAMLProviderArn"] !== undefined) {
        contents.SAMLProviderArn = (0, smithy_client_1.expectString)(output["SAMLProviderArn"]);
    }
    return contents;
};
const de_UploadServerCertificateResponse = (output, context) => {
    const contents = {};
    if (output["ServerCertificateMetadata"] !== undefined) {
        contents.ServerCertificateMetadata = de_ServerCertificateMetadata(output["ServerCertificateMetadata"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_UploadSigningCertificateResponse = (output, context) => {
    const contents = {};
    if (output["Certificate"] !== undefined) {
        contents.Certificate = de_SigningCertificate(output["Certificate"], context);
    }
    return contents;
};
const de_UploadSSHPublicKeyResponse = (output, context) => {
    const contents = {};
    if (output["SSHPublicKey"] !== undefined) {
        contents.SSHPublicKey = de_SSHPublicKey(output["SSHPublicKey"], context);
    }
    return contents;
};
const de_User = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["UserId"] !== undefined) {
        contents.UserId = (0, smithy_client_1.expectString)(output["UserId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output["PasswordLastUsed"] !== undefined) {
        contents.PasswordLastUsed = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["PasswordLastUsed"]));
    }
    if (output["PermissionsBoundary"] !== undefined) {
        contents.PermissionsBoundary = de_AttachedPermissionsBoundary(output["PermissionsBoundary"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_UserDetail = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["UserName"] !== undefined) {
        contents.UserName = (0, smithy_client_1.expectString)(output["UserName"]);
    }
    if (output["UserId"] !== undefined) {
        contents.UserId = (0, smithy_client_1.expectString)(output["UserId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreateDate"]));
    }
    if (output.UserPolicyList === "") {
        contents.UserPolicyList = [];
    }
    else if (output["UserPolicyList"] !== undefined && output["UserPolicyList"]["member"] !== undefined) {
        contents.UserPolicyList = de_policyDetailListType((0, smithy_client_1.getArrayIfSingleItem)(output["UserPolicyList"]["member"]), context);
    }
    if (output.GroupList === "") {
        contents.GroupList = [];
    }
    else if (output["GroupList"] !== undefined && output["GroupList"]["member"] !== undefined) {
        contents.GroupList = de_groupNameListType((0, smithy_client_1.getArrayIfSingleItem)(output["GroupList"]["member"]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents.AttachedManagedPolicies = [];
    }
    else if (output["AttachedManagedPolicies"] !== undefined &&
        output["AttachedManagedPolicies"]["member"] !== undefined) {
        contents.AttachedManagedPolicies = de_attachedPoliciesListType((0, smithy_client_1.getArrayIfSingleItem)(output["AttachedManagedPolicies"]["member"]), context);
    }
    if (output["PermissionsBoundary"] !== undefined) {
        contents.PermissionsBoundary = de_AttachedPermissionsBoundary(output["PermissionsBoundary"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_userDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UserDetail(entry, context);
    });
};
const de_userListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_User(entry, context);
    });
};
const de_VirtualMFADevice = (output, context) => {
    const contents = {};
    if (output["SerialNumber"] !== undefined) {
        contents.SerialNumber = (0, smithy_client_1.expectString)(output["SerialNumber"]);
    }
    if (output["Base32StringSeed"] !== undefined) {
        contents.Base32StringSeed = context.base64Decoder(output["Base32StringSeed"]);
    }
    if (output["QRCodePNG"] !== undefined) {
        contents.QRCodePNG = context.base64Decoder(output["QRCodePNG"]);
    }
    if (output["User"] !== undefined) {
        contents.User = de_User(output["User"], context);
    }
    if (output["EnableDate"] !== undefined) {
        contents.EnableDate = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["EnableDate"]));
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_virtualMFADeviceListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VirtualMFADevice(entry, context);
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(IAMServiceException_1.IAMServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => (0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};


/***/ }),

/***/ 14294:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(94646));
const client_sts_1 = __nccwpck_require__(52209);
const credential_provider_node_1 = __nccwpck_require__(75531);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(40372);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 40372:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const endpointResolver_1 = __nccwpck_require__(21320);
const getRuntimeConfig = (config) => ({
    apiVersion: "2010-05-08",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "IAM",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
    utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 89467:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(7548), exports);
tslib_1.__exportStar(__nccwpck_require__(9269), exports);
tslib_1.__exportStar(__nccwpck_require__(55130), exports);
tslib_1.__exportStar(__nccwpck_require__(96793), exports);


/***/ }),

/***/ 7548:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilInstanceProfileExists = exports.waitForInstanceProfileExists = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const GetInstanceProfileCommand_1 = __nccwpck_require__(27715);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new GetInstanceProfileCommand_1.GetInstanceProfileCommand(input));
        reason = result;
        return { state: util_waiter_1.WaiterState.SUCCESS, reason };
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NoSuchEntityException") {
            return { state: util_waiter_1.WaiterState.RETRY, reason };
        }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForInstanceProfileExists = async (params, input) => {
    const serviceDefaults = { minDelay: 1, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForInstanceProfileExists = waitForInstanceProfileExists;
const waitUntilInstanceProfileExists = async (params, input) => {
    const serviceDefaults = { minDelay: 1, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilInstanceProfileExists = waitUntilInstanceProfileExists;


/***/ }),

/***/ 9269:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilPolicyExists = exports.waitForPolicyExists = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const GetPolicyCommand_1 = __nccwpck_require__(1415);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new GetPolicyCommand_1.GetPolicyCommand(input));
        reason = result;
        return { state: util_waiter_1.WaiterState.SUCCESS, reason };
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NoSuchEntity") {
            return { state: util_waiter_1.WaiterState.RETRY, reason };
        }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForPolicyExists = async (params, input) => {
    const serviceDefaults = { minDelay: 1, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForPolicyExists = waitForPolicyExists;
const waitUntilPolicyExists = async (params, input) => {
    const serviceDefaults = { minDelay: 1, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilPolicyExists = waitUntilPolicyExists;


/***/ }),

/***/ 55130:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilRoleExists = exports.waitForRoleExists = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const GetRoleCommand_1 = __nccwpck_require__(82426);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new GetRoleCommand_1.GetRoleCommand(input));
        reason = result;
        return { state: util_waiter_1.WaiterState.SUCCESS, reason };
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NoSuchEntity") {
            return { state: util_waiter_1.WaiterState.RETRY, reason };
        }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForRoleExists = async (params, input) => {
    const serviceDefaults = { minDelay: 1, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForRoleExists = waitForRoleExists;
const waitUntilRoleExists = async (params, input) => {
    const serviceDefaults = { minDelay: 1, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilRoleExists = waitUntilRoleExists;


/***/ }),

/***/ 96793:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilUserExists = exports.waitForUserExists = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const GetUserCommand_1 = __nccwpck_require__(79345);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new GetUserCommand_1.GetUserCommand(input));
        reason = result;
        return { state: util_waiter_1.WaiterState.SUCCESS, reason };
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NoSuchEntity") {
            return { state: util_waiter_1.WaiterState.RETRY, reason };
        }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForUserExists = async (params, input) => {
    const serviceDefaults = { minDelay: 1, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForUserExists = waitForUserExists;
const waitUntilUserExists = async (params, input) => {
    const serviceDefaults = { minDelay: 1, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilUserExists = waitUntilUserExists;


/***/ }),

/***/ 11042:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityHub = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const AcceptAdministratorInvitationCommand_1 = __nccwpck_require__(65085);
const AcceptInvitationCommand_1 = __nccwpck_require__(48019);
const BatchDeleteAutomationRulesCommand_1 = __nccwpck_require__(86404);
const BatchDisableStandardsCommand_1 = __nccwpck_require__(61492);
const BatchEnableStandardsCommand_1 = __nccwpck_require__(81303);
const BatchGetAutomationRulesCommand_1 = __nccwpck_require__(5675);
const BatchGetSecurityControlsCommand_1 = __nccwpck_require__(33597);
const BatchGetStandardsControlAssociationsCommand_1 = __nccwpck_require__(32039);
const BatchImportFindingsCommand_1 = __nccwpck_require__(2613);
const BatchUpdateAutomationRulesCommand_1 = __nccwpck_require__(62004);
const BatchUpdateFindingsCommand_1 = __nccwpck_require__(48719);
const BatchUpdateStandardsControlAssociationsCommand_1 = __nccwpck_require__(99982);
const CreateActionTargetCommand_1 = __nccwpck_require__(88570);
const CreateAutomationRuleCommand_1 = __nccwpck_require__(27959);
const CreateFindingAggregatorCommand_1 = __nccwpck_require__(75744);
const CreateInsightCommand_1 = __nccwpck_require__(53109);
const CreateMembersCommand_1 = __nccwpck_require__(2858);
const DeclineInvitationsCommand_1 = __nccwpck_require__(2879);
const DeleteActionTargetCommand_1 = __nccwpck_require__(7327);
const DeleteFindingAggregatorCommand_1 = __nccwpck_require__(79241);
const DeleteInsightCommand_1 = __nccwpck_require__(88117);
const DeleteInvitationsCommand_1 = __nccwpck_require__(50128);
const DeleteMembersCommand_1 = __nccwpck_require__(62425);
const DescribeActionTargetsCommand_1 = __nccwpck_require__(74901);
const DescribeHubCommand_1 = __nccwpck_require__(90516);
const DescribeOrganizationConfigurationCommand_1 = __nccwpck_require__(98161);
const DescribeProductsCommand_1 = __nccwpck_require__(16988);
const DescribeStandardsCommand_1 = __nccwpck_require__(53386);
const DescribeStandardsControlsCommand_1 = __nccwpck_require__(87275);
const DisableImportFindingsForProductCommand_1 = __nccwpck_require__(70261);
const DisableOrganizationAdminAccountCommand_1 = __nccwpck_require__(55725);
const DisableSecurityHubCommand_1 = __nccwpck_require__(90403);
const DisassociateFromAdministratorAccountCommand_1 = __nccwpck_require__(63507);
const DisassociateFromMasterAccountCommand_1 = __nccwpck_require__(33866);
const DisassociateMembersCommand_1 = __nccwpck_require__(36423);
const EnableImportFindingsForProductCommand_1 = __nccwpck_require__(51922);
const EnableOrganizationAdminAccountCommand_1 = __nccwpck_require__(81408);
const EnableSecurityHubCommand_1 = __nccwpck_require__(50663);
const GetAdministratorAccountCommand_1 = __nccwpck_require__(70688);
const GetEnabledStandardsCommand_1 = __nccwpck_require__(8096);
const GetFindingAggregatorCommand_1 = __nccwpck_require__(8156);
const GetFindingHistoryCommand_1 = __nccwpck_require__(19691);
const GetFindingsCommand_1 = __nccwpck_require__(1571);
const GetInsightResultsCommand_1 = __nccwpck_require__(17023);
const GetInsightsCommand_1 = __nccwpck_require__(52409);
const GetInvitationsCountCommand_1 = __nccwpck_require__(42931);
const GetMasterAccountCommand_1 = __nccwpck_require__(56989);
const GetMembersCommand_1 = __nccwpck_require__(78168);
const InviteMembersCommand_1 = __nccwpck_require__(77310);
const ListAutomationRulesCommand_1 = __nccwpck_require__(43336);
const ListEnabledProductsForImportCommand_1 = __nccwpck_require__(27425);
const ListFindingAggregatorsCommand_1 = __nccwpck_require__(52848);
const ListInvitationsCommand_1 = __nccwpck_require__(99276);
const ListMembersCommand_1 = __nccwpck_require__(1215);
const ListOrganizationAdminAccountsCommand_1 = __nccwpck_require__(39272);
const ListSecurityControlDefinitionsCommand_1 = __nccwpck_require__(43237);
const ListStandardsControlAssociationsCommand_1 = __nccwpck_require__(43470);
const ListTagsForResourceCommand_1 = __nccwpck_require__(8294);
const TagResourceCommand_1 = __nccwpck_require__(10694);
const UntagResourceCommand_1 = __nccwpck_require__(71455);
const UpdateActionTargetCommand_1 = __nccwpck_require__(66563);
const UpdateFindingAggregatorCommand_1 = __nccwpck_require__(61656);
const UpdateFindingsCommand_1 = __nccwpck_require__(89806);
const UpdateInsightCommand_1 = __nccwpck_require__(78709);
const UpdateOrganizationConfigurationCommand_1 = __nccwpck_require__(4199);
const UpdateSecurityHubConfigurationCommand_1 = __nccwpck_require__(51321);
const UpdateStandardsControlCommand_1 = __nccwpck_require__(6201);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const commands = {
    AcceptAdministratorInvitationCommand: AcceptAdministratorInvitationCommand_1.AcceptAdministratorInvitationCommand,
    AcceptInvitationCommand: AcceptInvitationCommand_1.AcceptInvitationCommand,
    BatchDeleteAutomationRulesCommand: BatchDeleteAutomationRulesCommand_1.BatchDeleteAutomationRulesCommand,
    BatchDisableStandardsCommand: BatchDisableStandardsCommand_1.BatchDisableStandardsCommand,
    BatchEnableStandardsCommand: BatchEnableStandardsCommand_1.BatchEnableStandardsCommand,
    BatchGetAutomationRulesCommand: BatchGetAutomationRulesCommand_1.BatchGetAutomationRulesCommand,
    BatchGetSecurityControlsCommand: BatchGetSecurityControlsCommand_1.BatchGetSecurityControlsCommand,
    BatchGetStandardsControlAssociationsCommand: BatchGetStandardsControlAssociationsCommand_1.BatchGetStandardsControlAssociationsCommand,
    BatchImportFindingsCommand: BatchImportFindingsCommand_1.BatchImportFindingsCommand,
    BatchUpdateAutomationRulesCommand: BatchUpdateAutomationRulesCommand_1.BatchUpdateAutomationRulesCommand,
    BatchUpdateFindingsCommand: BatchUpdateFindingsCommand_1.BatchUpdateFindingsCommand,
    BatchUpdateStandardsControlAssociationsCommand: BatchUpdateStandardsControlAssociationsCommand_1.BatchUpdateStandardsControlAssociationsCommand,
    CreateActionTargetCommand: CreateActionTargetCommand_1.CreateActionTargetCommand,
    CreateAutomationRuleCommand: CreateAutomationRuleCommand_1.CreateAutomationRuleCommand,
    CreateFindingAggregatorCommand: CreateFindingAggregatorCommand_1.CreateFindingAggregatorCommand,
    CreateInsightCommand: CreateInsightCommand_1.CreateInsightCommand,
    CreateMembersCommand: CreateMembersCommand_1.CreateMembersCommand,
    DeclineInvitationsCommand: DeclineInvitationsCommand_1.DeclineInvitationsCommand,
    DeleteActionTargetCommand: DeleteActionTargetCommand_1.DeleteActionTargetCommand,
    DeleteFindingAggregatorCommand: DeleteFindingAggregatorCommand_1.DeleteFindingAggregatorCommand,
    DeleteInsightCommand: DeleteInsightCommand_1.DeleteInsightCommand,
    DeleteInvitationsCommand: DeleteInvitationsCommand_1.DeleteInvitationsCommand,
    DeleteMembersCommand: DeleteMembersCommand_1.DeleteMembersCommand,
    DescribeActionTargetsCommand: DescribeActionTargetsCommand_1.DescribeActionTargetsCommand,
    DescribeHubCommand: DescribeHubCommand_1.DescribeHubCommand,
    DescribeOrganizationConfigurationCommand: DescribeOrganizationConfigurationCommand_1.DescribeOrganizationConfigurationCommand,
    DescribeProductsCommand: DescribeProductsCommand_1.DescribeProductsCommand,
    DescribeStandardsCommand: DescribeStandardsCommand_1.DescribeStandardsCommand,
    DescribeStandardsControlsCommand: DescribeStandardsControlsCommand_1.DescribeStandardsControlsCommand,
    DisableImportFindingsForProductCommand: DisableImportFindingsForProductCommand_1.DisableImportFindingsForProductCommand,
    DisableOrganizationAdminAccountCommand: DisableOrganizationAdminAccountCommand_1.DisableOrganizationAdminAccountCommand,
    DisableSecurityHubCommand: DisableSecurityHubCommand_1.DisableSecurityHubCommand,
    DisassociateFromAdministratorAccountCommand: DisassociateFromAdministratorAccountCommand_1.DisassociateFromAdministratorAccountCommand,
    DisassociateFromMasterAccountCommand: DisassociateFromMasterAccountCommand_1.DisassociateFromMasterAccountCommand,
    DisassociateMembersCommand: DisassociateMembersCommand_1.DisassociateMembersCommand,
    EnableImportFindingsForProductCommand: EnableImportFindingsForProductCommand_1.EnableImportFindingsForProductCommand,
    EnableOrganizationAdminAccountCommand: EnableOrganizationAdminAccountCommand_1.EnableOrganizationAdminAccountCommand,
    EnableSecurityHubCommand: EnableSecurityHubCommand_1.EnableSecurityHubCommand,
    GetAdministratorAccountCommand: GetAdministratorAccountCommand_1.GetAdministratorAccountCommand,
    GetEnabledStandardsCommand: GetEnabledStandardsCommand_1.GetEnabledStandardsCommand,
    GetFindingAggregatorCommand: GetFindingAggregatorCommand_1.GetFindingAggregatorCommand,
    GetFindingHistoryCommand: GetFindingHistoryCommand_1.GetFindingHistoryCommand,
    GetFindingsCommand: GetFindingsCommand_1.GetFindingsCommand,
    GetInsightResultsCommand: GetInsightResultsCommand_1.GetInsightResultsCommand,
    GetInsightsCommand: GetInsightsCommand_1.GetInsightsCommand,
    GetInvitationsCountCommand: GetInvitationsCountCommand_1.GetInvitationsCountCommand,
    GetMasterAccountCommand: GetMasterAccountCommand_1.GetMasterAccountCommand,
    GetMembersCommand: GetMembersCommand_1.GetMembersCommand,
    InviteMembersCommand: InviteMembersCommand_1.InviteMembersCommand,
    ListAutomationRulesCommand: ListAutomationRulesCommand_1.ListAutomationRulesCommand,
    ListEnabledProductsForImportCommand: ListEnabledProductsForImportCommand_1.ListEnabledProductsForImportCommand,
    ListFindingAggregatorsCommand: ListFindingAggregatorsCommand_1.ListFindingAggregatorsCommand,
    ListInvitationsCommand: ListInvitationsCommand_1.ListInvitationsCommand,
    ListMembersCommand: ListMembersCommand_1.ListMembersCommand,
    ListOrganizationAdminAccountsCommand: ListOrganizationAdminAccountsCommand_1.ListOrganizationAdminAccountsCommand,
    ListSecurityControlDefinitionsCommand: ListSecurityControlDefinitionsCommand_1.ListSecurityControlDefinitionsCommand,
    ListStandardsControlAssociationsCommand: ListStandardsControlAssociationsCommand_1.ListStandardsControlAssociationsCommand,
    ListTagsForResourceCommand: ListTagsForResourceCommand_1.ListTagsForResourceCommand,
    TagResourceCommand: TagResourceCommand_1.TagResourceCommand,
    UntagResourceCommand: UntagResourceCommand_1.UntagResourceCommand,
    UpdateActionTargetCommand: UpdateActionTargetCommand_1.UpdateActionTargetCommand,
    UpdateFindingAggregatorCommand: UpdateFindingAggregatorCommand_1.UpdateFindingAggregatorCommand,
    UpdateFindingsCommand: UpdateFindingsCommand_1.UpdateFindingsCommand,
    UpdateInsightCommand: UpdateInsightCommand_1.UpdateInsightCommand,
    UpdateOrganizationConfigurationCommand: UpdateOrganizationConfigurationCommand_1.UpdateOrganizationConfigurationCommand,
    UpdateSecurityHubConfigurationCommand: UpdateSecurityHubConfigurationCommand_1.UpdateSecurityHubConfigurationCommand,
    UpdateStandardsControlCommand: UpdateStandardsControlCommand_1.UpdateStandardsControlCommand,
};
class SecurityHub extends SecurityHubClient_1.SecurityHubClient {
}
exports.SecurityHub = SecurityHub;
(0, smithy_client_1.createAggregatedClient)(commands, SecurityHub);


/***/ }),

/***/ 12569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityHubClient = exports.__Client = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const EndpointParameters_1 = __nccwpck_require__(89809);
const runtimeConfig_1 = __nccwpck_require__(98707);
class SecurityHubClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.SecurityHubClient = SecurityHubClient;


/***/ }),

/***/ 65085:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AcceptAdministratorInvitationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class AcceptAdministratorInvitationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AcceptAdministratorInvitationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "AcceptAdministratorInvitationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_AcceptAdministratorInvitationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_AcceptAdministratorInvitationCommand)(output, context);
    }
}
exports.AcceptAdministratorInvitationCommand = AcceptAdministratorInvitationCommand;


/***/ }),

/***/ 48019:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AcceptInvitationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class AcceptInvitationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AcceptInvitationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "AcceptInvitationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_AcceptInvitationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_AcceptInvitationCommand)(output, context);
    }
}
exports.AcceptInvitationCommand = AcceptInvitationCommand;


/***/ }),

/***/ 86404:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchDeleteAutomationRulesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchDeleteAutomationRulesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchDeleteAutomationRulesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchDeleteAutomationRulesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchDeleteAutomationRulesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchDeleteAutomationRulesCommand)(output, context);
    }
}
exports.BatchDeleteAutomationRulesCommand = BatchDeleteAutomationRulesCommand;


/***/ }),

/***/ 61492:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchDisableStandardsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchDisableStandardsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchDisableStandardsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchDisableStandardsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchDisableStandardsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchDisableStandardsCommand)(output, context);
    }
}
exports.BatchDisableStandardsCommand = BatchDisableStandardsCommand;


/***/ }),

/***/ 81303:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchEnableStandardsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchEnableStandardsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchEnableStandardsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchEnableStandardsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchEnableStandardsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchEnableStandardsCommand)(output, context);
    }
}
exports.BatchEnableStandardsCommand = BatchEnableStandardsCommand;


/***/ }),

/***/ 5675:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetAutomationRulesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchGetAutomationRulesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetAutomationRulesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchGetAutomationRulesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchGetAutomationRulesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchGetAutomationRulesCommand)(output, context);
    }
}
exports.BatchGetAutomationRulesCommand = BatchGetAutomationRulesCommand;


/***/ }),

/***/ 33597:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetSecurityControlsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchGetSecurityControlsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetSecurityControlsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchGetSecurityControlsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchGetSecurityControlsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchGetSecurityControlsCommand)(output, context);
    }
}
exports.BatchGetSecurityControlsCommand = BatchGetSecurityControlsCommand;


/***/ }),

/***/ 32039:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetStandardsControlAssociationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchGetStandardsControlAssociationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetStandardsControlAssociationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchGetStandardsControlAssociationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchGetStandardsControlAssociationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchGetStandardsControlAssociationsCommand)(output, context);
    }
}
exports.BatchGetStandardsControlAssociationsCommand = BatchGetStandardsControlAssociationsCommand;


/***/ }),

/***/ 2613:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchImportFindingsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchImportFindingsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchImportFindingsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchImportFindingsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchImportFindingsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchImportFindingsCommand)(output, context);
    }
}
exports.BatchImportFindingsCommand = BatchImportFindingsCommand;


/***/ }),

/***/ 62004:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchUpdateAutomationRulesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchUpdateAutomationRulesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchUpdateAutomationRulesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchUpdateAutomationRulesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchUpdateAutomationRulesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchUpdateAutomationRulesCommand)(output, context);
    }
}
exports.BatchUpdateAutomationRulesCommand = BatchUpdateAutomationRulesCommand;


/***/ }),

/***/ 48719:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchUpdateFindingsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchUpdateFindingsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchUpdateFindingsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchUpdateFindingsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchUpdateFindingsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchUpdateFindingsCommand)(output, context);
    }
}
exports.BatchUpdateFindingsCommand = BatchUpdateFindingsCommand;


/***/ }),

/***/ 99982:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchUpdateStandardsControlAssociationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class BatchUpdateStandardsControlAssociationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchUpdateStandardsControlAssociationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "BatchUpdateStandardsControlAssociationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_BatchUpdateStandardsControlAssociationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_BatchUpdateStandardsControlAssociationsCommand)(output, context);
    }
}
exports.BatchUpdateStandardsControlAssociationsCommand = BatchUpdateStandardsControlAssociationsCommand;


/***/ }),

/***/ 88570:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateActionTargetCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class CreateActionTargetCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateActionTargetCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "CreateActionTargetCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_CreateActionTargetCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_CreateActionTargetCommand)(output, context);
    }
}
exports.CreateActionTargetCommand = CreateActionTargetCommand;


/***/ }),

/***/ 27959:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateAutomationRuleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class CreateAutomationRuleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateAutomationRuleCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "CreateAutomationRuleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_CreateAutomationRuleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_CreateAutomationRuleCommand)(output, context);
    }
}
exports.CreateAutomationRuleCommand = CreateAutomationRuleCommand;


/***/ }),

/***/ 75744:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateFindingAggregatorCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class CreateFindingAggregatorCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateFindingAggregatorCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "CreateFindingAggregatorCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_CreateFindingAggregatorCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_CreateFindingAggregatorCommand)(output, context);
    }
}
exports.CreateFindingAggregatorCommand = CreateFindingAggregatorCommand;


/***/ }),

/***/ 53109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateInsightCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class CreateInsightCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateInsightCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "CreateInsightCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_CreateInsightCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_CreateInsightCommand)(output, context);
    }
}
exports.CreateInsightCommand = CreateInsightCommand;


/***/ }),

/***/ 2858:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateMembersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class CreateMembersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateMembersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "CreateMembersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_CreateMembersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_CreateMembersCommand)(output, context);
    }
}
exports.CreateMembersCommand = CreateMembersCommand;


/***/ }),

/***/ 2879:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclineInvitationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DeclineInvitationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeclineInvitationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DeclineInvitationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DeclineInvitationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DeclineInvitationsCommand)(output, context);
    }
}
exports.DeclineInvitationsCommand = DeclineInvitationsCommand;


/***/ }),

/***/ 7327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteActionTargetCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DeleteActionTargetCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteActionTargetCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DeleteActionTargetCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DeleteActionTargetCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DeleteActionTargetCommand)(output, context);
    }
}
exports.DeleteActionTargetCommand = DeleteActionTargetCommand;


/***/ }),

/***/ 79241:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteFindingAggregatorCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DeleteFindingAggregatorCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteFindingAggregatorCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DeleteFindingAggregatorCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DeleteFindingAggregatorCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DeleteFindingAggregatorCommand)(output, context);
    }
}
exports.DeleteFindingAggregatorCommand = DeleteFindingAggregatorCommand;


/***/ }),

/***/ 88117:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteInsightCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DeleteInsightCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteInsightCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DeleteInsightCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DeleteInsightCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DeleteInsightCommand)(output, context);
    }
}
exports.DeleteInsightCommand = DeleteInsightCommand;


/***/ }),

/***/ 50128:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteInvitationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DeleteInvitationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteInvitationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DeleteInvitationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DeleteInvitationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DeleteInvitationsCommand)(output, context);
    }
}
exports.DeleteInvitationsCommand = DeleteInvitationsCommand;


/***/ }),

/***/ 62425:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteMembersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DeleteMembersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteMembersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DeleteMembersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DeleteMembersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DeleteMembersCommand)(output, context);
    }
}
exports.DeleteMembersCommand = DeleteMembersCommand;


/***/ }),

/***/ 74901:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeActionTargetsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DescribeActionTargetsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeActionTargetsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DescribeActionTargetsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DescribeActionTargetsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DescribeActionTargetsCommand)(output, context);
    }
}
exports.DescribeActionTargetsCommand = DescribeActionTargetsCommand;


/***/ }),

/***/ 90516:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeHubCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DescribeHubCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeHubCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DescribeHubCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DescribeHubCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DescribeHubCommand)(output, context);
    }
}
exports.DescribeHubCommand = DescribeHubCommand;


/***/ }),

/***/ 98161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeOrganizationConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DescribeOrganizationConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeOrganizationConfigurationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DescribeOrganizationConfigurationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DescribeOrganizationConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DescribeOrganizationConfigurationCommand)(output, context);
    }
}
exports.DescribeOrganizationConfigurationCommand = DescribeOrganizationConfigurationCommand;


/***/ }),

/***/ 16988:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeProductsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DescribeProductsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeProductsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DescribeProductsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DescribeProductsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DescribeProductsCommand)(output, context);
    }
}
exports.DescribeProductsCommand = DescribeProductsCommand;


/***/ }),

/***/ 53386:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeStandardsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DescribeStandardsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeStandardsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DescribeStandardsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DescribeStandardsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DescribeStandardsCommand)(output, context);
    }
}
exports.DescribeStandardsCommand = DescribeStandardsCommand;


/***/ }),

/***/ 87275:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeStandardsControlsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DescribeStandardsControlsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeStandardsControlsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DescribeStandardsControlsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DescribeStandardsControlsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DescribeStandardsControlsCommand)(output, context);
    }
}
exports.DescribeStandardsControlsCommand = DescribeStandardsControlsCommand;


/***/ }),

/***/ 70261:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisableImportFindingsForProductCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DisableImportFindingsForProductCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DisableImportFindingsForProductCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DisableImportFindingsForProductCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DisableImportFindingsForProductCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DisableImportFindingsForProductCommand)(output, context);
    }
}
exports.DisableImportFindingsForProductCommand = DisableImportFindingsForProductCommand;


/***/ }),

/***/ 55725:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisableOrganizationAdminAccountCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DisableOrganizationAdminAccountCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DisableOrganizationAdminAccountCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DisableOrganizationAdminAccountCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DisableOrganizationAdminAccountCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DisableOrganizationAdminAccountCommand)(output, context);
    }
}
exports.DisableOrganizationAdminAccountCommand = DisableOrganizationAdminAccountCommand;


/***/ }),

/***/ 90403:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisableSecurityHubCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DisableSecurityHubCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DisableSecurityHubCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DisableSecurityHubCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DisableSecurityHubCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DisableSecurityHubCommand)(output, context);
    }
}
exports.DisableSecurityHubCommand = DisableSecurityHubCommand;


/***/ }),

/***/ 63507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisassociateFromAdministratorAccountCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DisassociateFromAdministratorAccountCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DisassociateFromAdministratorAccountCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DisassociateFromAdministratorAccountCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DisassociateFromAdministratorAccountCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DisassociateFromAdministratorAccountCommand)(output, context);
    }
}
exports.DisassociateFromAdministratorAccountCommand = DisassociateFromAdministratorAccountCommand;


/***/ }),

/***/ 33866:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisassociateFromMasterAccountCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DisassociateFromMasterAccountCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DisassociateFromMasterAccountCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DisassociateFromMasterAccountCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DisassociateFromMasterAccountCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DisassociateFromMasterAccountCommand)(output, context);
    }
}
exports.DisassociateFromMasterAccountCommand = DisassociateFromMasterAccountCommand;


/***/ }),

/***/ 36423:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisassociateMembersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class DisassociateMembersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DisassociateMembersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "DisassociateMembersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_DisassociateMembersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_DisassociateMembersCommand)(output, context);
    }
}
exports.DisassociateMembersCommand = DisassociateMembersCommand;


/***/ }),

/***/ 51922:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnableImportFindingsForProductCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class EnableImportFindingsForProductCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, EnableImportFindingsForProductCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "EnableImportFindingsForProductCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_EnableImportFindingsForProductCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_EnableImportFindingsForProductCommand)(output, context);
    }
}
exports.EnableImportFindingsForProductCommand = EnableImportFindingsForProductCommand;


/***/ }),

/***/ 81408:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnableOrganizationAdminAccountCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class EnableOrganizationAdminAccountCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, EnableOrganizationAdminAccountCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "EnableOrganizationAdminAccountCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_EnableOrganizationAdminAccountCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_EnableOrganizationAdminAccountCommand)(output, context);
    }
}
exports.EnableOrganizationAdminAccountCommand = EnableOrganizationAdminAccountCommand;


/***/ }),

/***/ 50663:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnableSecurityHubCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class EnableSecurityHubCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, EnableSecurityHubCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "EnableSecurityHubCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_EnableSecurityHubCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_EnableSecurityHubCommand)(output, context);
    }
}
exports.EnableSecurityHubCommand = EnableSecurityHubCommand;


/***/ }),

/***/ 70688:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAdministratorAccountCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetAdministratorAccountCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAdministratorAccountCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetAdministratorAccountCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetAdministratorAccountCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetAdministratorAccountCommand)(output, context);
    }
}
exports.GetAdministratorAccountCommand = GetAdministratorAccountCommand;


/***/ }),

/***/ 8096:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetEnabledStandardsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetEnabledStandardsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetEnabledStandardsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetEnabledStandardsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetEnabledStandardsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetEnabledStandardsCommand)(output, context);
    }
}
exports.GetEnabledStandardsCommand = GetEnabledStandardsCommand;


/***/ }),

/***/ 8156:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFindingAggregatorCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetFindingAggregatorCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetFindingAggregatorCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetFindingAggregatorCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetFindingAggregatorCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetFindingAggregatorCommand)(output, context);
    }
}
exports.GetFindingAggregatorCommand = GetFindingAggregatorCommand;


/***/ }),

/***/ 19691:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFindingHistoryCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetFindingHistoryCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetFindingHistoryCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetFindingHistoryCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetFindingHistoryCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetFindingHistoryCommand)(output, context);
    }
}
exports.GetFindingHistoryCommand = GetFindingHistoryCommand;


/***/ }),

/***/ 1571:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFindingsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetFindingsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetFindingsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetFindingsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetFindingsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetFindingsCommand)(output, context);
    }
}
exports.GetFindingsCommand = GetFindingsCommand;


/***/ }),

/***/ 17023:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetInsightResultsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetInsightResultsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetInsightResultsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetInsightResultsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetInsightResultsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetInsightResultsCommand)(output, context);
    }
}
exports.GetInsightResultsCommand = GetInsightResultsCommand;


/***/ }),

/***/ 52409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetInsightsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetInsightsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetInsightsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetInsightsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetInsightsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetInsightsCommand)(output, context);
    }
}
exports.GetInsightsCommand = GetInsightsCommand;


/***/ }),

/***/ 42931:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetInvitationsCountCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetInvitationsCountCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetInvitationsCountCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetInvitationsCountCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetInvitationsCountCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetInvitationsCountCommand)(output, context);
    }
}
exports.GetInvitationsCountCommand = GetInvitationsCountCommand;


/***/ }),

/***/ 56989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetMasterAccountCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetMasterAccountCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetMasterAccountCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetMasterAccountCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetMasterAccountCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetMasterAccountCommand)(output, context);
    }
}
exports.GetMasterAccountCommand = GetMasterAccountCommand;


/***/ }),

/***/ 78168:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetMembersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class GetMembersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetMembersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "GetMembersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetMembersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetMembersCommand)(output, context);
    }
}
exports.GetMembersCommand = GetMembersCommand;


/***/ }),

/***/ 77310:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InviteMembersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class InviteMembersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, InviteMembersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "InviteMembersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_InviteMembersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_InviteMembersCommand)(output, context);
    }
}
exports.InviteMembersCommand = InviteMembersCommand;


/***/ }),

/***/ 43336:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAutomationRulesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListAutomationRulesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAutomationRulesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListAutomationRulesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListAutomationRulesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListAutomationRulesCommand)(output, context);
    }
}
exports.ListAutomationRulesCommand = ListAutomationRulesCommand;


/***/ }),

/***/ 27425:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListEnabledProductsForImportCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListEnabledProductsForImportCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListEnabledProductsForImportCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListEnabledProductsForImportCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListEnabledProductsForImportCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListEnabledProductsForImportCommand)(output, context);
    }
}
exports.ListEnabledProductsForImportCommand = ListEnabledProductsForImportCommand;


/***/ }),

/***/ 52848:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListFindingAggregatorsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListFindingAggregatorsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListFindingAggregatorsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListFindingAggregatorsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListFindingAggregatorsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListFindingAggregatorsCommand)(output, context);
    }
}
exports.ListFindingAggregatorsCommand = ListFindingAggregatorsCommand;


/***/ }),

/***/ 99276:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListInvitationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListInvitationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListInvitationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListInvitationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListInvitationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListInvitationsCommand)(output, context);
    }
}
exports.ListInvitationsCommand = ListInvitationsCommand;


/***/ }),

/***/ 1215:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListMembersCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListMembersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListMembersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListMembersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListMembersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListMembersCommand)(output, context);
    }
}
exports.ListMembersCommand = ListMembersCommand;


/***/ }),

/***/ 39272:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListOrganizationAdminAccountsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListOrganizationAdminAccountsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListOrganizationAdminAccountsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListOrganizationAdminAccountsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListOrganizationAdminAccountsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListOrganizationAdminAccountsCommand)(output, context);
    }
}
exports.ListOrganizationAdminAccountsCommand = ListOrganizationAdminAccountsCommand;


/***/ }),

/***/ 43237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListSecurityControlDefinitionsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListSecurityControlDefinitionsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListSecurityControlDefinitionsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListSecurityControlDefinitionsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListSecurityControlDefinitionsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListSecurityControlDefinitionsCommand)(output, context);
    }
}
exports.ListSecurityControlDefinitionsCommand = ListSecurityControlDefinitionsCommand;


/***/ }),

/***/ 43470:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListStandardsControlAssociationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListStandardsControlAssociationsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListStandardsControlAssociationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListStandardsControlAssociationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListStandardsControlAssociationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListStandardsControlAssociationsCommand)(output, context);
    }
}
exports.ListStandardsControlAssociationsCommand = ListStandardsControlAssociationsCommand;


/***/ }),

/***/ 8294:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTagsForResourceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class ListTagsForResourceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTagsForResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "ListTagsForResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListTagsForResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListTagsForResourceCommand)(output, context);
    }
}
exports.ListTagsForResourceCommand = ListTagsForResourceCommand;


/***/ }),

/***/ 10694:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagResourceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class TagResourceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "TagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_TagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_TagResourceCommand)(output, context);
    }
}
exports.TagResourceCommand = TagResourceCommand;


/***/ }),

/***/ 71455:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagResourceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class UntagResourceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "UntagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_UntagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_UntagResourceCommand)(output, context);
    }
}
exports.UntagResourceCommand = UntagResourceCommand;


/***/ }),

/***/ 66563:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateActionTargetCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class UpdateActionTargetCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateActionTargetCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "UpdateActionTargetCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_UpdateActionTargetCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_UpdateActionTargetCommand)(output, context);
    }
}
exports.UpdateActionTargetCommand = UpdateActionTargetCommand;


/***/ }),

/***/ 61656:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateFindingAggregatorCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class UpdateFindingAggregatorCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateFindingAggregatorCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "UpdateFindingAggregatorCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_UpdateFindingAggregatorCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_UpdateFindingAggregatorCommand)(output, context);
    }
}
exports.UpdateFindingAggregatorCommand = UpdateFindingAggregatorCommand;


/***/ }),

/***/ 89806:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateFindingsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class UpdateFindingsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateFindingsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "UpdateFindingsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_UpdateFindingsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_UpdateFindingsCommand)(output, context);
    }
}
exports.UpdateFindingsCommand = UpdateFindingsCommand;


/***/ }),

/***/ 78709:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateInsightCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class UpdateInsightCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateInsightCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "UpdateInsightCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_UpdateInsightCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_UpdateInsightCommand)(output, context);
    }
}
exports.UpdateInsightCommand = UpdateInsightCommand;


/***/ }),

/***/ 4199:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateOrganizationConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class UpdateOrganizationConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateOrganizationConfigurationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "UpdateOrganizationConfigurationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_UpdateOrganizationConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_UpdateOrganizationConfigurationCommand)(output, context);
    }
}
exports.UpdateOrganizationConfigurationCommand = UpdateOrganizationConfigurationCommand;


/***/ }),

/***/ 51321:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateSecurityHubConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class UpdateSecurityHubConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateSecurityHubConfigurationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "UpdateSecurityHubConfigurationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_UpdateSecurityHubConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_UpdateSecurityHubConfigurationCommand)(output, context);
    }
}
exports.UpdateSecurityHubConfigurationCommand = UpdateSecurityHubConfigurationCommand;


/***/ }),

/***/ 6201:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateStandardsControlCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(88524);
class UpdateStandardsControlCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateStandardsControlCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SecurityHubClient";
        const commandName = "UpdateStandardsControlCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_UpdateStandardsControlCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_UpdateStandardsControlCommand)(output, context);
    }
}
exports.UpdateStandardsControlCommand = UpdateStandardsControlCommand;


/***/ }),

/***/ 13234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(65085), exports);
tslib_1.__exportStar(__nccwpck_require__(48019), exports);
tslib_1.__exportStar(__nccwpck_require__(86404), exports);
tslib_1.__exportStar(__nccwpck_require__(61492), exports);
tslib_1.__exportStar(__nccwpck_require__(81303), exports);
tslib_1.__exportStar(__nccwpck_require__(5675), exports);
tslib_1.__exportStar(__nccwpck_require__(33597), exports);
tslib_1.__exportStar(__nccwpck_require__(32039), exports);
tslib_1.__exportStar(__nccwpck_require__(2613), exports);
tslib_1.__exportStar(__nccwpck_require__(62004), exports);
tslib_1.__exportStar(__nccwpck_require__(48719), exports);
tslib_1.__exportStar(__nccwpck_require__(99982), exports);
tslib_1.__exportStar(__nccwpck_require__(88570), exports);
tslib_1.__exportStar(__nccwpck_require__(27959), exports);
tslib_1.__exportStar(__nccwpck_require__(75744), exports);
tslib_1.__exportStar(__nccwpck_require__(53109), exports);
tslib_1.__exportStar(__nccwpck_require__(2858), exports);
tslib_1.__exportStar(__nccwpck_require__(2879), exports);
tslib_1.__exportStar(__nccwpck_require__(7327), exports);
tslib_1.__exportStar(__nccwpck_require__(79241), exports);
tslib_1.__exportStar(__nccwpck_require__(88117), exports);
tslib_1.__exportStar(__nccwpck_require__(50128), exports);
tslib_1.__exportStar(__nccwpck_require__(62425), exports);
tslib_1.__exportStar(__nccwpck_require__(74901), exports);
tslib_1.__exportStar(__nccwpck_require__(90516), exports);
tslib_1.__exportStar(__nccwpck_require__(98161), exports);
tslib_1.__exportStar(__nccwpck_require__(16988), exports);
tslib_1.__exportStar(__nccwpck_require__(53386), exports);
tslib_1.__exportStar(__nccwpck_require__(87275), exports);
tslib_1.__exportStar(__nccwpck_require__(70261), exports);
tslib_1.__exportStar(__nccwpck_require__(55725), exports);
tslib_1.__exportStar(__nccwpck_require__(90403), exports);
tslib_1.__exportStar(__nccwpck_require__(63507), exports);
tslib_1.__exportStar(__nccwpck_require__(33866), exports);
tslib_1.__exportStar(__nccwpck_require__(36423), exports);
tslib_1.__exportStar(__nccwpck_require__(51922), exports);
tslib_1.__exportStar(__nccwpck_require__(81408), exports);
tslib_1.__exportStar(__nccwpck_require__(50663), exports);
tslib_1.__exportStar(__nccwpck_require__(70688), exports);
tslib_1.__exportStar(__nccwpck_require__(8096), exports);
tslib_1.__exportStar(__nccwpck_require__(8156), exports);
tslib_1.__exportStar(__nccwpck_require__(19691), exports);
tslib_1.__exportStar(__nccwpck_require__(1571), exports);
tslib_1.__exportStar(__nccwpck_require__(17023), exports);
tslib_1.__exportStar(__nccwpck_require__(52409), exports);
tslib_1.__exportStar(__nccwpck_require__(42931), exports);
tslib_1.__exportStar(__nccwpck_require__(56989), exports);
tslib_1.__exportStar(__nccwpck_require__(78168), exports);
tslib_1.__exportStar(__nccwpck_require__(77310), exports);
tslib_1.__exportStar(__nccwpck_require__(43336), exports);
tslib_1.__exportStar(__nccwpck_require__(27425), exports);
tslib_1.__exportStar(__nccwpck_require__(52848), exports);
tslib_1.__exportStar(__nccwpck_require__(99276), exports);
tslib_1.__exportStar(__nccwpck_require__(1215), exports);
tslib_1.__exportStar(__nccwpck_require__(39272), exports);
tslib_1.__exportStar(__nccwpck_require__(43237), exports);
tslib_1.__exportStar(__nccwpck_require__(43470), exports);
tslib_1.__exportStar(__nccwpck_require__(8294), exports);
tslib_1.__exportStar(__nccwpck_require__(10694), exports);
tslib_1.__exportStar(__nccwpck_require__(71455), exports);
tslib_1.__exportStar(__nccwpck_require__(66563), exports);
tslib_1.__exportStar(__nccwpck_require__(61656), exports);
tslib_1.__exportStar(__nccwpck_require__(89806), exports);
tslib_1.__exportStar(__nccwpck_require__(78709), exports);
tslib_1.__exportStar(__nccwpck_require__(4199), exports);
tslib_1.__exportStar(__nccwpck_require__(51321), exports);
tslib_1.__exportStar(__nccwpck_require__(6201), exports);


/***/ }),

/***/ 89809:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "securityhub",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 59644:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(23165);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 23165:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const q = "required", r = "fn", s = "argv", t = "ref";
const a = "isSet", b = "tree", c = "error", d = "endpoint", e = "PartitionResult", f = { [q]: false, "type": "String" }, g = { [q]: true, "default": false, "type": "Boolean" }, h = { [t]: "Endpoint" }, i = { [r]: "booleanEquals", [s]: [{ [t]: "UseFIPS" }, true] }, j = { [r]: "booleanEquals", [s]: [{ [t]: "UseDualStack" }, true] }, k = {}, l = { [r]: "booleanEquals", [s]: [true, { [r]: "getAttr", [s]: [{ [t]: e }, "supportsFIPS"] }] }, m = { [r]: "booleanEquals", [s]: [true, { [r]: "getAttr", [s]: [{ [t]: e }, "supportsDualStack"] }] }, n = [i], o = [j], p = [{ [t]: "Region" }];
const _data = { version: "1.0", parameters: { Region: f, UseDualStack: g, UseFIPS: g, Endpoint: f }, rules: [{ conditions: [{ [r]: a, [s]: [h] }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: h, properties: k, headers: k }, type: d }] }] }, { type: b, rules: [{ conditions: [{ [r]: a, [s]: p }], type: b, rules: [{ conditions: [{ [r]: "aws.partition", [s]: p, assign: e }], type: b, rules: [{ conditions: [i, j], type: b, rules: [{ conditions: [l, m], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://securityhub-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: k, headers: k }, type: d }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [l], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://securityhub-fips.{Region}.{PartitionResult#dnsSuffix}", properties: k, headers: k }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [m], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://securityhub.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: k, headers: k }, type: d }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { type: b, rules: [{ endpoint: { url: "https://securityhub.{Region}.{PartitionResult#dnsSuffix}", properties: k, headers: k }, type: d }] }] }] }, { error: "Invalid Configuration: Missing Region", type: c }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 93978:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityHubServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(12569), exports);
tslib_1.__exportStar(__nccwpck_require__(11042), exports);
tslib_1.__exportStar(__nccwpck_require__(13234), exports);
tslib_1.__exportStar(__nccwpck_require__(36099), exports);
tslib_1.__exportStar(__nccwpck_require__(51642), exports);
var SecurityHubServiceException_1 = __nccwpck_require__(38514);
Object.defineProperty(exports, "SecurityHubServiceException", ({ enumerable: true, get: function () { return SecurityHubServiceException_1.SecurityHubServiceException; } }));


/***/ }),

/***/ 38514:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityHubServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class SecurityHubServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SecurityHubServiceException.prototype);
    }
}
exports.SecurityHubServiceException = SecurityHubServiceException;


/***/ }),

/***/ 51642:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(99080), exports);
tslib_1.__exportStar(__nccwpck_require__(74549), exports);
tslib_1.__exportStar(__nccwpck_require__(76149), exports);


/***/ }),

/***/ 99080:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RuleStatus = exports.MapFilterComparison = exports.DateRangeUnit = exports.StringFilterComparison = exports.AutoEnableStandards = exports.AssociationStatus = exports.AdminStatus = exports.AutomationRulesActionType = exports.WorkflowStatus = exports.VerificationState = exports.SeverityLabel = exports.AccessDeniedException = exports.ResourceNotFoundException = exports.LimitExceededException = exports.InvalidInputException = exports.InvalidAccessException = exports.InternalException = void 0;
const SecurityHubServiceException_1 = __nccwpck_require__(38514);
class InternalException extends SecurityHubServiceException_1.SecurityHubServiceException {
    constructor(opts) {
        super({
            name: "InternalException",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalException";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalException.prototype);
        this.Message = opts.Message;
        this.Code = opts.Code;
    }
}
exports.InternalException = InternalException;
class InvalidAccessException extends SecurityHubServiceException_1.SecurityHubServiceException {
    constructor(opts) {
        super({
            name: "InvalidAccessException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAccessException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAccessException.prototype);
        this.Message = opts.Message;
        this.Code = opts.Code;
    }
}
exports.InvalidAccessException = InvalidAccessException;
class InvalidInputException extends SecurityHubServiceException_1.SecurityHubServiceException {
    constructor(opts) {
        super({
            name: "InvalidInputException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidInputException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidInputException.prototype);
        this.Message = opts.Message;
        this.Code = opts.Code;
    }
}
exports.InvalidInputException = InvalidInputException;
class LimitExceededException extends SecurityHubServiceException_1.SecurityHubServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LimitExceededException.prototype);
        this.Message = opts.Message;
        this.Code = opts.Code;
    }
}
exports.LimitExceededException = LimitExceededException;
class ResourceNotFoundException extends SecurityHubServiceException_1.SecurityHubServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
        this.Message = opts.Message;
        this.Code = opts.Code;
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
class AccessDeniedException extends SecurityHubServiceException_1.SecurityHubServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
        this.Message = opts.Message;
        this.Code = opts.Code;
    }
}
exports.AccessDeniedException = AccessDeniedException;
exports.SeverityLabel = {
    CRITICAL: "CRITICAL",
    HIGH: "HIGH",
    INFORMATIONAL: "INFORMATIONAL",
    LOW: "LOW",
    MEDIUM: "MEDIUM",
};
exports.VerificationState = {
    BENIGN_POSITIVE: "BENIGN_POSITIVE",
    FALSE_POSITIVE: "FALSE_POSITIVE",
    TRUE_POSITIVE: "TRUE_POSITIVE",
    UNKNOWN: "UNKNOWN",
};
exports.WorkflowStatus = {
    NEW: "NEW",
    NOTIFIED: "NOTIFIED",
    RESOLVED: "RESOLVED",
    SUPPRESSED: "SUPPRESSED",
};
exports.AutomationRulesActionType = {
    FINDING_FIELDS_UPDATE: "FINDING_FIELDS_UPDATE",
};
exports.AdminStatus = {
    DISABLE_IN_PROGRESS: "DISABLE_IN_PROGRESS",
    ENABLED: "ENABLED",
};
exports.AssociationStatus = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
exports.AutoEnableStandards = {
    DEFAULT: "DEFAULT",
    NONE: "NONE",
};
exports.StringFilterComparison = {
    CONTAINS: "CONTAINS",
    EQUALS: "EQUALS",
    NOT_CONTAINS: "NOT_CONTAINS",
    NOT_EQUALS: "NOT_EQUALS",
    PREFIX: "PREFIX",
    PREFIX_NOT_EQUALS: "PREFIX_NOT_EQUALS",
};
exports.DateRangeUnit = {
    DAYS: "DAYS",
};
exports.MapFilterComparison = {
    CONTAINS: "CONTAINS",
    EQUALS: "EQUALS",
    NOT_CONTAINS: "NOT_CONTAINS",
    NOT_EQUALS: "NOT_EQUALS",
};
exports.RuleStatus = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};


/***/ }),

/***/ 74549:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkflowState = exports.VulnerabilityFixAvailable = exports.ThreatIntelIndicatorType = exports.ThreatIntelIndicatorCategory = exports.Partition = exports.RecordState = exports.NetworkDirection = exports.MalwareType = exports.MalwareState = exports.ComplianceStatus = exports.AwsS3BucketNotificationConfigurationS3KeyFilterRuleName = exports.AwsIamAccessKeyStatus = void 0;
exports.AwsIamAccessKeyStatus = {
    ACTIVE: "Active",
    INACTIVE: "Inactive",
};
exports.AwsS3BucketNotificationConfigurationS3KeyFilterRuleName = {
    PREFIX: "Prefix",
    SUFFIX: "Suffix",
};
exports.ComplianceStatus = {
    FAILED: "FAILED",
    NOT_AVAILABLE: "NOT_AVAILABLE",
    PASSED: "PASSED",
    WARNING: "WARNING",
};
exports.MalwareState = {
    OBSERVED: "OBSERVED",
    REMOVAL_FAILED: "REMOVAL_FAILED",
    REMOVED: "REMOVED",
};
exports.MalwareType = {
    ADWARE: "ADWARE",
    BLENDED_THREAT: "BLENDED_THREAT",
    BOTNET_AGENT: "BOTNET_AGENT",
    COIN_MINER: "COIN_MINER",
    EXPLOIT_KIT: "EXPLOIT_KIT",
    KEYLOGGER: "KEYLOGGER",
    MACRO: "MACRO",
    POTENTIALLY_UNWANTED: "POTENTIALLY_UNWANTED",
    RANSOMWARE: "RANSOMWARE",
    REMOTE_ACCESS: "REMOTE_ACCESS",
    ROOTKIT: "ROOTKIT",
    SPYWARE: "SPYWARE",
    TROJAN: "TROJAN",
    VIRUS: "VIRUS",
    WORM: "WORM",
};
exports.NetworkDirection = {
    IN: "IN",
    OUT: "OUT",
};
exports.RecordState = {
    ACTIVE: "ACTIVE",
    ARCHIVED: "ARCHIVED",
};
exports.Partition = {
    AWS: "aws",
    AWS_CN: "aws-cn",
    AWS_US_GOV: "aws-us-gov",
};
exports.ThreatIntelIndicatorCategory = {
    BACKDOOR: "BACKDOOR",
    CARD_STEALER: "CARD_STEALER",
    COMMAND_AND_CONTROL: "COMMAND_AND_CONTROL",
    DROP_SITE: "DROP_SITE",
    EXPLOIT_SITE: "EXPLOIT_SITE",
    KEYLOGGER: "KEYLOGGER",
};
exports.ThreatIntelIndicatorType = {
    DOMAIN: "DOMAIN",
    EMAIL_ADDRESS: "EMAIL_ADDRESS",
    HASH_MD5: "HASH_MD5",
    HASH_SHA1: "HASH_SHA1",
    HASH_SHA256: "HASH_SHA256",
    HASH_SHA512: "HASH_SHA512",
    IPV4_ADDRESS: "IPV4_ADDRESS",
    IPV6_ADDRESS: "IPV6_ADDRESS",
    MUTEX: "MUTEX",
    PROCESS: "PROCESS",
    URL: "URL",
};
exports.VulnerabilityFixAvailable = {
    NO: "NO",
    PARTIAL: "PARTIAL",
    YES: "YES",
};
exports.WorkflowState = {
    ASSIGNED: "ASSIGNED",
    DEFERRED: "DEFERRED",
    IN_PROGRESS: "IN_PROGRESS",
    NEW: "NEW",
    RESOLVED: "RESOLVED",
};


/***/ }),

/***/ 76149:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegionAvailabilityStatus = exports.SortOrder = exports.FindingHistoryUpdateSourceType = exports.IntegrationType = exports.ResourceConflictException = exports.ControlFindingGenerator = exports.UnprocessedErrorCode = exports.SeverityRating = exports.ControlStatus = exports.StatusReasonCode = exports.StandardsStatus = void 0;
const SecurityHubServiceException_1 = __nccwpck_require__(38514);
exports.StandardsStatus = {
    DELETING: "DELETING",
    FAILED: "FAILED",
    INCOMPLETE: "INCOMPLETE",
    PENDING: "PENDING",
    READY: "READY",
};
exports.StatusReasonCode = {
    INTERNAL_ERROR: "INTERNAL_ERROR",
    NO_AVAILABLE_CONFIGURATION_RECORDER: "NO_AVAILABLE_CONFIGURATION_RECORDER",
};
exports.ControlStatus = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
exports.SeverityRating = {
    CRITICAL: "CRITICAL",
    HIGH: "HIGH",
    LOW: "LOW",
    MEDIUM: "MEDIUM",
};
exports.UnprocessedErrorCode = {
    ACCESS_DENIED: "ACCESS_DENIED",
    INVALID_INPUT: "INVALID_INPUT",
    LIMIT_EXCEEDED: "LIMIT_EXCEEDED",
    NOT_FOUND: "NOT_FOUND",
};
exports.ControlFindingGenerator = {
    SECURITY_CONTROL: "SECURITY_CONTROL",
    STANDARD_CONTROL: "STANDARD_CONTROL",
};
class ResourceConflictException extends SecurityHubServiceException_1.SecurityHubServiceException {
    constructor(opts) {
        super({
            name: "ResourceConflictException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceConflictException.prototype);
        this.Message = opts.Message;
        this.Code = opts.Code;
    }
}
exports.ResourceConflictException = ResourceConflictException;
exports.IntegrationType = {
    RECEIVE_FINDINGS_FROM_SECURITY_HUB: "RECEIVE_FINDINGS_FROM_SECURITY_HUB",
    SEND_FINDINGS_TO_SECURITY_HUB: "SEND_FINDINGS_TO_SECURITY_HUB",
    UPDATE_FINDINGS_IN_SECURITY_HUB: "UPDATE_FINDINGS_IN_SECURITY_HUB",
};
exports.FindingHistoryUpdateSourceType = {
    BATCH_IMPORT_FINDINGS: "BATCH_IMPORT_FINDINGS",
    BATCH_UPDATE_FINDINGS: "BATCH_UPDATE_FINDINGS",
};
exports.SortOrder = {
    ASCENDING: "asc",
    DESCENDING: "desc",
};
exports.RegionAvailabilityStatus = {
    AVAILABLE: "AVAILABLE",
    UNAVAILABLE: "UNAVAILABLE",
};


/***/ }),

/***/ 44955:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeActionTargets = void 0;
const DescribeActionTargetsCommand_1 = __nccwpck_require__(74901);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeActionTargetsCommand_1.DescribeActionTargetsCommand(input), ...args);
};
async function* paginateDescribeActionTargets(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeActionTargets = paginateDescribeActionTargets;


/***/ }),

/***/ 25578:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeProducts = void 0;
const DescribeProductsCommand_1 = __nccwpck_require__(16988);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeProductsCommand_1.DescribeProductsCommand(input), ...args);
};
async function* paginateDescribeProducts(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeProducts = paginateDescribeProducts;


/***/ }),

/***/ 18969:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeStandardsControls = void 0;
const DescribeStandardsControlsCommand_1 = __nccwpck_require__(87275);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeStandardsControlsCommand_1.DescribeStandardsControlsCommand(input), ...args);
};
async function* paginateDescribeStandardsControls(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeStandardsControls = paginateDescribeStandardsControls;


/***/ }),

/***/ 99340:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeStandards = void 0;
const DescribeStandardsCommand_1 = __nccwpck_require__(53386);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeStandardsCommand_1.DescribeStandardsCommand(input), ...args);
};
async function* paginateDescribeStandards(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeStandards = paginateDescribeStandards;


/***/ }),

/***/ 84963:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateGetEnabledStandards = void 0;
const GetEnabledStandardsCommand_1 = __nccwpck_require__(8096);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new GetEnabledStandardsCommand_1.GetEnabledStandardsCommand(input), ...args);
};
async function* paginateGetEnabledStandards(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateGetEnabledStandards = paginateGetEnabledStandards;


/***/ }),

/***/ 15671:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateGetFindingHistory = void 0;
const GetFindingHistoryCommand_1 = __nccwpck_require__(19691);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new GetFindingHistoryCommand_1.GetFindingHistoryCommand(input), ...args);
};
async function* paginateGetFindingHistory(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateGetFindingHistory = paginateGetFindingHistory;


/***/ }),

/***/ 17126:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateGetFindings = void 0;
const GetFindingsCommand_1 = __nccwpck_require__(1571);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new GetFindingsCommand_1.GetFindingsCommand(input), ...args);
};
async function* paginateGetFindings(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateGetFindings = paginateGetFindings;


/***/ }),

/***/ 45268:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateGetInsights = void 0;
const GetInsightsCommand_1 = __nccwpck_require__(52409);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new GetInsightsCommand_1.GetInsightsCommand(input), ...args);
};
async function* paginateGetInsights(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateGetInsights = paginateGetInsights;


/***/ }),

/***/ 54883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 59287:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListEnabledProductsForImport = void 0;
const ListEnabledProductsForImportCommand_1 = __nccwpck_require__(27425);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListEnabledProductsForImportCommand_1.ListEnabledProductsForImportCommand(input), ...args);
};
async function* paginateListEnabledProductsForImport(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListEnabledProductsForImport = paginateListEnabledProductsForImport;


/***/ }),

/***/ 28403:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListFindingAggregators = void 0;
const ListFindingAggregatorsCommand_1 = __nccwpck_require__(52848);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListFindingAggregatorsCommand_1.ListFindingAggregatorsCommand(input), ...args);
};
async function* paginateListFindingAggregators(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListFindingAggregators = paginateListFindingAggregators;


/***/ }),

/***/ 8460:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListInvitations = void 0;
const ListInvitationsCommand_1 = __nccwpck_require__(99276);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListInvitationsCommand_1.ListInvitationsCommand(input), ...args);
};
async function* paginateListInvitations(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListInvitations = paginateListInvitations;


/***/ }),

/***/ 679:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListMembers = void 0;
const ListMembersCommand_1 = __nccwpck_require__(1215);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListMembersCommand_1.ListMembersCommand(input), ...args);
};
async function* paginateListMembers(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListMembers = paginateListMembers;


/***/ }),

/***/ 76385:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListOrganizationAdminAccounts = void 0;
const ListOrganizationAdminAccountsCommand_1 = __nccwpck_require__(39272);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListOrganizationAdminAccountsCommand_1.ListOrganizationAdminAccountsCommand(input), ...args);
};
async function* paginateListOrganizationAdminAccounts(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListOrganizationAdminAccounts = paginateListOrganizationAdminAccounts;


/***/ }),

/***/ 44449:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListSecurityControlDefinitions = void 0;
const ListSecurityControlDefinitionsCommand_1 = __nccwpck_require__(43237);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListSecurityControlDefinitionsCommand_1.ListSecurityControlDefinitionsCommand(input), ...args);
};
async function* paginateListSecurityControlDefinitions(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListSecurityControlDefinitions = paginateListSecurityControlDefinitions;


/***/ }),

/***/ 47604:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListStandardsControlAssociations = void 0;
const ListStandardsControlAssociationsCommand_1 = __nccwpck_require__(43470);
const SecurityHubClient_1 = __nccwpck_require__(12569);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListStandardsControlAssociationsCommand_1.ListStandardsControlAssociationsCommand(input), ...args);
};
async function* paginateListStandardsControlAssociations(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof SecurityHubClient_1.SecurityHubClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SecurityHub | SecurityHubClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListStandardsControlAssociations = paginateListStandardsControlAssociations;


/***/ }),

/***/ 36099:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(44955), exports);
tslib_1.__exportStar(__nccwpck_require__(25578), exports);
tslib_1.__exportStar(__nccwpck_require__(18969), exports);
tslib_1.__exportStar(__nccwpck_require__(99340), exports);
tslib_1.__exportStar(__nccwpck_require__(84963), exports);
tslib_1.__exportStar(__nccwpck_require__(15671), exports);
tslib_1.__exportStar(__nccwpck_require__(17126), exports);
tslib_1.__exportStar(__nccwpck_require__(45268), exports);
tslib_1.__exportStar(__nccwpck_require__(54883), exports);
tslib_1.__exportStar(__nccwpck_require__(59287), exports);
tslib_1.__exportStar(__nccwpck_require__(28403), exports);
tslib_1.__exportStar(__nccwpck_require__(8460), exports);
tslib_1.__exportStar(__nccwpck_require__(679), exports);
tslib_1.__exportStar(__nccwpck_require__(76385), exports);
tslib_1.__exportStar(__nccwpck_require__(44449), exports);
tslib_1.__exportStar(__nccwpck_require__(47604), exports);


/***/ }),

/***/ 88524:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.se_ListAutomationRulesCommand = exports.se_InviteMembersCommand = exports.se_GetMembersCommand = exports.se_GetMasterAccountCommand = exports.se_GetInvitationsCountCommand = exports.se_GetInsightsCommand = exports.se_GetInsightResultsCommand = exports.se_GetFindingsCommand = exports.se_GetFindingHistoryCommand = exports.se_GetFindingAggregatorCommand = exports.se_GetEnabledStandardsCommand = exports.se_GetAdministratorAccountCommand = exports.se_EnableSecurityHubCommand = exports.se_EnableOrganizationAdminAccountCommand = exports.se_EnableImportFindingsForProductCommand = exports.se_DisassociateMembersCommand = exports.se_DisassociateFromMasterAccountCommand = exports.se_DisassociateFromAdministratorAccountCommand = exports.se_DisableSecurityHubCommand = exports.se_DisableOrganizationAdminAccountCommand = exports.se_DisableImportFindingsForProductCommand = exports.se_DescribeStandardsControlsCommand = exports.se_DescribeStandardsCommand = exports.se_DescribeProductsCommand = exports.se_DescribeOrganizationConfigurationCommand = exports.se_DescribeHubCommand = exports.se_DescribeActionTargetsCommand = exports.se_DeleteMembersCommand = exports.se_DeleteInvitationsCommand = exports.se_DeleteInsightCommand = exports.se_DeleteFindingAggregatorCommand = exports.se_DeleteActionTargetCommand = exports.se_DeclineInvitationsCommand = exports.se_CreateMembersCommand = exports.se_CreateInsightCommand = exports.se_CreateFindingAggregatorCommand = exports.se_CreateAutomationRuleCommand = exports.se_CreateActionTargetCommand = exports.se_BatchUpdateStandardsControlAssociationsCommand = exports.se_BatchUpdateFindingsCommand = exports.se_BatchUpdateAutomationRulesCommand = exports.se_BatchImportFindingsCommand = exports.se_BatchGetStandardsControlAssociationsCommand = exports.se_BatchGetSecurityControlsCommand = exports.se_BatchGetAutomationRulesCommand = exports.se_BatchEnableStandardsCommand = exports.se_BatchDisableStandardsCommand = exports.se_BatchDeleteAutomationRulesCommand = exports.se_AcceptInvitationCommand = exports.se_AcceptAdministratorInvitationCommand = void 0;
exports.de_DisassociateFromAdministratorAccountCommand = exports.de_DisableSecurityHubCommand = exports.de_DisableOrganizationAdminAccountCommand = exports.de_DisableImportFindingsForProductCommand = exports.de_DescribeStandardsControlsCommand = exports.de_DescribeStandardsCommand = exports.de_DescribeProductsCommand = exports.de_DescribeOrganizationConfigurationCommand = exports.de_DescribeHubCommand = exports.de_DescribeActionTargetsCommand = exports.de_DeleteMembersCommand = exports.de_DeleteInvitationsCommand = exports.de_DeleteInsightCommand = exports.de_DeleteFindingAggregatorCommand = exports.de_DeleteActionTargetCommand = exports.de_DeclineInvitationsCommand = exports.de_CreateMembersCommand = exports.de_CreateInsightCommand = exports.de_CreateFindingAggregatorCommand = exports.de_CreateAutomationRuleCommand = exports.de_CreateActionTargetCommand = exports.de_BatchUpdateStandardsControlAssociationsCommand = exports.de_BatchUpdateFindingsCommand = exports.de_BatchUpdateAutomationRulesCommand = exports.de_BatchImportFindingsCommand = exports.de_BatchGetStandardsControlAssociationsCommand = exports.de_BatchGetSecurityControlsCommand = exports.de_BatchGetAutomationRulesCommand = exports.de_BatchEnableStandardsCommand = exports.de_BatchDisableStandardsCommand = exports.de_BatchDeleteAutomationRulesCommand = exports.de_AcceptInvitationCommand = exports.de_AcceptAdministratorInvitationCommand = exports.se_UpdateStandardsControlCommand = exports.se_UpdateSecurityHubConfigurationCommand = exports.se_UpdateOrganizationConfigurationCommand = exports.se_UpdateInsightCommand = exports.se_UpdateFindingsCommand = exports.se_UpdateFindingAggregatorCommand = exports.se_UpdateActionTargetCommand = exports.se_UntagResourceCommand = exports.se_TagResourceCommand = exports.se_ListTagsForResourceCommand = exports.se_ListStandardsControlAssociationsCommand = exports.se_ListSecurityControlDefinitionsCommand = exports.se_ListOrganizationAdminAccountsCommand = exports.se_ListMembersCommand = exports.se_ListInvitationsCommand = exports.se_ListFindingAggregatorsCommand = exports.se_ListEnabledProductsForImportCommand = void 0;
exports.de_UpdateStandardsControlCommand = exports.de_UpdateSecurityHubConfigurationCommand = exports.de_UpdateOrganizationConfigurationCommand = exports.de_UpdateInsightCommand = exports.de_UpdateFindingsCommand = exports.de_UpdateFindingAggregatorCommand = exports.de_UpdateActionTargetCommand = exports.de_UntagResourceCommand = exports.de_TagResourceCommand = exports.de_ListTagsForResourceCommand = exports.de_ListStandardsControlAssociationsCommand = exports.de_ListSecurityControlDefinitionsCommand = exports.de_ListOrganizationAdminAccountsCommand = exports.de_ListMembersCommand = exports.de_ListInvitationsCommand = exports.de_ListFindingAggregatorsCommand = exports.de_ListEnabledProductsForImportCommand = exports.de_ListAutomationRulesCommand = exports.de_InviteMembersCommand = exports.de_GetMembersCommand = exports.de_GetMasterAccountCommand = exports.de_GetInvitationsCountCommand = exports.de_GetInsightsCommand = exports.de_GetInsightResultsCommand = exports.de_GetFindingsCommand = exports.de_GetFindingHistoryCommand = exports.de_GetFindingAggregatorCommand = exports.de_GetEnabledStandardsCommand = exports.de_GetAdministratorAccountCommand = exports.de_EnableSecurityHubCommand = exports.de_EnableOrganizationAdminAccountCommand = exports.de_EnableImportFindingsForProductCommand = exports.de_DisassociateMembersCommand = exports.de_DisassociateFromMasterAccountCommand = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const models_0_1 = __nccwpck_require__(99080);
const models_2_1 = __nccwpck_require__(76149);
const SecurityHubServiceException_1 = __nccwpck_require__(38514);
const se_AcceptAdministratorInvitationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/administrator";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AdministratorId: [],
        InvitationId: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_AcceptAdministratorInvitationCommand = se_AcceptAdministratorInvitationCommand;
const se_AcceptInvitationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/master";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        InvitationId: [],
        MasterId: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_AcceptInvitationCommand = se_AcceptInvitationCommand;
const se_BatchDeleteAutomationRulesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/automationrules/delete";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AutomationRulesArns: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchDeleteAutomationRulesCommand = se_BatchDeleteAutomationRulesCommand;
const se_BatchDisableStandardsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/standards/deregister";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        StandardsSubscriptionArns: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchDisableStandardsCommand = se_BatchDisableStandardsCommand;
const se_BatchEnableStandardsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/standards/register";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        StandardsSubscriptionRequests: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchEnableStandardsCommand = se_BatchEnableStandardsCommand;
const se_BatchGetAutomationRulesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/automationrules/get";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AutomationRulesArns: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchGetAutomationRulesCommand = se_BatchGetAutomationRulesCommand;
const se_BatchGetSecurityControlsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/securityControls/batchGet";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        SecurityControlIds: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchGetSecurityControlsCommand = se_BatchGetSecurityControlsCommand;
const se_BatchGetStandardsControlAssociationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/associations/batchGet";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        StandardsControlAssociationIds: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchGetStandardsControlAssociationsCommand = se_BatchGetStandardsControlAssociationsCommand;
const se_BatchImportFindingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/findings/import";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Findings: (_) => se_BatchImportFindingsRequestFindingList(_, context),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchImportFindingsCommand = se_BatchImportFindingsCommand;
const se_BatchUpdateAutomationRulesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/automationrules/update";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        UpdateAutomationRulesRequestItems: (_) => se_UpdateAutomationRulesRequestItemsList(_, context),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchUpdateAutomationRulesCommand = se_BatchUpdateAutomationRulesCommand;
const se_BatchUpdateFindingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/findings/batchupdate";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Confidence: [],
        Criticality: [],
        FindingIdentifiers: (_) => (0, smithy_client_1._json)(_),
        Note: (_) => (0, smithy_client_1._json)(_),
        RelatedFindings: (_) => (0, smithy_client_1._json)(_),
        Severity: (_) => se_SeverityUpdate(_, context),
        Types: (_) => (0, smithy_client_1._json)(_),
        UserDefinedFields: (_) => (0, smithy_client_1._json)(_),
        VerificationState: [],
        Workflow: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchUpdateFindingsCommand = se_BatchUpdateFindingsCommand;
const se_BatchUpdateStandardsControlAssociationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/associations";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        StandardsControlAssociationUpdates: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchUpdateStandardsControlAssociationsCommand = se_BatchUpdateStandardsControlAssociationsCommand;
const se_CreateActionTargetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/actionTargets";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Description: [],
        Id: [],
        Name: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateActionTargetCommand = se_CreateActionTargetCommand;
const se_CreateAutomationRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/automationrules/create";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Actions: (_) => se_ActionList(_, context),
        Criteria: (_) => se_AutomationRulesFindingFilters(_, context),
        Description: [],
        IsTerminal: [],
        RuleName: [],
        RuleOrder: [],
        RuleStatus: [],
        Tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateAutomationRuleCommand = se_CreateAutomationRuleCommand;
const se_CreateFindingAggregatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/findingAggregator/create";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        RegionLinkingMode: [],
        Regions: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateFindingAggregatorCommand = se_CreateFindingAggregatorCommand;
const se_CreateInsightCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/insights";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Filters: (_) => se_AwsSecurityFindingFilters(_, context),
        GroupByAttribute: [],
        Name: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateInsightCommand = se_CreateInsightCommand;
const se_CreateMembersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/members";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AccountDetails: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateMembersCommand = se_CreateMembersCommand;
const se_DeclineInvitationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/invitations/decline";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AccountIds: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeclineInvitationsCommand = se_DeclineInvitationsCommand;
const se_DeleteActionTargetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/actionTargets/{ActionTargetArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ActionTargetArn", () => input.ActionTargetArn, "{ActionTargetArn+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteActionTargetCommand = se_DeleteActionTargetCommand;
const se_DeleteFindingAggregatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/findingAggregator/delete/{FindingAggregatorArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "FindingAggregatorArn", () => input.FindingAggregatorArn, "{FindingAggregatorArn+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteFindingAggregatorCommand = se_DeleteFindingAggregatorCommand;
const se_DeleteInsightCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/insights/{InsightArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "InsightArn", () => input.InsightArn, "{InsightArn+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteInsightCommand = se_DeleteInsightCommand;
const se_DeleteInvitationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/invitations/delete";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AccountIds: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteInvitationsCommand = se_DeleteInvitationsCommand;
const se_DeleteMembersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/members/delete";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AccountIds: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteMembersCommand = se_DeleteMembersCommand;
const se_DescribeActionTargetsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/actionTargets/get";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        ActionTargetArns: (_) => (0, smithy_client_1._json)(_),
        MaxResults: [],
        NextToken: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeActionTargetsCommand = se_DescribeActionTargetsCommand;
const se_DescribeHubCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/accounts";
    const query = (0, smithy_client_1.map)({
        HubArn: [, input.HubArn],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DescribeHubCommand = se_DescribeHubCommand;
const se_DescribeOrganizationConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/organization/configuration";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeOrganizationConfigurationCommand = se_DescribeOrganizationConfigurationCommand;
const se_DescribeProductsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/products";
    const query = (0, smithy_client_1.map)({
        NextToken: [, input.NextToken],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        ProductArn: [, input.ProductArn],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DescribeProductsCommand = se_DescribeProductsCommand;
const se_DescribeStandardsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/standards";
    const query = (0, smithy_client_1.map)({
        NextToken: [, input.NextToken],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DescribeStandardsCommand = se_DescribeStandardsCommand;
const se_DescribeStandardsControlsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/standards/controls/{StandardsSubscriptionArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "StandardsSubscriptionArn", () => input.StandardsSubscriptionArn, "{StandardsSubscriptionArn+}", true);
    const query = (0, smithy_client_1.map)({
        NextToken: [, input.NextToken],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DescribeStandardsControlsCommand = se_DescribeStandardsControlsCommand;
const se_DisableImportFindingsForProductCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/productSubscriptions/{ProductSubscriptionArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ProductSubscriptionArn", () => input.ProductSubscriptionArn, "{ProductSubscriptionArn+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DisableImportFindingsForProductCommand = se_DisableImportFindingsForProductCommand;
const se_DisableOrganizationAdminAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/organization/admin/disable";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AdminAccountId: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DisableOrganizationAdminAccountCommand = se_DisableOrganizationAdminAccountCommand;
const se_DisableSecurityHubCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/accounts";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DisableSecurityHubCommand = se_DisableSecurityHubCommand;
const se_DisassociateFromAdministratorAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/administrator/disassociate";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DisassociateFromAdministratorAccountCommand = se_DisassociateFromAdministratorAccountCommand;
const se_DisassociateFromMasterAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/master/disassociate";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DisassociateFromMasterAccountCommand = se_DisassociateFromMasterAccountCommand;
const se_DisassociateMembersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/members/disassociate";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AccountIds: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DisassociateMembersCommand = se_DisassociateMembersCommand;
const se_EnableImportFindingsForProductCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/productSubscriptions";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        ProductArn: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_EnableImportFindingsForProductCommand = se_EnableImportFindingsForProductCommand;
const se_EnableOrganizationAdminAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/organization/admin/enable";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AdminAccountId: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_EnableOrganizationAdminAccountCommand = se_EnableOrganizationAdminAccountCommand;
const se_EnableSecurityHubCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/accounts";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        ControlFindingGenerator: [],
        EnableDefaultStandards: [],
        Tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_EnableSecurityHubCommand = se_EnableSecurityHubCommand;
const se_GetAdministratorAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/administrator";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetAdministratorAccountCommand = se_GetAdministratorAccountCommand;
const se_GetEnabledStandardsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/standards/get";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        MaxResults: [],
        NextToken: [],
        StandardsSubscriptionArns: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetEnabledStandardsCommand = se_GetEnabledStandardsCommand;
const se_GetFindingAggregatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/findingAggregator/get/{FindingAggregatorArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "FindingAggregatorArn", () => input.FindingAggregatorArn, "{FindingAggregatorArn+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetFindingAggregatorCommand = se_GetFindingAggregatorCommand;
const se_GetFindingHistoryCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/findingHistory/get";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        EndTime: (_) => _.toISOString().split(".")[0] + "Z",
        FindingIdentifier: (_) => (0, smithy_client_1._json)(_),
        MaxResults: [],
        NextToken: [],
        StartTime: (_) => _.toISOString().split(".")[0] + "Z",
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetFindingHistoryCommand = se_GetFindingHistoryCommand;
const se_GetFindingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/findings";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Filters: (_) => se_AwsSecurityFindingFilters(_, context),
        MaxResults: [],
        NextToken: [],
        SortCriteria: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetFindingsCommand = se_GetFindingsCommand;
const se_GetInsightResultsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/insights/results/{InsightArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "InsightArn", () => input.InsightArn, "{InsightArn+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetInsightResultsCommand = se_GetInsightResultsCommand;
const se_GetInsightsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/insights/get";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        InsightArns: (_) => (0, smithy_client_1._json)(_),
        MaxResults: [],
        NextToken: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetInsightsCommand = se_GetInsightsCommand;
const se_GetInvitationsCountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/invitations/count";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetInvitationsCountCommand = se_GetInvitationsCountCommand;
const se_GetMasterAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/master";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetMasterAccountCommand = se_GetMasterAccountCommand;
const se_GetMembersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/members/get";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AccountIds: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetMembersCommand = se_GetMembersCommand;
const se_InviteMembersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/members/invite";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AccountIds: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_InviteMembersCommand = se_InviteMembersCommand;
const se_ListAutomationRulesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/automationrules/list";
    const query = (0, smithy_client_1.map)({
        NextToken: [, input.NextToken],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListAutomationRulesCommand = se_ListAutomationRulesCommand;
const se_ListEnabledProductsForImportCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/productSubscriptions";
    const query = (0, smithy_client_1.map)({
        NextToken: [, input.NextToken],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListEnabledProductsForImportCommand = se_ListEnabledProductsForImportCommand;
const se_ListFindingAggregatorsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/findingAggregator/list";
    const query = (0, smithy_client_1.map)({
        NextToken: [, input.NextToken],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListFindingAggregatorsCommand = se_ListFindingAggregatorsCommand;
const se_ListInvitationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/invitations";
    const query = (0, smithy_client_1.map)({
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        NextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListInvitationsCommand = se_ListInvitationsCommand;
const se_ListMembersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/members";
    const query = (0, smithy_client_1.map)({
        OnlyAssociated: [() => input.OnlyAssociated !== void 0, () => input.OnlyAssociated.toString()],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        NextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListMembersCommand = se_ListMembersCommand;
const se_ListOrganizationAdminAccountsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/organization/admin";
    const query = (0, smithy_client_1.map)({
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        NextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListOrganizationAdminAccountsCommand = se_ListOrganizationAdminAccountsCommand;
const se_ListSecurityControlDefinitionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/securityControls/definitions";
    const query = (0, smithy_client_1.map)({
        StandardsArn: [, input.StandardsArn],
        NextToken: [, input.NextToken],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListSecurityControlDefinitionsCommand = se_ListSecurityControlDefinitionsCommand;
const se_ListStandardsControlAssociationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/associations";
    const query = (0, smithy_client_1.map)({
        SecurityControlId: [, (0, smithy_client_1.expectNonNull)(input.SecurityControlId, `SecurityControlId`)],
        NextToken: [, input.NextToken],
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListStandardsControlAssociationsCommand = se_ListStandardsControlAssociationsCommand;
const se_ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = (0, smithy_client_1.map)({
        tagKeys: [
            (0, smithy_client_1.expectNonNull)(input.TagKeys, `TagKeys`) != null,
            () => (input.TagKeys || []).map((_entry) => _entry),
        ],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateActionTargetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/actionTargets/{ActionTargetArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ActionTargetArn", () => input.ActionTargetArn, "{ActionTargetArn+}", true);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Description: [],
        Name: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateActionTargetCommand = se_UpdateActionTargetCommand;
const se_UpdateFindingAggregatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/findingAggregator/update";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        FindingAggregatorArn: [],
        RegionLinkingMode: [],
        Regions: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateFindingAggregatorCommand = se_UpdateFindingAggregatorCommand;
const se_UpdateFindingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/findings";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Filters: (_) => se_AwsSecurityFindingFilters(_, context),
        Note: (_) => (0, smithy_client_1._json)(_),
        RecordState: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateFindingsCommand = se_UpdateFindingsCommand;
const se_UpdateInsightCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/insights/{InsightArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "InsightArn", () => input.InsightArn, "{InsightArn+}", true);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Filters: (_) => se_AwsSecurityFindingFilters(_, context),
        GroupByAttribute: [],
        Name: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateInsightCommand = se_UpdateInsightCommand;
const se_UpdateOrganizationConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/organization/configuration";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AutoEnable: [],
        AutoEnableStandards: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateOrganizationConfigurationCommand = se_UpdateOrganizationConfigurationCommand;
const se_UpdateSecurityHubConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/accounts";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        AutoEnableControls: [],
        ControlFindingGenerator: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateSecurityHubConfigurationCommand = se_UpdateSecurityHubConfigurationCommand;
const se_UpdateStandardsControlCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/standards/control/{StandardsControlArn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "StandardsControlArn", () => input.StandardsControlArn, "{StandardsControlArn+}", true);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        ControlStatus: [],
        DisabledReason: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateStandardsControlCommand = se_UpdateStandardsControlCommand;
const de_AcceptAdministratorInvitationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AcceptAdministratorInvitationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AcceptAdministratorInvitationCommand = de_AcceptAdministratorInvitationCommand;
const de_AcceptAdministratorInvitationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AcceptInvitationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AcceptInvitationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AcceptInvitationCommand = de_AcceptInvitationCommand;
const de_AcceptInvitationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchDeleteAutomationRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchDeleteAutomationRulesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ProcessedAutomationRules: smithy_client_1._json,
        UnprocessedAutomationRules: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchDeleteAutomationRulesCommand = de_BatchDeleteAutomationRulesCommand;
const de_BatchDeleteAutomationRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchDisableStandardsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchDisableStandardsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        StandardsSubscriptions: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchDisableStandardsCommand = de_BatchDisableStandardsCommand;
const de_BatchDisableStandardsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchEnableStandardsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchEnableStandardsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        StandardsSubscriptions: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchEnableStandardsCommand = de_BatchEnableStandardsCommand;
const de_BatchEnableStandardsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetAutomationRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchGetAutomationRulesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Rules: (_) => de_AutomationRulesConfigList(_, context),
        UnprocessedAutomationRules: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchGetAutomationRulesCommand = de_BatchGetAutomationRulesCommand;
const de_BatchGetAutomationRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetSecurityControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchGetSecurityControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        SecurityControls: smithy_client_1._json,
        UnprocessedIds: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchGetSecurityControlsCommand = de_BatchGetSecurityControlsCommand;
const de_BatchGetSecurityControlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetStandardsControlAssociationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchGetStandardsControlAssociationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        StandardsControlAssociationDetails: (_) => de_StandardsControlAssociationDetails(_, context),
        UnprocessedAssociations: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchGetStandardsControlAssociationsCommand = de_BatchGetStandardsControlAssociationsCommand;
const de_BatchGetStandardsControlAssociationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchImportFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchImportFindingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        FailedCount: smithy_client_1.expectInt32,
        FailedFindings: smithy_client_1._json,
        SuccessCount: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchImportFindingsCommand = de_BatchImportFindingsCommand;
const de_BatchImportFindingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchUpdateAutomationRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchUpdateAutomationRulesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ProcessedAutomationRules: smithy_client_1._json,
        UnprocessedAutomationRules: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchUpdateAutomationRulesCommand = de_BatchUpdateAutomationRulesCommand;
const de_BatchUpdateAutomationRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchUpdateFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchUpdateFindingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ProcessedFindings: smithy_client_1._json,
        UnprocessedFindings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchUpdateFindingsCommand = de_BatchUpdateFindingsCommand;
const de_BatchUpdateFindingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchUpdateStandardsControlAssociationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchUpdateStandardsControlAssociationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        UnprocessedAssociationUpdates: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchUpdateStandardsControlAssociationsCommand = de_BatchUpdateStandardsControlAssociationsCommand;
const de_BatchUpdateStandardsControlAssociationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateActionTargetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateActionTargetCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ActionTargetArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateActionTargetCommand = de_CreateActionTargetCommand;
const de_CreateActionTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceConflictException":
        case "com.amazonaws.securityhub#ResourceConflictException":
            throw await de_ResourceConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateAutomationRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAutomationRuleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        RuleArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateAutomationRuleCommand = de_CreateAutomationRuleCommand;
const de_CreateAutomationRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateFindingAggregatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateFindingAggregatorCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        FindingAggregationRegion: smithy_client_1.expectString,
        FindingAggregatorArn: smithy_client_1.expectString,
        RegionLinkingMode: smithy_client_1.expectString,
        Regions: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateFindingAggregatorCommand = de_CreateFindingAggregatorCommand;
const de_CreateFindingAggregatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateInsightCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateInsightCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        InsightArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateInsightCommand = de_CreateInsightCommand;
const de_CreateInsightCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceConflictException":
        case "com.amazonaws.securityhub#ResourceConflictException":
            throw await de_ResourceConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateMembersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateMembersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        UnprocessedAccounts: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateMembersCommand = de_CreateMembersCommand;
const de_CreateMembersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceConflictException":
        case "com.amazonaws.securityhub#ResourceConflictException":
            throw await de_ResourceConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeclineInvitationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeclineInvitationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        UnprocessedAccounts: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeclineInvitationsCommand = de_DeclineInvitationsCommand;
const de_DeclineInvitationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteActionTargetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteActionTargetCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ActionTargetArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeleteActionTargetCommand = de_DeleteActionTargetCommand;
const de_DeleteActionTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteFindingAggregatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteFindingAggregatorCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteFindingAggregatorCommand = de_DeleteFindingAggregatorCommand;
const de_DeleteFindingAggregatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteInsightCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteInsightCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        InsightArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeleteInsightCommand = de_DeleteInsightCommand;
const de_DeleteInsightCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteInvitationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteInvitationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        UnprocessedAccounts: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeleteInvitationsCommand = de_DeleteInvitationsCommand;
const de_DeleteInvitationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteMembersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteMembersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        UnprocessedAccounts: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeleteMembersCommand = de_DeleteMembersCommand;
const de_DeleteMembersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeActionTargetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeActionTargetsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ActionTargets: smithy_client_1._json,
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeActionTargetsCommand = de_DescribeActionTargetsCommand;
const de_DescribeActionTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeHubCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeHubCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AutoEnableControls: smithy_client_1.expectBoolean,
        ControlFindingGenerator: smithy_client_1.expectString,
        HubArn: smithy_client_1.expectString,
        SubscribedAt: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeHubCommand = de_DescribeHubCommand;
const de_DescribeHubCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeOrganizationConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeOrganizationConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AutoEnable: smithy_client_1.expectBoolean,
        AutoEnableStandards: smithy_client_1.expectString,
        MemberAccountLimitReached: smithy_client_1.expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeOrganizationConfigurationCommand = de_DescribeOrganizationConfigurationCommand;
const de_DescribeOrganizationConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeProductsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeProductsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        Products: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeProductsCommand = de_DescribeProductsCommand;
const de_DescribeProductsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeStandardsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeStandardsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        Standards: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeStandardsCommand = de_DescribeStandardsCommand;
const de_DescribeStandardsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeStandardsControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeStandardsControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Controls: (_) => de_StandardsControls(_, context),
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeStandardsControlsCommand = de_DescribeStandardsControlsCommand;
const de_DescribeStandardsControlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisableImportFindingsForProductCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisableImportFindingsForProductCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DisableImportFindingsForProductCommand = de_DisableImportFindingsForProductCommand;
const de_DisableImportFindingsForProductCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisableOrganizationAdminAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisableOrganizationAdminAccountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DisableOrganizationAdminAccountCommand = de_DisableOrganizationAdminAccountCommand;
const de_DisableOrganizationAdminAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisableSecurityHubCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisableSecurityHubCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DisableSecurityHubCommand = de_DisableSecurityHubCommand;
const de_DisableSecurityHubCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisassociateFromAdministratorAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisassociateFromAdministratorAccountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DisassociateFromAdministratorAccountCommand = de_DisassociateFromAdministratorAccountCommand;
const de_DisassociateFromAdministratorAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisassociateFromMasterAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisassociateFromMasterAccountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DisassociateFromMasterAccountCommand = de_DisassociateFromMasterAccountCommand;
const de_DisassociateFromMasterAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisassociateMembersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisassociateMembersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DisassociateMembersCommand = de_DisassociateMembersCommand;
const de_DisassociateMembersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EnableImportFindingsForProductCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_EnableImportFindingsForProductCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ProductSubscriptionArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_EnableImportFindingsForProductCommand = de_EnableImportFindingsForProductCommand;
const de_EnableImportFindingsForProductCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceConflictException":
        case "com.amazonaws.securityhub#ResourceConflictException":
            throw await de_ResourceConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EnableOrganizationAdminAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_EnableOrganizationAdminAccountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_EnableOrganizationAdminAccountCommand = de_EnableOrganizationAdminAccountCommand;
const de_EnableOrganizationAdminAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EnableSecurityHubCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_EnableSecurityHubCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_EnableSecurityHubCommand = de_EnableSecurityHubCommand;
const de_EnableSecurityHubCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceConflictException":
        case "com.amazonaws.securityhub#ResourceConflictException":
            throw await de_ResourceConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetAdministratorAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAdministratorAccountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Administrator: (_) => de_Invitation(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetAdministratorAccountCommand = de_GetAdministratorAccountCommand;
const de_GetAdministratorAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetEnabledStandardsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetEnabledStandardsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        StandardsSubscriptions: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetEnabledStandardsCommand = de_GetEnabledStandardsCommand;
const de_GetEnabledStandardsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetFindingAggregatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFindingAggregatorCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        FindingAggregationRegion: smithy_client_1.expectString,
        FindingAggregatorArn: smithy_client_1.expectString,
        RegionLinkingMode: smithy_client_1.expectString,
        Regions: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetFindingAggregatorCommand = de_GetFindingAggregatorCommand;
const de_GetFindingAggregatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetFindingHistoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFindingHistoryCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        Records: (_) => de_FindingHistoryRecordList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetFindingHistoryCommand = de_GetFindingHistoryCommand;
const de_GetFindingHistoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFindingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Findings: (_) => de_AwsSecurityFindingList(_, context),
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetFindingsCommand = de_GetFindingsCommand;
const de_GetFindingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetInsightResultsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetInsightResultsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        InsightResults: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetInsightResultsCommand = de_GetInsightResultsCommand;
const de_GetInsightResultsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetInsightsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetInsightsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Insights: (_) => de_InsightList(_, context),
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetInsightsCommand = de_GetInsightsCommand;
const de_GetInsightsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetInvitationsCountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetInvitationsCountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        InvitationsCount: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetInvitationsCountCommand = de_GetInvitationsCountCommand;
const de_GetInvitationsCountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetMasterAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMasterAccountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Master: (_) => de_Invitation(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetMasterAccountCommand = de_GetMasterAccountCommand;
const de_GetMasterAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetMembersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMembersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Members: (_) => de_MemberList(_, context),
        UnprocessedAccounts: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetMembersCommand = de_GetMembersCommand;
const de_GetMembersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_InviteMembersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_InviteMembersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        UnprocessedAccounts: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_InviteMembersCommand = de_InviteMembersCommand;
const de_InviteMembersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAutomationRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAutomationRulesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AutomationRulesMetadata: (_) => de_AutomationRulesMetadataList(_, context),
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAutomationRulesCommand = de_ListAutomationRulesCommand;
const de_ListAutomationRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListEnabledProductsForImportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListEnabledProductsForImportCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        ProductSubscriptions: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListEnabledProductsForImportCommand = de_ListEnabledProductsForImportCommand;
const de_ListEnabledProductsForImportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListFindingAggregatorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFindingAggregatorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        FindingAggregators: smithy_client_1._json,
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListFindingAggregatorsCommand = de_ListFindingAggregatorsCommand;
const de_ListFindingAggregatorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListInvitationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListInvitationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Invitations: (_) => de_InvitationList(_, context),
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListInvitationsCommand = de_ListInvitationsCommand;
const de_ListInvitationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListMembersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListMembersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Members: (_) => de_MemberList(_, context),
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListMembersCommand = de_ListMembersCommand;
const de_ListMembersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListOrganizationAdminAccountsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOrganizationAdminAccountsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AdminAccounts: smithy_client_1._json,
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListOrganizationAdminAccountsCommand = de_ListOrganizationAdminAccountsCommand;
const de_ListOrganizationAdminAccountsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListSecurityControlDefinitionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListSecurityControlDefinitionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        SecurityControlDefinitions: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListSecurityControlDefinitionsCommand = de_ListSecurityControlDefinitionsCommand;
const de_ListSecurityControlDefinitionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListStandardsControlAssociationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListStandardsControlAssociationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        StandardsControlAssociationSummaries: (_) => de_StandardsControlAssociationSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListStandardsControlAssociationsCommand = de_ListStandardsControlAssociationsCommand;
const de_ListStandardsControlAssociationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateActionTargetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateActionTargetCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateActionTargetCommand = de_UpdateActionTargetCommand;
const de_UpdateActionTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateFindingAggregatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFindingAggregatorCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        FindingAggregationRegion: smithy_client_1.expectString,
        FindingAggregatorArn: smithy_client_1.expectString,
        RegionLinkingMode: smithy_client_1.expectString,
        Regions: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateFindingAggregatorCommand = de_UpdateFindingAggregatorCommand;
const de_UpdateFindingAggregatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.securityhub#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFindingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateFindingsCommand = de_UpdateFindingsCommand;
const de_UpdateFindingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateInsightCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateInsightCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateInsightCommand = de_UpdateInsightCommand;
const de_UpdateInsightCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateOrganizationConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateOrganizationConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateOrganizationConfigurationCommand = de_UpdateOrganizationConfigurationCommand;
const de_UpdateOrganizationConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateSecurityHubConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateSecurityHubConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateSecurityHubConfigurationCommand = de_UpdateSecurityHubConfigurationCommand;
const de_UpdateSecurityHubConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.securityhub#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateStandardsControlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStandardsControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateStandardsControlCommand = de_UpdateStandardsControlCommand;
const de_UpdateStandardsControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.securityhub#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidAccessException":
        case "com.amazonaws.securityhub#InvalidAccessException":
            throw await de_InvalidAccessExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.securityhub#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.securityhub#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(SecurityHubServiceException_1.SecurityHubServiceException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Code: smithy_client_1.expectString,
        Message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InternalExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Code: smithy_client_1.expectString,
        Message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidAccessExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Code: smithy_client_1.expectString,
        Message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidAccessException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidInputExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Code: smithy_client_1.expectString,
        Message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidInputException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Code: smithy_client_1.expectString,
        Message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Code: smithy_client_1.expectString,
        Message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_2_1.ResourceConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Code: smithy_client_1.expectString,
        Message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const se_Action = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        ActionType: [],
        AwsApiCallAction: (_) => se_AwsApiCallAction(_, context),
        DnsRequestAction: smithy_client_1._json,
        NetworkConnectionAction: (_) => se_NetworkConnectionAction(_, context),
        PortProbeAction: (_) => se_PortProbeAction(_, context),
    });
};
const se_ActionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AutomationRulesAction(entry, context);
    });
};
const se_ActionRemoteIpDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        City: smithy_client_1._json,
        Country: smithy_client_1._json,
        GeoLocation: (_) => se_GeoLocation(_, context),
        IpAddressV4: [],
        Organization: smithy_client_1._json,
    });
};
const se_AutomationRulesAction = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        FindingFieldsUpdate: (_) => se_AutomationRulesFindingFieldsUpdate(_, context),
        Type: [],
    });
};
const se_AutomationRulesFindingFieldsUpdate = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Confidence: [],
        Criticality: [],
        Note: smithy_client_1._json,
        RelatedFindings: smithy_client_1._json,
        Severity: (_) => se_SeverityUpdate(_, context),
        Types: smithy_client_1._json,
        UserDefinedFields: smithy_client_1._json,
        VerificationState: [],
        Workflow: smithy_client_1._json,
    });
};
const se_AutomationRulesFindingFilters = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AwsAccountId: smithy_client_1._json,
        CompanyName: smithy_client_1._json,
        ComplianceAssociatedStandardsId: smithy_client_1._json,
        ComplianceSecurityControlId: smithy_client_1._json,
        ComplianceStatus: smithy_client_1._json,
        Confidence: (_) => se_NumberFilterList(_, context),
        CreatedAt: smithy_client_1._json,
        Criticality: (_) => se_NumberFilterList(_, context),
        Description: smithy_client_1._json,
        FirstObservedAt: smithy_client_1._json,
        GeneratorId: smithy_client_1._json,
        Id: smithy_client_1._json,
        LastObservedAt: smithy_client_1._json,
        NoteText: smithy_client_1._json,
        NoteUpdatedAt: smithy_client_1._json,
        NoteUpdatedBy: smithy_client_1._json,
        ProductArn: smithy_client_1._json,
        ProductName: smithy_client_1._json,
        RecordState: smithy_client_1._json,
        RelatedFindingsId: smithy_client_1._json,
        RelatedFindingsProductArn: smithy_client_1._json,
        ResourceDetailsOther: smithy_client_1._json,
        ResourceId: smithy_client_1._json,
        ResourcePartition: smithy_client_1._json,
        ResourceRegion: smithy_client_1._json,
        ResourceTags: smithy_client_1._json,
        ResourceType: smithy_client_1._json,
        SeverityLabel: smithy_client_1._json,
        SourceUrl: smithy_client_1._json,
        Title: smithy_client_1._json,
        Type: smithy_client_1._json,
        UpdatedAt: smithy_client_1._json,
        UserDefinedFields: smithy_client_1._json,
        VerificationState: smithy_client_1._json,
        WorkflowStatus: smithy_client_1._json,
    });
};
const se_AwsApiCallAction = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AffectedResources: smithy_client_1._json,
        Api: [],
        CallerType: [],
        DomainDetails: smithy_client_1._json,
        FirstSeen: [],
        LastSeen: [],
        RemoteIpDetails: (_) => se_ActionRemoteIpDetails(_, context),
        ServiceName: [],
    });
};
const se_AwsApiGatewayCanarySettings = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DeploymentId: [],
        PercentTraffic: smithy_client_1.serializeFloat,
        StageVariableOverrides: smithy_client_1._json,
        UseStageCache: [],
    });
};
const se_AwsApiGatewayMethodSettings = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        CacheDataEncrypted: [],
        CacheTtlInSeconds: [],
        CachingEnabled: [],
        DataTraceEnabled: [],
        HttpMethod: [],
        LoggingLevel: [],
        MetricsEnabled: [],
        RequireAuthorizationForCacheControl: [],
        ResourcePath: [],
        ThrottlingBurstLimit: [],
        ThrottlingRateLimit: smithy_client_1.serializeFloat,
        UnauthorizedCacheControlHeaderStrategy: [],
    });
};
const se_AwsApiGatewayMethodSettingsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AwsApiGatewayMethodSettings(entry, context);
    });
};
const se_AwsApiGatewayStageDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AccessLogSettings: smithy_client_1._json,
        CacheClusterEnabled: [],
        CacheClusterSize: [],
        CacheClusterStatus: [],
        CanarySettings: (_) => se_AwsApiGatewayCanarySettings(_, context),
        ClientCertificateId: [],
        CreatedDate: [],
        DeploymentId: [],
        Description: [],
        DocumentationVersion: [],
        LastUpdatedDate: [],
        MethodSettings: (_) => se_AwsApiGatewayMethodSettingsList(_, context),
        StageName: [],
        TracingEnabled: [],
        Variables: smithy_client_1._json,
        WebAclArn: [],
    });
};
const se_AwsApiGatewayV2RouteSettings = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DataTraceEnabled: [],
        DetailedMetricsEnabled: [],
        LoggingLevel: [],
        ThrottlingBurstLimit: [],
        ThrottlingRateLimit: smithy_client_1.serializeFloat,
    });
};
const se_AwsApiGatewayV2StageDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AccessLogSettings: smithy_client_1._json,
        ApiGatewayManaged: [],
        AutoDeploy: [],
        ClientCertificateId: [],
        CreatedDate: [],
        DefaultRouteSettings: (_) => se_AwsApiGatewayV2RouteSettings(_, context),
        DeploymentId: [],
        Description: [],
        LastDeploymentStatusMessage: [],
        LastUpdatedDate: [],
        RouteSettings: (_) => se_AwsApiGatewayV2RouteSettings(_, context),
        StageName: [],
        StageVariables: smithy_client_1._json,
    });
};
const se_AwsCloudWatchAlarmDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        ActionsEnabled: [],
        AlarmActions: smithy_client_1._json,
        AlarmArn: [],
        AlarmConfigurationUpdatedTimestamp: [],
        AlarmDescription: [],
        AlarmName: [],
        ComparisonOperator: [],
        DatapointsToAlarm: [],
        Dimensions: smithy_client_1._json,
        EvaluateLowSampleCountPercentile: [],
        EvaluationPeriods: [],
        ExtendedStatistic: [],
        InsufficientDataActions: smithy_client_1._json,
        MetricName: [],
        Namespace: [],
        OkActions: smithy_client_1._json,
        Period: [],
        Statistic: [],
        Threshold: smithy_client_1.serializeFloat,
        ThresholdMetricId: [],
        TreatMissingData: [],
        Unit: [],
    });
};
const se_AwsEc2LaunchTemplateDataDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        BlockDeviceMappingSet: smithy_client_1._json,
        CapacityReservationSpecification: smithy_client_1._json,
        CpuOptions: smithy_client_1._json,
        CreditSpecification: smithy_client_1._json,
        DisableApiStop: [],
        DisableApiTermination: [],
        EbsOptimized: [],
        ElasticGpuSpecificationSet: smithy_client_1._json,
        ElasticInferenceAcceleratorSet: smithy_client_1._json,
        EnclaveOptions: smithy_client_1._json,
        HibernationOptions: smithy_client_1._json,
        IamInstanceProfile: smithy_client_1._json,
        ImageId: [],
        InstanceInitiatedShutdownBehavior: [],
        InstanceMarketOptions: smithy_client_1._json,
        InstanceRequirements: (_) => se_AwsEc2LaunchTemplateDataInstanceRequirementsDetails(_, context),
        InstanceType: [],
        KernelId: [],
        KeyName: [],
        LicenseSet: smithy_client_1._json,
        MaintenanceOptions: smithy_client_1._json,
        MetadataOptions: smithy_client_1._json,
        Monitoring: smithy_client_1._json,
        NetworkInterfaceSet: smithy_client_1._json,
        Placement: smithy_client_1._json,
        PrivateDnsNameOptions: smithy_client_1._json,
        RamDiskId: [],
        SecurityGroupIdSet: smithy_client_1._json,
        SecurityGroupSet: smithy_client_1._json,
        UserData: [],
    });
};
const se_AwsEc2LaunchTemplateDataInstanceRequirementsDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AcceleratorCount: smithy_client_1._json,
        AcceleratorManufacturers: smithy_client_1._json,
        AcceleratorNames: smithy_client_1._json,
        AcceleratorTotalMemoryMiB: smithy_client_1._json,
        AcceleratorTypes: smithy_client_1._json,
        BareMetal: [],
        BaselineEbsBandwidthMbps: smithy_client_1._json,
        BurstablePerformance: [],
        CpuManufacturers: smithy_client_1._json,
        ExcludedInstanceTypes: smithy_client_1._json,
        InstanceGenerations: smithy_client_1._json,
        LocalStorage: [],
        LocalStorageTypes: smithy_client_1._json,
        MemoryGiBPerVCpu: (_) => se_AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails(_, context),
        MemoryMiB: smithy_client_1._json,
        NetworkInterfaceCount: smithy_client_1._json,
        OnDemandMaxPricePercentageOverLowestPrice: [],
        RequireHibernateSupport: [],
        SpotMaxPricePercentageOverLowestPrice: [],
        TotalLocalStorageGB: (_) => se_AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails(_, context),
        VCpuCount: smithy_client_1._json,
    });
};
const se_AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Max: smithy_client_1.serializeFloat,
        Min: smithy_client_1.serializeFloat,
    });
};
const se_AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Max: smithy_client_1.serializeFloat,
        Min: smithy_client_1.serializeFloat,
    });
};
const se_AwsEc2LaunchTemplateDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DefaultVersionNumber: [],
        Id: [],
        LatestVersionNumber: [],
        LaunchTemplateData: (_) => se_AwsEc2LaunchTemplateDataDetails(_, context),
        LaunchTemplateName: [],
    });
};
const se_AwsKmsKeyDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AWSAccountId: [],
        CreationDate: smithy_client_1.serializeFloat,
        Description: [],
        KeyId: [],
        KeyManager: [],
        KeyRotationStatus: [],
        KeyState: [],
        Origin: [],
    });
};
const se_AwsNetworkFirewallRuleGroupDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Capacity: [],
        Description: [],
        RuleGroup: smithy_client_1._json,
        RuleGroupArn: [],
        RuleGroupId: [],
        RuleGroupName: [],
        Type: [],
    });
};
const se_AwsRedshiftClusterDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AllowVersionUpgrade: [],
        AutomatedSnapshotRetentionPeriod: [],
        AvailabilityZone: [],
        ClusterAvailabilityStatus: [],
        ClusterCreateTime: [],
        ClusterIdentifier: [],
        ClusterNodes: smithy_client_1._json,
        ClusterParameterGroups: smithy_client_1._json,
        ClusterPublicKey: [],
        ClusterRevisionNumber: [],
        ClusterSecurityGroups: smithy_client_1._json,
        ClusterSnapshotCopyStatus: smithy_client_1._json,
        ClusterStatus: [],
        ClusterSubnetGroupName: [],
        ClusterVersion: [],
        DBName: [],
        DeferredMaintenanceWindows: smithy_client_1._json,
        ElasticIpStatus: smithy_client_1._json,
        ElasticResizeNumberOfNodeOptions: [],
        Encrypted: [],
        Endpoint: smithy_client_1._json,
        EnhancedVpcRouting: [],
        ExpectedNextSnapshotScheduleTime: [],
        ExpectedNextSnapshotScheduleTimeStatus: [],
        HsmStatus: smithy_client_1._json,
        IamRoles: smithy_client_1._json,
        KmsKeyId: [],
        LoggingStatus: smithy_client_1._json,
        MaintenanceTrackName: [],
        ManualSnapshotRetentionPeriod: [],
        MasterUsername: [],
        NextMaintenanceWindowStartTime: [],
        NodeType: [],
        NumberOfNodes: [],
        PendingActions: smithy_client_1._json,
        PendingModifiedValues: smithy_client_1._json,
        PreferredMaintenanceWindow: [],
        PubliclyAccessible: [],
        ResizeInfo: smithy_client_1._json,
        RestoreStatus: (_) => se_AwsRedshiftClusterRestoreStatus(_, context),
        SnapshotScheduleIdentifier: [],
        SnapshotScheduleState: [],
        VpcId: [],
        VpcSecurityGroups: smithy_client_1._json,
    });
};
const se_AwsRedshiftClusterRestoreStatus = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        CurrentRestoreRateInMegaBytesPerSecond: smithy_client_1.serializeFloat,
        ElapsedTimeInSeconds: [],
        EstimatedTimeToCompletionInSeconds: [],
        ProgressInMegaBytes: [],
        SnapshotSizeInMegaBytes: [],
        Status: [],
    });
};
const se_AwsSecurityFinding = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Action: (_) => se_Action(_, context),
        AwsAccountId: [],
        CompanyName: [],
        Compliance: smithy_client_1._json,
        Confidence: [],
        CreatedAt: [],
        Criticality: [],
        Description: [],
        FindingProviderFields: smithy_client_1._json,
        FirstObservedAt: [],
        GeneratorId: [],
        Id: [],
        LastObservedAt: [],
        Malware: smithy_client_1._json,
        Network: smithy_client_1._json,
        NetworkPath: smithy_client_1._json,
        Note: smithy_client_1._json,
        PatchSummary: smithy_client_1._json,
        Process: smithy_client_1._json,
        ProductArn: [],
        ProductFields: smithy_client_1._json,
        ProductName: [],
        RecordState: [],
        Region: [],
        RelatedFindings: smithy_client_1._json,
        Remediation: smithy_client_1._json,
        Resources: (_) => se_ResourceList(_, context),
        Sample: [],
        SchemaVersion: [],
        Severity: (_) => se_Severity(_, context),
        SourceUrl: [],
        ThreatIntelIndicators: smithy_client_1._json,
        Threats: smithy_client_1._json,
        Title: [],
        Types: smithy_client_1._json,
        UpdatedAt: [],
        UserDefinedFields: smithy_client_1._json,
        VerificationState: [],
        Vulnerabilities: (_) => se_VulnerabilityList(_, context),
        Workflow: smithy_client_1._json,
        WorkflowState: [],
    });
};
const se_AwsSecurityFindingFilters = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AwsAccountId: smithy_client_1._json,
        CompanyName: smithy_client_1._json,
        ComplianceAssociatedStandardsId: smithy_client_1._json,
        ComplianceSecurityControlId: smithy_client_1._json,
        ComplianceStatus: smithy_client_1._json,
        Confidence: (_) => se_NumberFilterList(_, context),
        CreatedAt: smithy_client_1._json,
        Criticality: (_) => se_NumberFilterList(_, context),
        Description: smithy_client_1._json,
        FindingProviderFieldsConfidence: (_) => se_NumberFilterList(_, context),
        FindingProviderFieldsCriticality: (_) => se_NumberFilterList(_, context),
        FindingProviderFieldsRelatedFindingsId: smithy_client_1._json,
        FindingProviderFieldsRelatedFindingsProductArn: smithy_client_1._json,
        FindingProviderFieldsSeverityLabel: smithy_client_1._json,
        FindingProviderFieldsSeverityOriginal: smithy_client_1._json,
        FindingProviderFieldsTypes: smithy_client_1._json,
        FirstObservedAt: smithy_client_1._json,
        GeneratorId: smithy_client_1._json,
        Id: smithy_client_1._json,
        Keyword: smithy_client_1._json,
        LastObservedAt: smithy_client_1._json,
        MalwareName: smithy_client_1._json,
        MalwarePath: smithy_client_1._json,
        MalwareState: smithy_client_1._json,
        MalwareType: smithy_client_1._json,
        NetworkDestinationDomain: smithy_client_1._json,
        NetworkDestinationIpV4: smithy_client_1._json,
        NetworkDestinationIpV6: smithy_client_1._json,
        NetworkDestinationPort: (_) => se_NumberFilterList(_, context),
        NetworkDirection: smithy_client_1._json,
        NetworkProtocol: smithy_client_1._json,
        NetworkSourceDomain: smithy_client_1._json,
        NetworkSourceIpV4: smithy_client_1._json,
        NetworkSourceIpV6: smithy_client_1._json,
        NetworkSourceMac: smithy_client_1._json,
        NetworkSourcePort: (_) => se_NumberFilterList(_, context),
        NoteText: smithy_client_1._json,
        NoteUpdatedAt: smithy_client_1._json,
        NoteUpdatedBy: smithy_client_1._json,
        ProcessLaunchedAt: smithy_client_1._json,
        ProcessName: smithy_client_1._json,
        ProcessParentPid: (_) => se_NumberFilterList(_, context),
        ProcessPath: smithy_client_1._json,
        ProcessPid: (_) => se_NumberFilterList(_, context),
        ProcessTerminatedAt: smithy_client_1._json,
        ProductArn: smithy_client_1._json,
        ProductFields: smithy_client_1._json,
        ProductName: smithy_client_1._json,
        RecommendationText: smithy_client_1._json,
        RecordState: smithy_client_1._json,
        Region: smithy_client_1._json,
        RelatedFindingsId: smithy_client_1._json,
        RelatedFindingsProductArn: smithy_client_1._json,
        ResourceAwsEc2InstanceIamInstanceProfileArn: smithy_client_1._json,
        ResourceAwsEc2InstanceImageId: smithy_client_1._json,
        ResourceAwsEc2InstanceIpV4Addresses: smithy_client_1._json,
        ResourceAwsEc2InstanceIpV6Addresses: smithy_client_1._json,
        ResourceAwsEc2InstanceKeyName: smithy_client_1._json,
        ResourceAwsEc2InstanceLaunchedAt: smithy_client_1._json,
        ResourceAwsEc2InstanceSubnetId: smithy_client_1._json,
        ResourceAwsEc2InstanceType: smithy_client_1._json,
        ResourceAwsEc2InstanceVpcId: smithy_client_1._json,
        ResourceAwsIamAccessKeyCreatedAt: smithy_client_1._json,
        ResourceAwsIamAccessKeyPrincipalName: smithy_client_1._json,
        ResourceAwsIamAccessKeyStatus: smithy_client_1._json,
        ResourceAwsIamAccessKeyUserName: smithy_client_1._json,
        ResourceAwsIamUserUserName: smithy_client_1._json,
        ResourceAwsS3BucketOwnerId: smithy_client_1._json,
        ResourceAwsS3BucketOwnerName: smithy_client_1._json,
        ResourceContainerImageId: smithy_client_1._json,
        ResourceContainerImageName: smithy_client_1._json,
        ResourceContainerLaunchedAt: smithy_client_1._json,
        ResourceContainerName: smithy_client_1._json,
        ResourceDetailsOther: smithy_client_1._json,
        ResourceId: smithy_client_1._json,
        ResourcePartition: smithy_client_1._json,
        ResourceRegion: smithy_client_1._json,
        ResourceTags: smithy_client_1._json,
        ResourceType: smithy_client_1._json,
        Sample: smithy_client_1._json,
        SeverityLabel: smithy_client_1._json,
        SeverityNormalized: (_) => se_NumberFilterList(_, context),
        SeverityProduct: (_) => se_NumberFilterList(_, context),
        SourceUrl: smithy_client_1._json,
        ThreatIntelIndicatorCategory: smithy_client_1._json,
        ThreatIntelIndicatorLastObservedAt: smithy_client_1._json,
        ThreatIntelIndicatorSource: smithy_client_1._json,
        ThreatIntelIndicatorSourceUrl: smithy_client_1._json,
        ThreatIntelIndicatorType: smithy_client_1._json,
        ThreatIntelIndicatorValue: smithy_client_1._json,
        Title: smithy_client_1._json,
        Type: smithy_client_1._json,
        UpdatedAt: smithy_client_1._json,
        UserDefinedFields: smithy_client_1._json,
        VerificationState: smithy_client_1._json,
        WorkflowState: smithy_client_1._json,
        WorkflowStatus: smithy_client_1._json,
    });
};
const se_BatchImportFindingsRequestFindingList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AwsSecurityFinding(entry, context);
    });
};
const se_Cvss = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Adjustments: smithy_client_1._json,
        BaseScore: smithy_client_1.serializeFloat,
        BaseVector: [],
        Source: [],
        Version: [],
    });
};
const se_CvssList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Cvss(entry, context);
    });
};
const se_GeoLocation = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Lat: smithy_client_1.serializeFloat,
        Lon: smithy_client_1.serializeFloat,
    });
};
const se_NetworkConnectionAction = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Blocked: [],
        ConnectionDirection: [],
        LocalPortDetails: smithy_client_1._json,
        Protocol: [],
        RemoteIpDetails: (_) => se_ActionRemoteIpDetails(_, context),
        RemotePortDetails: smithy_client_1._json,
    });
};
const se_NumberFilter = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Eq: smithy_client_1.serializeFloat,
        Gte: smithy_client_1.serializeFloat,
        Lte: smithy_client_1.serializeFloat,
    });
};
const se_NumberFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_NumberFilter(entry, context);
    });
};
const se_PortProbeAction = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Blocked: [],
        PortProbeDetails: (_) => se_PortProbeDetailList(_, context),
    });
};
const se_PortProbeDetail = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        LocalIpDetails: smithy_client_1._json,
        LocalPortDetails: smithy_client_1._json,
        RemoteIpDetails: (_) => se_ActionRemoteIpDetails(_, context),
    });
};
const se_PortProbeDetailList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PortProbeDetail(entry, context);
    });
};
const se_Resource = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DataClassification: smithy_client_1._json,
        Details: (_) => se_ResourceDetails(_, context),
        Id: [],
        Partition: [],
        Region: [],
        ResourceRole: [],
        Tags: smithy_client_1._json,
        Type: [],
    });
};
const se_ResourceDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AwsAmazonMqBroker: smithy_client_1._json,
        AwsApiGatewayRestApi: smithy_client_1._json,
        AwsApiGatewayStage: (_) => se_AwsApiGatewayStageDetails(_, context),
        AwsApiGatewayV2Api: smithy_client_1._json,
        AwsApiGatewayV2Stage: (_) => se_AwsApiGatewayV2StageDetails(_, context),
        AwsAppSyncGraphQlApi: smithy_client_1._json,
        AwsAthenaWorkGroup: smithy_client_1._json,
        AwsAutoScalingAutoScalingGroup: smithy_client_1._json,
        AwsAutoScalingLaunchConfiguration: smithy_client_1._json,
        AwsBackupBackupPlan: smithy_client_1._json,
        AwsBackupBackupVault: smithy_client_1._json,
        AwsBackupRecoveryPoint: smithy_client_1._json,
        AwsCertificateManagerCertificate: smithy_client_1._json,
        AwsCloudFormationStack: smithy_client_1._json,
        AwsCloudFrontDistribution: smithy_client_1._json,
        AwsCloudTrailTrail: smithy_client_1._json,
        AwsCloudWatchAlarm: (_) => se_AwsCloudWatchAlarmDetails(_, context),
        AwsCodeBuildProject: smithy_client_1._json,
        AwsDynamoDbTable: smithy_client_1._json,
        AwsEc2Eip: smithy_client_1._json,
        AwsEc2Instance: smithy_client_1._json,
        AwsEc2LaunchTemplate: (_) => se_AwsEc2LaunchTemplateDetails(_, context),
        AwsEc2NetworkAcl: smithy_client_1._json,
        AwsEc2NetworkInterface: smithy_client_1._json,
        AwsEc2RouteTable: smithy_client_1._json,
        AwsEc2SecurityGroup: smithy_client_1._json,
        AwsEc2Subnet: smithy_client_1._json,
        AwsEc2TransitGateway: smithy_client_1._json,
        AwsEc2Volume: smithy_client_1._json,
        AwsEc2Vpc: smithy_client_1._json,
        AwsEc2VpcEndpointService: smithy_client_1._json,
        AwsEc2VpcPeeringConnection: smithy_client_1._json,
        AwsEc2VpnConnection: smithy_client_1._json,
        AwsEcrContainerImage: smithy_client_1._json,
        AwsEcrRepository: smithy_client_1._json,
        AwsEcsCluster: smithy_client_1._json,
        AwsEcsContainer: smithy_client_1._json,
        AwsEcsService: smithy_client_1._json,
        AwsEcsTask: smithy_client_1._json,
        AwsEcsTaskDefinition: smithy_client_1._json,
        AwsEfsAccessPoint: smithy_client_1._json,
        AwsEksCluster: smithy_client_1._json,
        AwsElasticBeanstalkEnvironment: smithy_client_1._json,
        AwsElasticsearchDomain: smithy_client_1._json,
        AwsElbLoadBalancer: smithy_client_1._json,
        AwsElbv2LoadBalancer: smithy_client_1._json,
        AwsEventSchemasRegistry: smithy_client_1._json,
        AwsGuardDutyDetector: smithy_client_1._json,
        AwsIamAccessKey: smithy_client_1._json,
        AwsIamGroup: smithy_client_1._json,
        AwsIamPolicy: smithy_client_1._json,
        AwsIamRole: smithy_client_1._json,
        AwsIamUser: smithy_client_1._json,
        AwsKinesisStream: smithy_client_1._json,
        AwsKmsKey: (_) => se_AwsKmsKeyDetails(_, context),
        AwsLambdaFunction: smithy_client_1._json,
        AwsLambdaLayerVersion: smithy_client_1._json,
        AwsNetworkFirewallFirewall: smithy_client_1._json,
        AwsNetworkFirewallFirewallPolicy: smithy_client_1._json,
        AwsNetworkFirewallRuleGroup: (_) => se_AwsNetworkFirewallRuleGroupDetails(_, context),
        AwsOpenSearchServiceDomain: smithy_client_1._json,
        AwsRdsDbCluster: smithy_client_1._json,
        AwsRdsDbClusterSnapshot: smithy_client_1._json,
        AwsRdsDbInstance: smithy_client_1._json,
        AwsRdsDbSecurityGroup: smithy_client_1._json,
        AwsRdsDbSnapshot: smithy_client_1._json,
        AwsRdsEventSubscription: smithy_client_1._json,
        AwsRedshiftCluster: (_) => se_AwsRedshiftClusterDetails(_, context),
        AwsS3AccountPublicAccessBlock: smithy_client_1._json,
        AwsS3Bucket: smithy_client_1._json,
        AwsS3Object: smithy_client_1._json,
        AwsSageMakerNotebookInstance: smithy_client_1._json,
        AwsSecretsManagerSecret: smithy_client_1._json,
        AwsSnsTopic: smithy_client_1._json,
        AwsSqsQueue: smithy_client_1._json,
        AwsSsmPatchCompliance: smithy_client_1._json,
        AwsStepFunctionStateMachine: smithy_client_1._json,
        AwsWafRateBasedRule: smithy_client_1._json,
        AwsWafRegionalRateBasedRule: smithy_client_1._json,
        AwsWafRegionalRule: smithy_client_1._json,
        AwsWafRegionalRuleGroup: smithy_client_1._json,
        AwsWafRegionalWebAcl: smithy_client_1._json,
        AwsWafRule: smithy_client_1._json,
        AwsWafRuleGroup: smithy_client_1._json,
        AwsWafWebAcl: smithy_client_1._json,
        AwsWafv2RuleGroup: smithy_client_1._json,
        AwsWafv2WebAcl: smithy_client_1._json,
        AwsXrayEncryptionConfig: smithy_client_1._json,
        Container: smithy_client_1._json,
        Other: smithy_client_1._json,
    });
};
const se_ResourceList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Resource(entry, context);
    });
};
const se_Severity = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Label: [],
        Normalized: [],
        Original: [],
        Product: smithy_client_1.serializeFloat,
    });
};
const se_SeverityUpdate = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Label: [],
        Normalized: [],
        Product: smithy_client_1.serializeFloat,
    });
};
const se_UpdateAutomationRulesRequestItem = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Actions: (_) => se_ActionList(_, context),
        Criteria: (_) => se_AutomationRulesFindingFilters(_, context),
        Description: [],
        IsTerminal: [],
        RuleArn: [],
        RuleName: [],
        RuleOrder: [],
        RuleStatus: [],
    });
};
const se_UpdateAutomationRulesRequestItemsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_UpdateAutomationRulesRequestItem(entry, context);
    });
};
const se_Vulnerability = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Cvss: (_) => se_CvssList(_, context),
        FixAvailable: [],
        Id: [],
        ReferenceUrls: smithy_client_1._json,
        RelatedVulnerabilities: smithy_client_1._json,
        Vendor: smithy_client_1._json,
        VulnerablePackages: smithy_client_1._json,
    });
};
const se_VulnerabilityList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Vulnerability(entry, context);
    });
};
const de_Action = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ActionType: smithy_client_1.expectString,
        AwsApiCallAction: (_) => de_AwsApiCallAction(_, context),
        DnsRequestAction: smithy_client_1._json,
        NetworkConnectionAction: (_) => de_NetworkConnectionAction(_, context),
        PortProbeAction: (_) => de_PortProbeAction(_, context),
    });
};
const de_ActionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutomationRulesAction(entry, context);
    });
    return retVal;
};
const de_ActionRemoteIpDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        City: smithy_client_1._json,
        Country: smithy_client_1._json,
        GeoLocation: (_) => de_GeoLocation(_, context),
        IpAddressV4: smithy_client_1.expectString,
        Organization: smithy_client_1._json,
    });
};
const de_AutomationRulesAction = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        FindingFieldsUpdate: (_) => de_AutomationRulesFindingFieldsUpdate(_, context),
        Type: smithy_client_1.expectString,
    });
};
const de_AutomationRulesConfig = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Actions: (_) => de_ActionList(_, context),
        CreatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
        CreatedBy: smithy_client_1.expectString,
        Criteria: (_) => de_AutomationRulesFindingFilters(_, context),
        Description: smithy_client_1.expectString,
        IsTerminal: smithy_client_1.expectBoolean,
        RuleArn: smithy_client_1.expectString,
        RuleName: smithy_client_1.expectString,
        RuleOrder: smithy_client_1.expectInt32,
        RuleStatus: smithy_client_1.expectString,
        UpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
    });
};
const de_AutomationRulesConfigList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutomationRulesConfig(entry, context);
    });
    return retVal;
};
const de_AutomationRulesFindingFieldsUpdate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Confidence: smithy_client_1.expectInt32,
        Criticality: smithy_client_1.expectInt32,
        Note: smithy_client_1._json,
        RelatedFindings: smithy_client_1._json,
        Severity: (_) => de_SeverityUpdate(_, context),
        Types: smithy_client_1._json,
        UserDefinedFields: smithy_client_1._json,
        VerificationState: smithy_client_1.expectString,
        Workflow: smithy_client_1._json,
    });
};
const de_AutomationRulesFindingFilters = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AwsAccountId: smithy_client_1._json,
        CompanyName: smithy_client_1._json,
        ComplianceAssociatedStandardsId: smithy_client_1._json,
        ComplianceSecurityControlId: smithy_client_1._json,
        ComplianceStatus: smithy_client_1._json,
        Confidence: (_) => de_NumberFilterList(_, context),
        CreatedAt: smithy_client_1._json,
        Criticality: (_) => de_NumberFilterList(_, context),
        Description: smithy_client_1._json,
        FirstObservedAt: smithy_client_1._json,
        GeneratorId: smithy_client_1._json,
        Id: smithy_client_1._json,
        LastObservedAt: smithy_client_1._json,
        NoteText: smithy_client_1._json,
        NoteUpdatedAt: smithy_client_1._json,
        NoteUpdatedBy: smithy_client_1._json,
        ProductArn: smithy_client_1._json,
        ProductName: smithy_client_1._json,
        RecordState: smithy_client_1._json,
        RelatedFindingsId: smithy_client_1._json,
        RelatedFindingsProductArn: smithy_client_1._json,
        ResourceDetailsOther: smithy_client_1._json,
        ResourceId: smithy_client_1._json,
        ResourcePartition: smithy_client_1._json,
        ResourceRegion: smithy_client_1._json,
        ResourceTags: smithy_client_1._json,
        ResourceType: smithy_client_1._json,
        SeverityLabel: smithy_client_1._json,
        SourceUrl: smithy_client_1._json,
        Title: smithy_client_1._json,
        Type: smithy_client_1._json,
        UpdatedAt: smithy_client_1._json,
        UserDefinedFields: smithy_client_1._json,
        VerificationState: smithy_client_1._json,
        WorkflowStatus: smithy_client_1._json,
    });
};
const de_AutomationRulesMetadata = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CreatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
        CreatedBy: smithy_client_1.expectString,
        Description: smithy_client_1.expectString,
        IsTerminal: smithy_client_1.expectBoolean,
        RuleArn: smithy_client_1.expectString,
        RuleName: smithy_client_1.expectString,
        RuleOrder: smithy_client_1.expectInt32,
        RuleStatus: smithy_client_1.expectString,
        UpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
    });
};
const de_AutomationRulesMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutomationRulesMetadata(entry, context);
    });
    return retVal;
};
const de_AwsApiCallAction = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AffectedResources: smithy_client_1._json,
        Api: smithy_client_1.expectString,
        CallerType: smithy_client_1.expectString,
        DomainDetails: smithy_client_1._json,
        FirstSeen: smithy_client_1.expectString,
        LastSeen: smithy_client_1.expectString,
        RemoteIpDetails: (_) => de_ActionRemoteIpDetails(_, context),
        ServiceName: smithy_client_1.expectString,
    });
};
const de_AwsApiGatewayCanarySettings = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DeploymentId: smithy_client_1.expectString,
        PercentTraffic: smithy_client_1.limitedParseDouble,
        StageVariableOverrides: smithy_client_1._json,
        UseStageCache: smithy_client_1.expectBoolean,
    });
};
const de_AwsApiGatewayMethodSettings = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CacheDataEncrypted: smithy_client_1.expectBoolean,
        CacheTtlInSeconds: smithy_client_1.expectInt32,
        CachingEnabled: smithy_client_1.expectBoolean,
        DataTraceEnabled: smithy_client_1.expectBoolean,
        HttpMethod: smithy_client_1.expectString,
        LoggingLevel: smithy_client_1.expectString,
        MetricsEnabled: smithy_client_1.expectBoolean,
        RequireAuthorizationForCacheControl: smithy_client_1.expectBoolean,
        ResourcePath: smithy_client_1.expectString,
        ThrottlingBurstLimit: smithy_client_1.expectInt32,
        ThrottlingRateLimit: smithy_client_1.limitedParseDouble,
        UnauthorizedCacheControlHeaderStrategy: smithy_client_1.expectString,
    });
};
const de_AwsApiGatewayMethodSettingsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AwsApiGatewayMethodSettings(entry, context);
    });
    return retVal;
};
const de_AwsApiGatewayStageDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AccessLogSettings: smithy_client_1._json,
        CacheClusterEnabled: smithy_client_1.expectBoolean,
        CacheClusterSize: smithy_client_1.expectString,
        CacheClusterStatus: smithy_client_1.expectString,
        CanarySettings: (_) => de_AwsApiGatewayCanarySettings(_, context),
        ClientCertificateId: smithy_client_1.expectString,
        CreatedDate: smithy_client_1.expectString,
        DeploymentId: smithy_client_1.expectString,
        Description: smithy_client_1.expectString,
        DocumentationVersion: smithy_client_1.expectString,
        LastUpdatedDate: smithy_client_1.expectString,
        MethodSettings: (_) => de_AwsApiGatewayMethodSettingsList(_, context),
        StageName: smithy_client_1.expectString,
        TracingEnabled: smithy_client_1.expectBoolean,
        Variables: smithy_client_1._json,
        WebAclArn: smithy_client_1.expectString,
    });
};
const de_AwsApiGatewayV2RouteSettings = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DataTraceEnabled: smithy_client_1.expectBoolean,
        DetailedMetricsEnabled: smithy_client_1.expectBoolean,
        LoggingLevel: smithy_client_1.expectString,
        ThrottlingBurstLimit: smithy_client_1.expectInt32,
        ThrottlingRateLimit: smithy_client_1.limitedParseDouble,
    });
};
const de_AwsApiGatewayV2StageDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AccessLogSettings: smithy_client_1._json,
        ApiGatewayManaged: smithy_client_1.expectBoolean,
        AutoDeploy: smithy_client_1.expectBoolean,
        ClientCertificateId: smithy_client_1.expectString,
        CreatedDate: smithy_client_1.expectString,
        DefaultRouteSettings: (_) => de_AwsApiGatewayV2RouteSettings(_, context),
        DeploymentId: smithy_client_1.expectString,
        Description: smithy_client_1.expectString,
        LastDeploymentStatusMessage: smithy_client_1.expectString,
        LastUpdatedDate: smithy_client_1.expectString,
        RouteSettings: (_) => de_AwsApiGatewayV2RouteSettings(_, context),
        StageName: smithy_client_1.expectString,
        StageVariables: smithy_client_1._json,
    });
};
const de_AwsCloudWatchAlarmDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ActionsEnabled: smithy_client_1.expectBoolean,
        AlarmActions: smithy_client_1._json,
        AlarmArn: smithy_client_1.expectString,
        AlarmConfigurationUpdatedTimestamp: smithy_client_1.expectString,
        AlarmDescription: smithy_client_1.expectString,
        AlarmName: smithy_client_1.expectString,
        ComparisonOperator: smithy_client_1.expectString,
        DatapointsToAlarm: smithy_client_1.expectInt32,
        Dimensions: smithy_client_1._json,
        EvaluateLowSampleCountPercentile: smithy_client_1.expectString,
        EvaluationPeriods: smithy_client_1.expectInt32,
        ExtendedStatistic: smithy_client_1.expectString,
        InsufficientDataActions: smithy_client_1._json,
        MetricName: smithy_client_1.expectString,
        Namespace: smithy_client_1.expectString,
        OkActions: smithy_client_1._json,
        Period: smithy_client_1.expectInt32,
        Statistic: smithy_client_1.expectString,
        Threshold: smithy_client_1.limitedParseDouble,
        ThresholdMetricId: smithy_client_1.expectString,
        TreatMissingData: smithy_client_1.expectString,
        Unit: smithy_client_1.expectString,
    });
};
const de_AwsEc2LaunchTemplateDataDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BlockDeviceMappingSet: smithy_client_1._json,
        CapacityReservationSpecification: smithy_client_1._json,
        CpuOptions: smithy_client_1._json,
        CreditSpecification: smithy_client_1._json,
        DisableApiStop: smithy_client_1.expectBoolean,
        DisableApiTermination: smithy_client_1.expectBoolean,
        EbsOptimized: smithy_client_1.expectBoolean,
        ElasticGpuSpecificationSet: smithy_client_1._json,
        ElasticInferenceAcceleratorSet: smithy_client_1._json,
        EnclaveOptions: smithy_client_1._json,
        HibernationOptions: smithy_client_1._json,
        IamInstanceProfile: smithy_client_1._json,
        ImageId: smithy_client_1.expectString,
        InstanceInitiatedShutdownBehavior: smithy_client_1.expectString,
        InstanceMarketOptions: smithy_client_1._json,
        InstanceRequirements: (_) => de_AwsEc2LaunchTemplateDataInstanceRequirementsDetails(_, context),
        InstanceType: smithy_client_1.expectString,
        KernelId: smithy_client_1.expectString,
        KeyName: smithy_client_1.expectString,
        LicenseSet: smithy_client_1._json,
        MaintenanceOptions: smithy_client_1._json,
        MetadataOptions: smithy_client_1._json,
        Monitoring: smithy_client_1._json,
        NetworkInterfaceSet: smithy_client_1._json,
        Placement: smithy_client_1._json,
        PrivateDnsNameOptions: smithy_client_1._json,
        RamDiskId: smithy_client_1.expectString,
        SecurityGroupIdSet: smithy_client_1._json,
        SecurityGroupSet: smithy_client_1._json,
        UserData: smithy_client_1.expectString,
    });
};
const de_AwsEc2LaunchTemplateDataInstanceRequirementsDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AcceleratorCount: smithy_client_1._json,
        AcceleratorManufacturers: smithy_client_1._json,
        AcceleratorNames: smithy_client_1._json,
        AcceleratorTotalMemoryMiB: smithy_client_1._json,
        AcceleratorTypes: smithy_client_1._json,
        BareMetal: smithy_client_1.expectString,
        BaselineEbsBandwidthMbps: smithy_client_1._json,
        BurstablePerformance: smithy_client_1.expectString,
        CpuManufacturers: smithy_client_1._json,
        ExcludedInstanceTypes: smithy_client_1._json,
        InstanceGenerations: smithy_client_1._json,
        LocalStorage: smithy_client_1.expectString,
        LocalStorageTypes: smithy_client_1._json,
        MemoryGiBPerVCpu: (_) => de_AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails(_, context),
        MemoryMiB: smithy_client_1._json,
        NetworkInterfaceCount: smithy_client_1._json,
        OnDemandMaxPricePercentageOverLowestPrice: smithy_client_1.expectInt32,
        RequireHibernateSupport: smithy_client_1.expectBoolean,
        SpotMaxPricePercentageOverLowestPrice: smithy_client_1.expectInt32,
        TotalLocalStorageGB: (_) => de_AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails(_, context),
        VCpuCount: smithy_client_1._json,
    });
};
const de_AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Max: smithy_client_1.limitedParseDouble,
        Min: smithy_client_1.limitedParseDouble,
    });
};
const de_AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Max: smithy_client_1.limitedParseDouble,
        Min: smithy_client_1.limitedParseDouble,
    });
};
const de_AwsEc2LaunchTemplateDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DefaultVersionNumber: smithy_client_1.expectLong,
        Id: smithy_client_1.expectString,
        LatestVersionNumber: smithy_client_1.expectLong,
        LaunchTemplateData: (_) => de_AwsEc2LaunchTemplateDataDetails(_, context),
        LaunchTemplateName: smithy_client_1.expectString,
    });
};
const de_AwsKmsKeyDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AWSAccountId: smithy_client_1.expectString,
        CreationDate: smithy_client_1.limitedParseDouble,
        Description: smithy_client_1.expectString,
        KeyId: smithy_client_1.expectString,
        KeyManager: smithy_client_1.expectString,
        KeyRotationStatus: smithy_client_1.expectBoolean,
        KeyState: smithy_client_1.expectString,
        Origin: smithy_client_1.expectString,
    });
};
const de_AwsNetworkFirewallRuleGroupDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Capacity: smithy_client_1.expectInt32,
        Description: smithy_client_1.expectString,
        RuleGroup: smithy_client_1._json,
        RuleGroupArn: smithy_client_1.expectString,
        RuleGroupId: smithy_client_1.expectString,
        RuleGroupName: smithy_client_1.expectString,
        Type: smithy_client_1.expectString,
    });
};
const de_AwsRedshiftClusterDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AllowVersionUpgrade: smithy_client_1.expectBoolean,
        AutomatedSnapshotRetentionPeriod: smithy_client_1.expectInt32,
        AvailabilityZone: smithy_client_1.expectString,
        ClusterAvailabilityStatus: smithy_client_1.expectString,
        ClusterCreateTime: smithy_client_1.expectString,
        ClusterIdentifier: smithy_client_1.expectString,
        ClusterNodes: smithy_client_1._json,
        ClusterParameterGroups: smithy_client_1._json,
        ClusterPublicKey: smithy_client_1.expectString,
        ClusterRevisionNumber: smithy_client_1.expectString,
        ClusterSecurityGroups: smithy_client_1._json,
        ClusterSnapshotCopyStatus: smithy_client_1._json,
        ClusterStatus: smithy_client_1.expectString,
        ClusterSubnetGroupName: smithy_client_1.expectString,
        ClusterVersion: smithy_client_1.expectString,
        DBName: smithy_client_1.expectString,
        DeferredMaintenanceWindows: smithy_client_1._json,
        ElasticIpStatus: smithy_client_1._json,
        ElasticResizeNumberOfNodeOptions: smithy_client_1.expectString,
        Encrypted: smithy_client_1.expectBoolean,
        Endpoint: smithy_client_1._json,
        EnhancedVpcRouting: smithy_client_1.expectBoolean,
        ExpectedNextSnapshotScheduleTime: smithy_client_1.expectString,
        ExpectedNextSnapshotScheduleTimeStatus: smithy_client_1.expectString,
        HsmStatus: smithy_client_1._json,
        IamRoles: smithy_client_1._json,
        KmsKeyId: smithy_client_1.expectString,
        LoggingStatus: smithy_client_1._json,
        MaintenanceTrackName: smithy_client_1.expectString,
        ManualSnapshotRetentionPeriod: smithy_client_1.expectInt32,
        MasterUsername: smithy_client_1.expectString,
        NextMaintenanceWindowStartTime: smithy_client_1.expectString,
        NodeType: smithy_client_1.expectString,
        NumberOfNodes: smithy_client_1.expectInt32,
        PendingActions: smithy_client_1._json,
        PendingModifiedValues: smithy_client_1._json,
        PreferredMaintenanceWindow: smithy_client_1.expectString,
        PubliclyAccessible: smithy_client_1.expectBoolean,
        ResizeInfo: smithy_client_1._json,
        RestoreStatus: (_) => de_AwsRedshiftClusterRestoreStatus(_, context),
        SnapshotScheduleIdentifier: smithy_client_1.expectString,
        SnapshotScheduleState: smithy_client_1.expectString,
        VpcId: smithy_client_1.expectString,
        VpcSecurityGroups: smithy_client_1._json,
    });
};
const de_AwsRedshiftClusterRestoreStatus = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CurrentRestoreRateInMegaBytesPerSecond: smithy_client_1.limitedParseDouble,
        ElapsedTimeInSeconds: smithy_client_1.expectLong,
        EstimatedTimeToCompletionInSeconds: smithy_client_1.expectLong,
        ProgressInMegaBytes: smithy_client_1.expectLong,
        SnapshotSizeInMegaBytes: smithy_client_1.expectLong,
        Status: smithy_client_1.expectString,
    });
};
const de_AwsSecurityFinding = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Action: (_) => de_Action(_, context),
        AwsAccountId: smithy_client_1.expectString,
        CompanyName: smithy_client_1.expectString,
        Compliance: smithy_client_1._json,
        Confidence: smithy_client_1.expectInt32,
        CreatedAt: smithy_client_1.expectString,
        Criticality: smithy_client_1.expectInt32,
        Description: smithy_client_1.expectString,
        FindingProviderFields: smithy_client_1._json,
        FirstObservedAt: smithy_client_1.expectString,
        GeneratorId: smithy_client_1.expectString,
        Id: smithy_client_1.expectString,
        LastObservedAt: smithy_client_1.expectString,
        Malware: smithy_client_1._json,
        Network: smithy_client_1._json,
        NetworkPath: smithy_client_1._json,
        Note: smithy_client_1._json,
        PatchSummary: smithy_client_1._json,
        Process: smithy_client_1._json,
        ProductArn: smithy_client_1.expectString,
        ProductFields: smithy_client_1._json,
        ProductName: smithy_client_1.expectString,
        RecordState: smithy_client_1.expectString,
        Region: smithy_client_1.expectString,
        RelatedFindings: smithy_client_1._json,
        Remediation: smithy_client_1._json,
        Resources: (_) => de_ResourceList(_, context),
        Sample: smithy_client_1.expectBoolean,
        SchemaVersion: smithy_client_1.expectString,
        Severity: (_) => de_Severity(_, context),
        SourceUrl: smithy_client_1.expectString,
        ThreatIntelIndicators: smithy_client_1._json,
        Threats: smithy_client_1._json,
        Title: smithy_client_1.expectString,
        Types: smithy_client_1._json,
        UpdatedAt: smithy_client_1.expectString,
        UserDefinedFields: smithy_client_1._json,
        VerificationState: smithy_client_1.expectString,
        Vulnerabilities: (_) => de_VulnerabilityList(_, context),
        Workflow: smithy_client_1._json,
        WorkflowState: smithy_client_1.expectString,
    });
};
const de_AwsSecurityFindingFilters = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AwsAccountId: smithy_client_1._json,
        CompanyName: smithy_client_1._json,
        ComplianceAssociatedStandardsId: smithy_client_1._json,
        ComplianceSecurityControlId: smithy_client_1._json,
        ComplianceStatus: smithy_client_1._json,
        Confidence: (_) => de_NumberFilterList(_, context),
        CreatedAt: smithy_client_1._json,
        Criticality: (_) => de_NumberFilterList(_, context),
        Description: smithy_client_1._json,
        FindingProviderFieldsConfidence: (_) => de_NumberFilterList(_, context),
        FindingProviderFieldsCriticality: (_) => de_NumberFilterList(_, context),
        FindingProviderFieldsRelatedFindingsId: smithy_client_1._json,
        FindingProviderFieldsRelatedFindingsProductArn: smithy_client_1._json,
        FindingProviderFieldsSeverityLabel: smithy_client_1._json,
        FindingProviderFieldsSeverityOriginal: smithy_client_1._json,
        FindingProviderFieldsTypes: smithy_client_1._json,
        FirstObservedAt: smithy_client_1._json,
        GeneratorId: smithy_client_1._json,
        Id: smithy_client_1._json,
        Keyword: smithy_client_1._json,
        LastObservedAt: smithy_client_1._json,
        MalwareName: smithy_client_1._json,
        MalwarePath: smithy_client_1._json,
        MalwareState: smithy_client_1._json,
        MalwareType: smithy_client_1._json,
        NetworkDestinationDomain: smithy_client_1._json,
        NetworkDestinationIpV4: smithy_client_1._json,
        NetworkDestinationIpV6: smithy_client_1._json,
        NetworkDestinationPort: (_) => de_NumberFilterList(_, context),
        NetworkDirection: smithy_client_1._json,
        NetworkProtocol: smithy_client_1._json,
        NetworkSourceDomain: smithy_client_1._json,
        NetworkSourceIpV4: smithy_client_1._json,
        NetworkSourceIpV6: smithy_client_1._json,
        NetworkSourceMac: smithy_client_1._json,
        NetworkSourcePort: (_) => de_NumberFilterList(_, context),
        NoteText: smithy_client_1._json,
        NoteUpdatedAt: smithy_client_1._json,
        NoteUpdatedBy: smithy_client_1._json,
        ProcessLaunchedAt: smithy_client_1._json,
        ProcessName: smithy_client_1._json,
        ProcessParentPid: (_) => de_NumberFilterList(_, context),
        ProcessPath: smithy_client_1._json,
        ProcessPid: (_) => de_NumberFilterList(_, context),
        ProcessTerminatedAt: smithy_client_1._json,
        ProductArn: smithy_client_1._json,
        ProductFields: smithy_client_1._json,
        ProductName: smithy_client_1._json,
        RecommendationText: smithy_client_1._json,
        RecordState: smithy_client_1._json,
        Region: smithy_client_1._json,
        RelatedFindingsId: smithy_client_1._json,
        RelatedFindingsProductArn: smithy_client_1._json,
        ResourceAwsEc2InstanceIamInstanceProfileArn: smithy_client_1._json,
        ResourceAwsEc2InstanceImageId: smithy_client_1._json,
        ResourceAwsEc2InstanceIpV4Addresses: smithy_client_1._json,
        ResourceAwsEc2InstanceIpV6Addresses: smithy_client_1._json,
        ResourceAwsEc2InstanceKeyName: smithy_client_1._json,
        ResourceAwsEc2InstanceLaunchedAt: smithy_client_1._json,
        ResourceAwsEc2InstanceSubnetId: smithy_client_1._json,
        ResourceAwsEc2InstanceType: smithy_client_1._json,
        ResourceAwsEc2InstanceVpcId: smithy_client_1._json,
        ResourceAwsIamAccessKeyCreatedAt: smithy_client_1._json,
        ResourceAwsIamAccessKeyPrincipalName: smithy_client_1._json,
        ResourceAwsIamAccessKeyStatus: smithy_client_1._json,
        ResourceAwsIamAccessKeyUserName: smithy_client_1._json,
        ResourceAwsIamUserUserName: smithy_client_1._json,
        ResourceAwsS3BucketOwnerId: smithy_client_1._json,
        ResourceAwsS3BucketOwnerName: smithy_client_1._json,
        ResourceContainerImageId: smithy_client_1._json,
        ResourceContainerImageName: smithy_client_1._json,
        ResourceContainerLaunchedAt: smithy_client_1._json,
        ResourceContainerName: smithy_client_1._json,
        ResourceDetailsOther: smithy_client_1._json,
        ResourceId: smithy_client_1._json,
        ResourcePartition: smithy_client_1._json,
        ResourceRegion: smithy_client_1._json,
        ResourceTags: smithy_client_1._json,
        ResourceType: smithy_client_1._json,
        Sample: smithy_client_1._json,
        SeverityLabel: smithy_client_1._json,
        SeverityNormalized: (_) => de_NumberFilterList(_, context),
        SeverityProduct: (_) => de_NumberFilterList(_, context),
        SourceUrl: smithy_client_1._json,
        ThreatIntelIndicatorCategory: smithy_client_1._json,
        ThreatIntelIndicatorLastObservedAt: smithy_client_1._json,
        ThreatIntelIndicatorSource: smithy_client_1._json,
        ThreatIntelIndicatorSourceUrl: smithy_client_1._json,
        ThreatIntelIndicatorType: smithy_client_1._json,
        ThreatIntelIndicatorValue: smithy_client_1._json,
        Title: smithy_client_1._json,
        Type: smithy_client_1._json,
        UpdatedAt: smithy_client_1._json,
        UserDefinedFields: smithy_client_1._json,
        VerificationState: smithy_client_1._json,
        WorkflowState: smithy_client_1._json,
        WorkflowStatus: smithy_client_1._json,
    });
};
const de_AwsSecurityFindingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AwsSecurityFinding(entry, context);
    });
    return retVal;
};
const de_Cvss = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Adjustments: smithy_client_1._json,
        BaseScore: smithy_client_1.limitedParseDouble,
        BaseVector: smithy_client_1.expectString,
        Source: smithy_client_1.expectString,
        Version: smithy_client_1.expectString,
    });
};
const de_CvssList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Cvss(entry, context);
    });
    return retVal;
};
const de_FindingHistoryRecord = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        FindingCreated: smithy_client_1.expectBoolean,
        FindingIdentifier: smithy_client_1._json,
        NextToken: smithy_client_1.expectString,
        UpdateSource: smithy_client_1._json,
        UpdateTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
        Updates: smithy_client_1._json,
    });
};
const de_FindingHistoryRecordList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FindingHistoryRecord(entry, context);
    });
    return retVal;
};
const de_GeoLocation = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Lat: smithy_client_1.limitedParseDouble,
        Lon: smithy_client_1.limitedParseDouble,
    });
};
const de_Insight = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Filters: (_) => de_AwsSecurityFindingFilters(_, context),
        GroupByAttribute: smithy_client_1.expectString,
        InsightArn: smithy_client_1.expectString,
        Name: smithy_client_1.expectString,
    });
};
const de_InsightList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Insight(entry, context);
    });
    return retVal;
};
const de_Invitation = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AccountId: smithy_client_1.expectString,
        InvitationId: smithy_client_1.expectString,
        InvitedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
        MemberStatus: smithy_client_1.expectString,
    });
};
const de_InvitationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Invitation(entry, context);
    });
    return retVal;
};
const de_Member = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AccountId: smithy_client_1.expectString,
        AdministratorId: smithy_client_1.expectString,
        Email: smithy_client_1.expectString,
        InvitedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
        MasterId: smithy_client_1.expectString,
        MemberStatus: smithy_client_1.expectString,
        UpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
    });
};
const de_MemberList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Member(entry, context);
    });
    return retVal;
};
const de_NetworkConnectionAction = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Blocked: smithy_client_1.expectBoolean,
        ConnectionDirection: smithy_client_1.expectString,
        LocalPortDetails: smithy_client_1._json,
        Protocol: smithy_client_1.expectString,
        RemoteIpDetails: (_) => de_ActionRemoteIpDetails(_, context),
        RemotePortDetails: smithy_client_1._json,
    });
};
const de_NumberFilter = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Eq: smithy_client_1.limitedParseDouble,
        Gte: smithy_client_1.limitedParseDouble,
        Lte: smithy_client_1.limitedParseDouble,
    });
};
const de_NumberFilterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NumberFilter(entry, context);
    });
    return retVal;
};
const de_PortProbeAction = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Blocked: smithy_client_1.expectBoolean,
        PortProbeDetails: (_) => de_PortProbeDetailList(_, context),
    });
};
const de_PortProbeDetail = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        LocalIpDetails: smithy_client_1._json,
        LocalPortDetails: smithy_client_1._json,
        RemoteIpDetails: (_) => de_ActionRemoteIpDetails(_, context),
    });
};
const de_PortProbeDetailList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PortProbeDetail(entry, context);
    });
    return retVal;
};
const de_Resource = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DataClassification: smithy_client_1._json,
        Details: (_) => de_ResourceDetails(_, context),
        Id: smithy_client_1.expectString,
        Partition: smithy_client_1.expectString,
        Region: smithy_client_1.expectString,
        ResourceRole: smithy_client_1.expectString,
        Tags: smithy_client_1._json,
        Type: smithy_client_1.expectString,
    });
};
const de_ResourceDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AwsAmazonMqBroker: smithy_client_1._json,
        AwsApiGatewayRestApi: smithy_client_1._json,
        AwsApiGatewayStage: (_) => de_AwsApiGatewayStageDetails(_, context),
        AwsApiGatewayV2Api: smithy_client_1._json,
        AwsApiGatewayV2Stage: (_) => de_AwsApiGatewayV2StageDetails(_, context),
        AwsAppSyncGraphQlApi: smithy_client_1._json,
        AwsAthenaWorkGroup: smithy_client_1._json,
        AwsAutoScalingAutoScalingGroup: smithy_client_1._json,
        AwsAutoScalingLaunchConfiguration: smithy_client_1._json,
        AwsBackupBackupPlan: smithy_client_1._json,
        AwsBackupBackupVault: smithy_client_1._json,
        AwsBackupRecoveryPoint: smithy_client_1._json,
        AwsCertificateManagerCertificate: smithy_client_1._json,
        AwsCloudFormationStack: smithy_client_1._json,
        AwsCloudFrontDistribution: smithy_client_1._json,
        AwsCloudTrailTrail: smithy_client_1._json,
        AwsCloudWatchAlarm: (_) => de_AwsCloudWatchAlarmDetails(_, context),
        AwsCodeBuildProject: smithy_client_1._json,
        AwsDynamoDbTable: smithy_client_1._json,
        AwsEc2Eip: smithy_client_1._json,
        AwsEc2Instance: smithy_client_1._json,
        AwsEc2LaunchTemplate: (_) => de_AwsEc2LaunchTemplateDetails(_, context),
        AwsEc2NetworkAcl: smithy_client_1._json,
        AwsEc2NetworkInterface: smithy_client_1._json,
        AwsEc2RouteTable: smithy_client_1._json,
        AwsEc2SecurityGroup: smithy_client_1._json,
        AwsEc2Subnet: smithy_client_1._json,
        AwsEc2TransitGateway: smithy_client_1._json,
        AwsEc2Volume: smithy_client_1._json,
        AwsEc2Vpc: smithy_client_1._json,
        AwsEc2VpcEndpointService: smithy_client_1._json,
        AwsEc2VpcPeeringConnection: smithy_client_1._json,
        AwsEc2VpnConnection: smithy_client_1._json,
        AwsEcrContainerImage: smithy_client_1._json,
        AwsEcrRepository: smithy_client_1._json,
        AwsEcsCluster: smithy_client_1._json,
        AwsEcsContainer: smithy_client_1._json,
        AwsEcsService: smithy_client_1._json,
        AwsEcsTask: smithy_client_1._json,
        AwsEcsTaskDefinition: smithy_client_1._json,
        AwsEfsAccessPoint: smithy_client_1._json,
        AwsEksCluster: smithy_client_1._json,
        AwsElasticBeanstalkEnvironment: smithy_client_1._json,
        AwsElasticsearchDomain: smithy_client_1._json,
        AwsElbLoadBalancer: smithy_client_1._json,
        AwsElbv2LoadBalancer: smithy_client_1._json,
        AwsEventSchemasRegistry: smithy_client_1._json,
        AwsGuardDutyDetector: smithy_client_1._json,
        AwsIamAccessKey: smithy_client_1._json,
        AwsIamGroup: smithy_client_1._json,
        AwsIamPolicy: smithy_client_1._json,
        AwsIamRole: smithy_client_1._json,
        AwsIamUser: smithy_client_1._json,
        AwsKinesisStream: smithy_client_1._json,
        AwsKmsKey: (_) => de_AwsKmsKeyDetails(_, context),
        AwsLambdaFunction: smithy_client_1._json,
        AwsLambdaLayerVersion: smithy_client_1._json,
        AwsNetworkFirewallFirewall: smithy_client_1._json,
        AwsNetworkFirewallFirewallPolicy: smithy_client_1._json,
        AwsNetworkFirewallRuleGroup: (_) => de_AwsNetworkFirewallRuleGroupDetails(_, context),
        AwsOpenSearchServiceDomain: smithy_client_1._json,
        AwsRdsDbCluster: smithy_client_1._json,
        AwsRdsDbClusterSnapshot: smithy_client_1._json,
        AwsRdsDbInstance: smithy_client_1._json,
        AwsRdsDbSecurityGroup: smithy_client_1._json,
        AwsRdsDbSnapshot: smithy_client_1._json,
        AwsRdsEventSubscription: smithy_client_1._json,
        AwsRedshiftCluster: (_) => de_AwsRedshiftClusterDetails(_, context),
        AwsS3AccountPublicAccessBlock: smithy_client_1._json,
        AwsS3Bucket: smithy_client_1._json,
        AwsS3Object: smithy_client_1._json,
        AwsSageMakerNotebookInstance: smithy_client_1._json,
        AwsSecretsManagerSecret: smithy_client_1._json,
        AwsSnsTopic: smithy_client_1._json,
        AwsSqsQueue: smithy_client_1._json,
        AwsSsmPatchCompliance: smithy_client_1._json,
        AwsStepFunctionStateMachine: smithy_client_1._json,
        AwsWafRateBasedRule: smithy_client_1._json,
        AwsWafRegionalRateBasedRule: smithy_client_1._json,
        AwsWafRegionalRule: smithy_client_1._json,
        AwsWafRegionalRuleGroup: smithy_client_1._json,
        AwsWafRegionalWebAcl: smithy_client_1._json,
        AwsWafRule: smithy_client_1._json,
        AwsWafRuleGroup: smithy_client_1._json,
        AwsWafWebAcl: smithy_client_1._json,
        AwsWafv2RuleGroup: smithy_client_1._json,
        AwsWafv2WebAcl: smithy_client_1._json,
        AwsXrayEncryptionConfig: smithy_client_1._json,
        Container: smithy_client_1._json,
        Other: smithy_client_1._json,
    });
};
const de_ResourceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Resource(entry, context);
    });
    return retVal;
};
const de_Severity = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Label: smithy_client_1.expectString,
        Normalized: smithy_client_1.expectInt32,
        Original: smithy_client_1.expectString,
        Product: smithy_client_1.limitedParseDouble,
    });
};
const de_SeverityUpdate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Label: smithy_client_1.expectString,
        Normalized: smithy_client_1.expectInt32,
        Product: smithy_client_1.limitedParseDouble,
    });
};
const de_StandardsControl = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ControlId: smithy_client_1.expectString,
        ControlStatus: smithy_client_1.expectString,
        ControlStatusUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
        Description: smithy_client_1.expectString,
        DisabledReason: smithy_client_1.expectString,
        RelatedRequirements: smithy_client_1._json,
        RemediationUrl: smithy_client_1.expectString,
        SeverityRating: smithy_client_1.expectString,
        StandardsControlArn: smithy_client_1.expectString,
        Title: smithy_client_1.expectString,
    });
};
const de_StandardsControlAssociationDetail = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AssociationStatus: smithy_client_1.expectString,
        RelatedRequirements: smithy_client_1._json,
        SecurityControlArn: smithy_client_1.expectString,
        SecurityControlId: smithy_client_1.expectString,
        StandardsArn: smithy_client_1.expectString,
        StandardsControlArns: smithy_client_1._json,
        StandardsControlDescription: smithy_client_1.expectString,
        StandardsControlTitle: smithy_client_1.expectString,
        UpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
        UpdatedReason: smithy_client_1.expectString,
    });
};
const de_StandardsControlAssociationDetails = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StandardsControlAssociationDetail(entry, context);
    });
    return retVal;
};
const de_StandardsControlAssociationSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StandardsControlAssociationSummary(entry, context);
    });
    return retVal;
};
const de_StandardsControlAssociationSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AssociationStatus: smithy_client_1.expectString,
        RelatedRequirements: smithy_client_1._json,
        SecurityControlArn: smithy_client_1.expectString,
        SecurityControlId: smithy_client_1.expectString,
        StandardsArn: smithy_client_1.expectString,
        StandardsControlDescription: smithy_client_1.expectString,
        StandardsControlTitle: smithy_client_1.expectString,
        UpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
        UpdatedReason: smithy_client_1.expectString,
    });
};
const de_StandardsControls = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StandardsControl(entry, context);
    });
    return retVal;
};
const de_Vulnerability = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Cvss: (_) => de_CvssList(_, context),
        FixAvailable: smithy_client_1.expectString,
        Id: smithy_client_1.expectString,
        ReferenceUrls: smithy_client_1._json,
        RelatedVulnerabilities: smithy_client_1._json,
        Vendor: smithy_client_1._json,
        VulnerablePackages: smithy_client_1._json,
    });
};
const de_VulnerabilityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Vulnerability(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 98707:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(61984));
const client_sts_1 = __nccwpck_require__(52209);
const credential_provider_node_1 = __nccwpck_require__(75531);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(21610);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 21610:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const endpointResolver_1 = __nccwpck_require__(59644);
const getRuntimeConfig = (config) => ({
    apiVersion: "2018-10-26",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "SecurityHub",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
    utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 17124:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOOIDC = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const CreateTokenCommand_1 = __nccwpck_require__(62853);
const RegisterClientCommand_1 = __nccwpck_require__(36677);
const StartDeviceAuthorizationCommand_1 = __nccwpck_require__(38359);
const SSOOIDCClient_1 = __nccwpck_require__(70139);
const commands = {
    CreateTokenCommand: CreateTokenCommand_1.CreateTokenCommand,
    RegisterClientCommand: RegisterClientCommand_1.RegisterClientCommand,
    StartDeviceAuthorizationCommand: StartDeviceAuthorizationCommand_1.StartDeviceAuthorizationCommand,
};
class SSOOIDC extends SSOOIDCClient_1.SSOOIDCClient {
}
exports.SSOOIDC = SSOOIDC;
(0, smithy_client_1.createAggregatedClient)(commands, SSOOIDC);


/***/ }),

/***/ 70139:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOOIDCClient = exports.__Client = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const EndpointParameters_1 = __nccwpck_require__(61426);
const runtimeConfig_1 = __nccwpck_require__(25524);
class SSOOIDCClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        super(_config_6);
        this.config = _config_6;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.SSOOIDCClient = SSOOIDCClient;


/***/ }),

/***/ 62853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateTokenCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(21518);
class CreateTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "CreateTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_CreateTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_CreateTokenCommand)(output, context);
    }
}
exports.CreateTokenCommand = CreateTokenCommand;


/***/ }),

/***/ 36677:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterClientCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(21518);
class RegisterClientCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RegisterClientCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "RegisterClientCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_RegisterClientCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_RegisterClientCommand)(output, context);
    }
}
exports.RegisterClientCommand = RegisterClientCommand;


/***/ }),

/***/ 38359:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StartDeviceAuthorizationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_restJson1_1 = __nccwpck_require__(21518);
class StartDeviceAuthorizationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StartDeviceAuthorizationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "StartDeviceAuthorizationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_StartDeviceAuthorizationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_StartDeviceAuthorizationCommand)(output, context);
    }
}
exports.StartDeviceAuthorizationCommand = StartDeviceAuthorizationCommand;


/***/ }),

/***/ 50447:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(62853), exports);
tslib_1.__exportStar(__nccwpck_require__(36677), exports);
tslib_1.__exportStar(__nccwpck_require__(38359), exports);


/***/ }),

/***/ 61426:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssooidc",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 97604:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(51756);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 51756:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const p = "required", q = "fn", r = "argv", s = "ref";
const a = "PartitionResult", b = "tree", c = "error", d = "endpoint", e = { [p]: false, "type": "String" }, f = { [p]: true, "default": false, "type": "Boolean" }, g = { [s]: "Endpoint" }, h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] }, i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] }, j = {}, k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] }, l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] }, m = [g], n = [h], o = [i];
const _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 54527:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOOIDCServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(70139), exports);
tslib_1.__exportStar(__nccwpck_require__(17124), exports);
tslib_1.__exportStar(__nccwpck_require__(50447), exports);
tslib_1.__exportStar(__nccwpck_require__(35973), exports);
var SSOOIDCServiceException_1 = __nccwpck_require__(43026);
Object.defineProperty(exports, "SSOOIDCServiceException", ({ enumerable: true, get: function () { return SSOOIDCServiceException_1.SSOOIDCServiceException; } }));


/***/ }),

/***/ 43026:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOOIDCServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class SSOOIDCServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSOOIDCServiceException.prototype);
    }
}
exports.SSOOIDCServiceException = SSOOIDCServiceException;


/***/ }),

/***/ 35973:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(69374), exports);


/***/ }),

/***/ 69374:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidClientMetadataException = exports.UnsupportedGrantTypeException = exports.UnauthorizedClientException = exports.SlowDownException = exports.InvalidScopeException = exports.InvalidRequestException = exports.InvalidGrantException = exports.InvalidClientException = exports.InternalServerException = exports.ExpiredTokenException = exports.AuthorizationPendingException = exports.AccessDeniedException = void 0;
const SSOOIDCServiceException_1 = __nccwpck_require__(43026);
class AccessDeniedException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.AccessDeniedException = AccessDeniedException;
class AuthorizationPendingException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "AuthorizationPendingException",
            $fault: "client",
            ...opts,
        });
        this.name = "AuthorizationPendingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AuthorizationPendingException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.AuthorizationPendingException = AuthorizationPendingException;
class ExpiredTokenException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredTokenException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.ExpiredTokenException = ExpiredTokenException;
class InternalServerException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalServerException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InternalServerException = InternalServerException;
class InvalidClientException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidClientException = InvalidClientException;
class InvalidGrantException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidGrantException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidGrantException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidGrantException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidGrantException = InvalidGrantException;
class InvalidRequestException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidRequestException = InvalidRequestException;
class InvalidScopeException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidScopeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidScopeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidScopeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidScopeException = InvalidScopeException;
class SlowDownException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "SlowDownException",
            $fault: "client",
            ...opts,
        });
        this.name = "SlowDownException";
        this.$fault = "client";
        Object.setPrototypeOf(this, SlowDownException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.SlowDownException = SlowDownException;
class UnauthorizedClientException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.UnauthorizedClientException = UnauthorizedClientException;
class UnsupportedGrantTypeException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "UnsupportedGrantTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnsupportedGrantTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedGrantTypeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.UnsupportedGrantTypeException = UnsupportedGrantTypeException;
class InvalidClientMetadataException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidClientMetadataException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidClientMetadataException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidClientMetadataException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidClientMetadataException = InvalidClientMetadataException;


/***/ }),

/***/ 21518:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.de_StartDeviceAuthorizationCommand = exports.de_RegisterClientCommand = exports.de_CreateTokenCommand = exports.se_StartDeviceAuthorizationCommand = exports.se_RegisterClientCommand = exports.se_CreateTokenCommand = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const models_0_1 = __nccwpck_require__(69374);
const SSOOIDCServiceException_1 = __nccwpck_require__(43026);
const se_CreateTokenCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/token";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        clientId: [],
        clientSecret: [],
        code: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateTokenCommand = se_CreateTokenCommand;
const se_RegisterClientCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/client/register";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        clientName: [],
        clientType: [],
        scopes: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RegisterClientCommand = se_RegisterClientCommand;
const se_StartDeviceAuthorizationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/device_authorization";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        clientId: [],
        clientSecret: [],
        startUrl: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_StartDeviceAuthorizationCommand = se_StartDeviceAuthorizationCommand;
const de_CreateTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateTokenCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        accessToken: smithy_client_1.expectString,
        expiresIn: smithy_client_1.expectInt32,
        idToken: smithy_client_1.expectString,
        refreshToken: smithy_client_1.expectString,
        tokenType: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateTokenCommand = de_CreateTokenCommand;
const de_CreateTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
            throw await de_AuthorizationPendingExceptionRes(parsedOutput, context);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await de_InvalidClientExceptionRes(parsedOutput, context);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
            throw await de_InvalidGrantExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await de_InvalidScopeExceptionRes(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await de_SlowDownExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
            throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RegisterClientCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterClientCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorizationEndpoint: smithy_client_1.expectString,
        clientId: smithy_client_1.expectString,
        clientIdIssuedAt: smithy_client_1.expectLong,
        clientSecret: smithy_client_1.expectString,
        clientSecretExpiresAt: smithy_client_1.expectLong,
        tokenEndpoint: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_RegisterClientCommand = de_RegisterClientCommand;
const de_RegisterClientCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientMetadataException":
        case "com.amazonaws.ssooidc#InvalidClientMetadataException":
            throw await de_InvalidClientMetadataExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await de_InvalidScopeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartDeviceAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartDeviceAuthorizationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        deviceCode: smithy_client_1.expectString,
        expiresIn: smithy_client_1.expectInt32,
        interval: smithy_client_1.expectInt32,
        userCode: smithy_client_1.expectString,
        verificationUri: smithy_client_1.expectString,
        verificationUriComplete: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_StartDeviceAuthorizationCommand = de_StartDeviceAuthorizationCommand;
const de_StartDeviceAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await de_InvalidClientExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await de_SlowDownExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(SSOOIDCServiceException_1.SSOOIDCServiceException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_AuthorizationPendingExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.AuthorizationPendingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidClientExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidClientMetadataExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidClientMetadataException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidGrantExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidGrantException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidScopeExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidScopeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_SlowDownExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.SlowDownException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedClientExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnauthorizedClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        error: smithy_client_1.expectString,
        error_description: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnsupportedGrantTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 25524:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(69722));
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(68005);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 68005:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const endpointResolver_1 = __nccwpck_require__(97604);
const getRuntimeConfig = (config) => ({
    apiVersion: "2019-06-10",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "SSO OIDC",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
    utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 69838:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSO = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const GetRoleCredentialsCommand_1 = __nccwpck_require__(18972);
const ListAccountRolesCommand_1 = __nccwpck_require__(1513);
const ListAccountsCommand_1 = __nccwpck_require__(64296);
const LogoutCommand_1 = __nccwpck_require__(12586);
const SSOClient_1 = __nccwpck_require__(71057);
const commands = {
    GetRoleCredentialsCommand: GetRoleCredentialsCommand_1.GetRoleCredentialsCommand,
    ListAccountRolesCommand: ListAccountRolesCommand_1.ListAccountRolesCommand,
    ListAccountsCommand: ListAccountsCommand_1.ListAccountsCommand,
    LogoutCommand: LogoutCommand_1.LogoutCommand,
};
class SSO extends SSOClient_1.SSOClient {
}
exports.SSO = SSO;
(0, smithy_client_1.createAggregatedClient)(commands, SSO);


/***/ }),

/***/ 71057:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOClient = exports.__Client = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const EndpointParameters_1 = __nccwpck_require__(34214);
const runtimeConfig_1 = __nccwpck_require__(19756);
class SSOClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        super(_config_6);
        this.config = _config_6;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.SSOClient = SSOClient;


/***/ }),

/***/ 18972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRoleCredentialsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class GetRoleCredentialsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetRoleCredentialsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "GetRoleCredentialsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetRoleCredentialsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetRoleCredentialsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetRoleCredentialsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetRoleCredentialsCommand)(output, context);
    }
}
exports.GetRoleCredentialsCommand = GetRoleCredentialsCommand;


/***/ }),

/***/ 1513:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccountRolesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class ListAccountRolesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountRolesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "ListAccountRolesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListAccountRolesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListAccountRolesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListAccountRolesCommand)(output, context);
    }
}
exports.ListAccountRolesCommand = ListAccountRolesCommand;


/***/ }),

/***/ 64296:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccountsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class ListAccountsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "ListAccountsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListAccountsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListAccountsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListAccountsCommand)(output, context);
    }
}
exports.ListAccountsCommand = ListAccountsCommand;


/***/ }),

/***/ 12586:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogoutCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class LogoutCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, LogoutCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "LogoutCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.LogoutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_LogoutCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_LogoutCommand)(output, context);
    }
}
exports.LogoutCommand = LogoutCommand;


/***/ }),

/***/ 65706:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(18972), exports);
tslib_1.__exportStar(__nccwpck_require__(1513), exports);
tslib_1.__exportStar(__nccwpck_require__(64296), exports);
tslib_1.__exportStar(__nccwpck_require__(12586), exports);


/***/ }),

/***/ 34214:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 30898:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(13341);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 13341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const p = "required", q = "fn", r = "argv", s = "ref";
const a = "PartitionResult", b = "tree", c = "error", d = "endpoint", e = { [p]: false, "type": "String" }, f = { [p]: true, "default": false, "type": "Boolean" }, g = { [s]: "Endpoint" }, h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] }, i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] }, j = {}, k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] }, l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] }, m = [g], n = [h], o = [i];
const _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 82666:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(71057), exports);
tslib_1.__exportStar(__nccwpck_require__(69838), exports);
tslib_1.__exportStar(__nccwpck_require__(65706), exports);
tslib_1.__exportStar(__nccwpck_require__(36773), exports);
tslib_1.__exportStar(__nccwpck_require__(14952), exports);
var SSOServiceException_1 = __nccwpck_require__(81517);
Object.defineProperty(exports, "SSOServiceException", ({ enumerable: true, get: function () { return SSOServiceException_1.SSOServiceException; } }));


/***/ }),

/***/ 81517:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class SSOServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
}
exports.SSOServiceException = SSOServiceException;


/***/ }),

/***/ 14952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(66390), exports);


/***/ }),

/***/ 66390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogoutRequestFilterSensitiveLog = exports.ListAccountsRequestFilterSensitiveLog = exports.ListAccountRolesRequestFilterSensitiveLog = exports.GetRoleCredentialsResponseFilterSensitiveLog = exports.RoleCredentialsFilterSensitiveLog = exports.GetRoleCredentialsRequestFilterSensitiveLog = exports.UnauthorizedException = exports.TooManyRequestsException = exports.ResourceNotFoundException = exports.InvalidRequestException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const SSOServiceException_1 = __nccwpck_require__(81517);
class InvalidRequestException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
}
exports.InvalidRequestException = InvalidRequestException;
class ResourceNotFoundException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
class TooManyRequestsException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
}
exports.TooManyRequestsException = TooManyRequestsException;
class UnauthorizedException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
}
exports.UnauthorizedException = UnauthorizedException;
const GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.GetRoleCredentialsRequestFilterSensitiveLog = GetRoleCredentialsRequestFilterSensitiveLog;
const RoleCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.secretAccessKey && { secretAccessKey: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.sessionToken && { sessionToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.RoleCredentialsFilterSensitiveLog = RoleCredentialsFilterSensitiveLog;
const GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.roleCredentials && { roleCredentials: (0, exports.RoleCredentialsFilterSensitiveLog)(obj.roleCredentials) }),
});
exports.GetRoleCredentialsResponseFilterSensitiveLog = GetRoleCredentialsResponseFilterSensitiveLog;
const ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.ListAccountRolesRequestFilterSensitiveLog = ListAccountRolesRequestFilterSensitiveLog;
const ListAccountsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.ListAccountsRequestFilterSensitiveLog = ListAccountsRequestFilterSensitiveLog;
const LogoutRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.LogoutRequestFilterSensitiveLog = LogoutRequestFilterSensitiveLog;


/***/ }),

/***/ 80849:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 88460:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccountRoles = void 0;
const ListAccountRolesCommand_1 = __nccwpck_require__(1513);
const SSOClient_1 = __nccwpck_require__(71057);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAccountRolesCommand_1.ListAccountRolesCommand(input), ...args);
};
async function* paginateListAccountRoles(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof SSOClient_1.SSOClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SSO | SSOClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccountRoles = paginateListAccountRoles;


/***/ }),

/***/ 50938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccounts = void 0;
const ListAccountsCommand_1 = __nccwpck_require__(64296);
const SSOClient_1 = __nccwpck_require__(71057);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAccountsCommand_1.ListAccountsCommand(input), ...args);
};
async function* paginateListAccounts(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof SSOClient_1.SSOClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SSO | SSOClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccounts = paginateListAccounts;


/***/ }),

/***/ 36773:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80849), exports);
tslib_1.__exportStar(__nccwpck_require__(88460), exports);
tslib_1.__exportStar(__nccwpck_require__(50938), exports);


/***/ }),

/***/ 98507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.de_LogoutCommand = exports.de_ListAccountsCommand = exports.de_ListAccountRolesCommand = exports.de_GetRoleCredentialsCommand = exports.se_LogoutCommand = exports.se_ListAccountsCommand = exports.se_ListAccountRolesCommand = exports.se_GetRoleCredentialsCommand = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const models_0_1 = __nccwpck_require__(66390);
const SSOServiceException_1 = __nccwpck_require__(81517);
const se_GetRoleCredentialsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/federation/credentials";
    const query = (0, smithy_client_1.map)({
        role_name: [, (0, smithy_client_1.expectNonNull)(input.roleName, `roleName`)],
        account_id: [, (0, smithy_client_1.expectNonNull)(input.accountId, `accountId`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetRoleCredentialsCommand = se_GetRoleCredentialsCommand;
const se_ListAccountRolesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/roles";
    const query = (0, smithy_client_1.map)({
        next_token: [, input.nextToken],
        max_result: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        account_id: [, (0, smithy_client_1.expectNonNull)(input.accountId, `accountId`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListAccountRolesCommand = se_ListAccountRolesCommand;
const se_ListAccountsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/accounts";
    const query = (0, smithy_client_1.map)({
        next_token: [, input.nextToken],
        max_result: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListAccountsCommand = se_ListAccountsCommand;
const se_LogoutCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/logout";
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_LogoutCommand = se_LogoutCommand;
const de_GetRoleCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRoleCredentialsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        roleCredentials: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRoleCredentialsCommand = de_GetRoleCredentialsCommand;
const de_GetRoleCredentialsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAccountRolesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccountRolesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        roleList: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAccountRolesCommand = de_ListAccountRolesCommand;
const de_ListAccountRolesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAccountsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccountsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        accountList: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAccountsCommand = de_ListAccountsCommand;
const de_ListAccountsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_LogoutCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_LogoutCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_LogoutCommand = de_LogoutCommand;
const de_LogoutCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(SSOServiceException_1.SSOServiceException);
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 19756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(91092));
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(44809);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 44809:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const endpointResolver_1 = __nccwpck_require__(30898);
const getRuntimeConfig = (config) => ({
    apiVersion: "2019-06-10",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "SSO",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
    utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 32605:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STS = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const AssumeRoleCommand_1 = __nccwpck_require__(59802);
const AssumeRoleWithSAMLCommand_1 = __nccwpck_require__(72865);
const AssumeRoleWithWebIdentityCommand_1 = __nccwpck_require__(37451);
const DecodeAuthorizationMessageCommand_1 = __nccwpck_require__(74150);
const GetAccessKeyInfoCommand_1 = __nccwpck_require__(49804);
const GetCallerIdentityCommand_1 = __nccwpck_require__(24278);
const GetFederationTokenCommand_1 = __nccwpck_require__(57552);
const GetSessionTokenCommand_1 = __nccwpck_require__(43285);
const STSClient_1 = __nccwpck_require__(64195);
const commands = {
    AssumeRoleCommand: AssumeRoleCommand_1.AssumeRoleCommand,
    AssumeRoleWithSAMLCommand: AssumeRoleWithSAMLCommand_1.AssumeRoleWithSAMLCommand,
    AssumeRoleWithWebIdentityCommand: AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand,
    DecodeAuthorizationMessageCommand: DecodeAuthorizationMessageCommand_1.DecodeAuthorizationMessageCommand,
    GetAccessKeyInfoCommand: GetAccessKeyInfoCommand_1.GetAccessKeyInfoCommand,
    GetCallerIdentityCommand: GetCallerIdentityCommand_1.GetCallerIdentityCommand,
    GetFederationTokenCommand: GetFederationTokenCommand_1.GetFederationTokenCommand,
    GetSessionTokenCommand: GetSessionTokenCommand_1.GetSessionTokenCommand,
};
class STS extends STSClient_1.STSClient {
}
exports.STS = STS;
(0, smithy_client_1.createAggregatedClient)(commands, STS);


/***/ }),

/***/ 64195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSClient = exports.__Client = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_sdk_sts_1 = __nccwpck_require__(55959);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const runtimeConfig_1 = __nccwpck_require__(83405);
class STSClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_sdk_sts_1.resolveStsAuthConfig)(_config_5, { stsClientCtor: STSClient });
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.STSClient = STSClient;


/***/ }),

/***/ 59802:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleCommand = exports.$Command = void 0;
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: models_0_1.AssumeRoleResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AssumeRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AssumeRoleCommand)(output, context);
    }
}
exports.AssumeRoleCommand = AssumeRoleCommand;


/***/ }),

/***/ 72865:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleWithSAMLCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleWithSAMLCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleWithSAMLCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleWithSAMLCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AssumeRoleWithSAMLCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AssumeRoleWithSAMLCommand)(output, context);
    }
}
exports.AssumeRoleWithSAMLCommand = AssumeRoleWithSAMLCommand;


/***/ }),

/***/ 37451:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleWithWebIdentityCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleWithWebIdentityCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleWithWebIdentityCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AssumeRoleWithWebIdentityCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AssumeRoleWithWebIdentityCommand)(output, context);
    }
}
exports.AssumeRoleWithWebIdentityCommand = AssumeRoleWithWebIdentityCommand;


/***/ }),

/***/ 74150:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecodeAuthorizationMessageCommand = exports.$Command = void 0;
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(10740);
class DecodeAuthorizationMessageCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DecodeAuthorizationMessageCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "DecodeAuthorizationMessageCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DecodeAuthorizationMessageCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DecodeAuthorizationMessageCommand)(output, context);
    }
}
exports.DecodeAuthorizationMessageCommand = DecodeAuthorizationMessageCommand;


/***/ }),

/***/ 49804:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAccessKeyInfoCommand = exports.$Command = void 0;
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(10740);
class GetAccessKeyInfoCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAccessKeyInfoCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetAccessKeyInfoCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetAccessKeyInfoCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetAccessKeyInfoCommand)(output, context);
    }
}
exports.GetAccessKeyInfoCommand = GetAccessKeyInfoCommand;


/***/ }),

/***/ 24278:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCallerIdentityCommand = exports.$Command = void 0;
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const Aws_query_1 = __nccwpck_require__(10740);
class GetCallerIdentityCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetCallerIdentityCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetCallerIdentityCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetCallerIdentityCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetCallerIdentityCommand)(output, context);
    }
}
exports.GetCallerIdentityCommand = GetCallerIdentityCommand;


/***/ }),

/***/ 57552:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFederationTokenCommand = exports.$Command = void 0;
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class GetFederationTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetFederationTokenCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetFederationTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: models_0_1.GetFederationTokenResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetFederationTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetFederationTokenCommand)(output, context);
    }
}
exports.GetFederationTokenCommand = GetFederationTokenCommand;


/***/ }),

/***/ 43285:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSessionTokenCommand = exports.$Command = void 0;
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class GetSessionTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    constructor(input) {
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetSessionTokenCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetSessionTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: models_0_1.GetSessionTokenResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetSessionTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetSessionTokenCommand)(output, context);
    }
}
exports.GetSessionTokenCommand = GetSessionTokenCommand;


/***/ }),

/***/ 55716:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(59802), exports);
tslib_1.__exportStar(__nccwpck_require__(72865), exports);
tslib_1.__exportStar(__nccwpck_require__(37451), exports);
tslib_1.__exportStar(__nccwpck_require__(74150), exports);
tslib_1.__exportStar(__nccwpck_require__(49804), exports);
tslib_1.__exportStar(__nccwpck_require__(24278), exports);
tslib_1.__exportStar(__nccwpck_require__(57552), exports);
tslib_1.__exportStar(__nccwpck_require__(43285), exports);


/***/ }),

/***/ 88028:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
const defaultStsRoleAssumers_1 = __nccwpck_require__(90048);
const STSClient_1 = __nccwpck_require__(64195);
const getCustomizableStsClientCtor = (baseCtor, customizations) => {
    if (!customizations)
        return baseCtor;
    else
        return class CustomizableSTSClient extends baseCtor {
            constructor(config) {
                super(config);
                for (const customization of customizations) {
                    this.middlewareStack.use(customization);
                }
            }
        };
};
const getDefaultRoleAssumer = (stsOptions = {}, stsPlugins) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumer)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
const getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumerWithWebIdentity)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
const decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: (0, exports.getDefaultRoleAssumer)(input),
    roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input),
    ...input,
});
exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


/***/ }),

/***/ 90048:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
const AssumeRoleCommand_1 = __nccwpck_require__(59802);
const AssumeRoleWithWebIdentityCommand_1 = __nccwpck_require__(37451);
const ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
const decorateDefaultRegion = (region) => {
    if (typeof region !== "function") {
        return region === undefined ? ASSUME_ROLE_DEFAULT_REGION : region;
    }
    return async () => {
        try {
            return await region();
        }
        catch (e) {
            return ASSUME_ROLE_DEFAULT_REGION;
        }
    };
};
const getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params) => {
        closureSourceCreds = sourceCreds;
        if (!stsClient) {
            const { logger, region, requestHandler } = stsOptions;
            stsClient = new stsClientCtor({
                logger,
                credentialDefaultProvider: () => async () => closureSourceCreds,
                region: decorateDefaultRegion(region || stsOptions.region),
                ...(requestHandler ? { requestHandler } : {}),
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleCommand_1.AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration,
        };
    };
};
exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
const getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
    let stsClient;
    return async (params) => {
        if (!stsClient) {
            const { logger, region, requestHandler } = stsOptions;
            stsClient = new stsClientCtor({
                logger,
                region: decorateDefaultRegion(region || stsOptions.region),
                ...(requestHandler ? { requestHandler } : {}),
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration,
        };
    };
};
exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
const decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: (0, exports.getDefaultRoleAssumer)(input, input.stsClientCtor),
    roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input, input.stsClientCtor),
    ...input,
});
exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


/***/ }),

/***/ 20510:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        defaultSigningName: "sts",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 41203:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(86882);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 86882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const F = "required", G = "type", H = "fn", I = "argv", J = "ref";
const a = false, b = true, c = "booleanEquals", d = "tree", e = "stringEquals", f = "sigv4", g = "sts", h = "us-east-1", i = "endpoint", j = "https://sts.{Region}.{PartitionResult#dnsSuffix}", k = "error", l = "getAttr", m = { [F]: false, [G]: "String" }, n = { [F]: true, "default": false, [G]: "Boolean" }, o = { [J]: "Endpoint" }, p = { [H]: "isSet", [I]: [{ [J]: "Region" }] }, q = { [J]: "Region" }, r = { [H]: "aws.partition", [I]: [q], "assign": "PartitionResult" }, s = { [J]: "UseFIPS" }, t = { [J]: "UseDualStack" }, u = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": f, "signingName": g, "signingRegion": h }] }, "headers": {} }, v = {}, w = { "conditions": [{ [H]: e, [I]: [q, "aws-global"] }], [i]: u, [G]: i }, x = { [H]: c, [I]: [s, true] }, y = { [H]: c, [I]: [t, true] }, z = { [H]: c, [I]: [true, { [H]: l, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] }] }, A = { [J]: "PartitionResult" }, B = { [H]: c, [I]: [true, { [H]: l, [I]: [A, "supportsDualStack"] }] }, C = [{ [H]: "isSet", [I]: [o] }], D = [x], E = [y];
const _data = { version: "1.0", parameters: { Region: m, UseDualStack: n, UseFIPS: n, Endpoint: m, UseGlobalEndpoint: n }, rules: [{ conditions: [{ [H]: c, [I]: [{ [J]: "UseGlobalEndpoint" }, b] }, { [H]: "not", [I]: C }, p, r, { [H]: c, [I]: [s, a] }, { [H]: c, [I]: [t, a] }], [G]: d, rules: [{ conditions: [{ [H]: e, [I]: [q, "ap-northeast-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "ap-south-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "ap-southeast-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "ap-southeast-2"] }], endpoint: u, [G]: i }, w, { conditions: [{ [H]: e, [I]: [q, "ca-central-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "eu-central-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "eu-north-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "eu-west-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "eu-west-2"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "eu-west-3"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "sa-east-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, h] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "us-east-2"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "us-west-1"] }], endpoint: u, [G]: i }, { conditions: [{ [H]: e, [I]: [q, "us-west-2"] }], endpoint: u, [G]: i }, { endpoint: { url: j, properties: { authSchemes: [{ name: f, signingName: g, signingRegion: "{Region}" }] }, headers: v }, [G]: i }] }, { conditions: C, [G]: d, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k }, { [G]: d, rules: [{ conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k }, { endpoint: { url: o, properties: v, headers: v }, [G]: i }] }] }, { [G]: d, rules: [{ conditions: [p], [G]: d, rules: [{ conditions: [r], [G]: d, rules: [{ conditions: [x, y], [G]: d, rules: [{ conditions: [z, B], [G]: d, rules: [{ [G]: d, rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: i }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k }] }, { conditions: D, [G]: d, rules: [{ conditions: [z], [G]: d, rules: [{ [G]: d, rules: [{ conditions: [{ [H]: e, [I]: ["aws-us-gov", { [H]: l, [I]: [A, "name"] }] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v, headers: v }, [G]: i }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v, headers: v }, [G]: i }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k }] }, { conditions: E, [G]: d, rules: [{ conditions: [B], [G]: d, rules: [{ [G]: d, rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: i }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k }] }, { [G]: d, rules: [w, { endpoint: { url: j, properties: v, headers: v }, [G]: i }] }] }] }, { error: "Invalid Configuration: Missing Region", [G]: k }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 52209:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(64195), exports);
tslib_1.__exportStar(__nccwpck_require__(32605), exports);
tslib_1.__exportStar(__nccwpck_require__(55716), exports);
tslib_1.__exportStar(__nccwpck_require__(20106), exports);
tslib_1.__exportStar(__nccwpck_require__(88028), exports);
var STSServiceException_1 = __nccwpck_require__(26450);
Object.defineProperty(exports, "STSServiceException", ({ enumerable: true, get: function () { return STSServiceException_1.STSServiceException; } }));


/***/ }),

/***/ 26450:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class STSServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, STSServiceException.prototype);
    }
}
exports.STSServiceException = STSServiceException;


/***/ }),

/***/ 20106:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(21780), exports);


/***/ }),

/***/ 21780:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSessionTokenResponseFilterSensitiveLog = exports.GetFederationTokenResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = exports.AssumeRoleResponseFilterSensitiveLog = exports.CredentialsFilterSensitiveLog = exports.InvalidAuthorizationMessageException = exports.IDPCommunicationErrorException = exports.InvalidIdentityTokenException = exports.IDPRejectedClaimException = exports.RegionDisabledException = exports.PackedPolicyTooLargeException = exports.MalformedPolicyDocumentException = exports.ExpiredTokenException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const STSServiceException_1 = __nccwpck_require__(26450);
class ExpiredTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredTokenException.prototype);
    }
}
exports.ExpiredTokenException = ExpiredTokenException;
class MalformedPolicyDocumentException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedPolicyDocumentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
}
exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;
class PackedPolicyTooLargeException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "PackedPolicyTooLargeException",
            $fault: "client",
            ...opts,
        });
        this.name = "PackedPolicyTooLargeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
}
exports.PackedPolicyTooLargeException = PackedPolicyTooLargeException;
class RegionDisabledException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "RegionDisabledException",
            $fault: "client",
            ...opts,
        });
        this.name = "RegionDisabledException";
        this.$fault = "client";
        Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
}
exports.RegionDisabledException = RegionDisabledException;
class IDPRejectedClaimException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "IDPRejectedClaimException",
            $fault: "client",
            ...opts,
        });
        this.name = "IDPRejectedClaimException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
}
exports.IDPRejectedClaimException = IDPRejectedClaimException;
class InvalidIdentityTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "InvalidIdentityTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidIdentityTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
}
exports.InvalidIdentityTokenException = InvalidIdentityTokenException;
class IDPCommunicationErrorException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "IDPCommunicationErrorException",
            $fault: "client",
            ...opts,
        });
        this.name = "IDPCommunicationErrorException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
}
exports.IDPCommunicationErrorException = IDPCommunicationErrorException;
class InvalidAuthorizationMessageException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "InvalidAuthorizationMessageException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAuthorizationMessageException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
    }
}
exports.InvalidAuthorizationMessageException = InvalidAuthorizationMessageException;
const CredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SecretAccessKey && { SecretAccessKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.CredentialsFilterSensitiveLog = CredentialsFilterSensitiveLog;
const AssumeRoleResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.AssumeRoleResponseFilterSensitiveLog = AssumeRoleResponseFilterSensitiveLog;
const AssumeRoleWithSAMLRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SAMLAssertion && { SAMLAssertion: smithy_client_1.SENSITIVE_STRING }),
});
exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = AssumeRoleWithSAMLRequestFilterSensitiveLog;
const AssumeRoleWithSAMLResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = AssumeRoleWithSAMLResponseFilterSensitiveLog;
const AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.WebIdentityToken && { WebIdentityToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = AssumeRoleWithWebIdentityRequestFilterSensitiveLog;
const AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = AssumeRoleWithWebIdentityResponseFilterSensitiveLog;
const GetFederationTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.GetFederationTokenResponseFilterSensitiveLog = GetFederationTokenResponseFilterSensitiveLog;
const GetSessionTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.GetSessionTokenResponseFilterSensitiveLog = GetSessionTokenResponseFilterSensitiveLog;


/***/ }),

/***/ 10740:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.de_GetSessionTokenCommand = exports.de_GetFederationTokenCommand = exports.de_GetCallerIdentityCommand = exports.de_GetAccessKeyInfoCommand = exports.de_DecodeAuthorizationMessageCommand = exports.de_AssumeRoleWithWebIdentityCommand = exports.de_AssumeRoleWithSAMLCommand = exports.de_AssumeRoleCommand = exports.se_GetSessionTokenCommand = exports.se_GetFederationTokenCommand = exports.se_GetCallerIdentityCommand = exports.se_GetAccessKeyInfoCommand = exports.se_DecodeAuthorizationMessageCommand = exports.se_AssumeRoleWithWebIdentityCommand = exports.se_AssumeRoleWithSAMLCommand = exports.se_AssumeRoleCommand = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const fast_xml_parser_1 = __nccwpck_require__(12603);
const models_0_1 = __nccwpck_require__(21780);
const STSServiceException_1 = __nccwpck_require__(26450);
const se_AssumeRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleRequest(input, context),
        Action: "AssumeRole",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleCommand = se_AssumeRoleCommand;
const se_AssumeRoleWithSAMLCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleWithSAMLRequest(input, context),
        Action: "AssumeRoleWithSAML",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleWithSAMLCommand = se_AssumeRoleWithSAMLCommand;
const se_AssumeRoleWithWebIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleWithWebIdentityRequest(input, context),
        Action: "AssumeRoleWithWebIdentity",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleWithWebIdentityCommand = se_AssumeRoleWithWebIdentityCommand;
const se_DecodeAuthorizationMessageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DecodeAuthorizationMessageRequest(input, context),
        Action: "DecodeAuthorizationMessage",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DecodeAuthorizationMessageCommand = se_DecodeAuthorizationMessageCommand;
const se_GetAccessKeyInfoCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccessKeyInfoRequest(input, context),
        Action: "GetAccessKeyInfo",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAccessKeyInfoCommand = se_GetAccessKeyInfoCommand;
const se_GetCallerIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetCallerIdentityRequest(input, context),
        Action: "GetCallerIdentity",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCallerIdentityCommand = se_GetCallerIdentityCommand;
const se_GetFederationTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetFederationTokenRequest(input, context),
        Action: "GetFederationToken",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetFederationTokenCommand = se_GetFederationTokenCommand;
const se_GetSessionTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSessionTokenRequest(input, context),
        Action: "GetSessionToken",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetSessionTokenCommand = se_GetSessionTokenCommand;
const de_AssumeRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AssumeRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleResponse(data.AssumeRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AssumeRoleCommand = de_AssumeRoleCommand;
const de_AssumeRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AssumeRoleWithSAMLCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AssumeRoleWithSAMLCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithSAMLResponse(data.AssumeRoleWithSAMLResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AssumeRoleWithSAMLCommand = de_AssumeRoleWithSAMLCommand;
const de_AssumeRoleWithSAMLCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AssumeRoleWithWebIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AssumeRoleWithWebIdentityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AssumeRoleWithWebIdentityCommand = de_AssumeRoleWithWebIdentityCommand;
const de_AssumeRoleWithWebIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
            throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DecodeAuthorizationMessageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DecodeAuthorizationMessageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DecodeAuthorizationMessageResponse(data.DecodeAuthorizationMessageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DecodeAuthorizationMessageCommand = de_DecodeAuthorizationMessageCommand;
const de_DecodeAuthorizationMessageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidAuthorizationMessageException":
        case "com.amazonaws.sts#InvalidAuthorizationMessageException":
            throw await de_InvalidAuthorizationMessageExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetAccessKeyInfoCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccessKeyInfoCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccessKeyInfoResponse(data.GetAccessKeyInfoResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetAccessKeyInfoCommand = de_GetAccessKeyInfoCommand;
const de_GetAccessKeyInfoCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_GetCallerIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCallerIdentityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCallerIdentityResponse(data.GetCallerIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetCallerIdentityCommand = de_GetCallerIdentityCommand;
const de_GetCallerIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_GetFederationTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetFederationTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetFederationTokenResponse(data.GetFederationTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetFederationTokenCommand = de_GetFederationTokenCommand;
const de_GetFederationTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetSessionTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetSessionTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSessionTokenResponse(data.GetSessionTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetSessionTokenCommand = de_GetSessionTokenCommand;
const de_GetSessionTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ExpiredTokenException(body.Error, context);
    const exception = new models_0_1.ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPCommunicationErrorException(body.Error, context);
    const exception = new models_0_1.IDPCommunicationErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IDPRejectedClaimExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPRejectedClaimException(body.Error, context);
    const exception = new models_0_1.IDPRejectedClaimException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAuthorizationMessageExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthorizationMessageException(body.Error, context);
    const exception = new models_0_1.InvalidAuthorizationMessageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidIdentityTokenException(body.Error, context);
    const exception = new models_0_1.InvalidIdentityTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new models_0_1.MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PackedPolicyTooLargeException(body.Error, context);
    const exception = new models_0_1.PackedPolicyTooLargeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RegionDisabledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RegionDisabledException(body.Error, context);
    const exception = new models_0_1.RegionDisabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_AssumeRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.RoleSessionName != null) {
        entries["RoleSessionName"] = input.RoleSessionName;
    }
    if (input.PolicyArns != null) {
        const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TransitiveTagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TransitiveTagKeys, context);
        if (input.TransitiveTagKeys?.length === 0) {
            entries.TransitiveTagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitiveTagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ExternalId != null) {
        entries["ExternalId"] = input.ExternalId;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.TokenCode != null) {
        entries["TokenCode"] = input.TokenCode;
    }
    if (input.SourceIdentity != null) {
        entries["SourceIdentity"] = input.SourceIdentity;
    }
    if (input.ProvidedContexts != null) {
        const memberEntries = se_ProvidedContextsListType(input.ProvidedContexts, context);
        if (input.ProvidedContexts?.length === 0) {
            entries.ProvidedContexts = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ProvidedContexts.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AssumeRoleWithSAMLRequest = (input, context) => {
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.PrincipalArn != null) {
        entries["PrincipalArn"] = input.PrincipalArn;
    }
    if (input.SAMLAssertion != null) {
        entries["SAMLAssertion"] = input.SAMLAssertion;
    }
    if (input.PolicyArns != null) {
        const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    return entries;
};
const se_AssumeRoleWithWebIdentityRequest = (input, context) => {
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.RoleSessionName != null) {
        entries["RoleSessionName"] = input.RoleSessionName;
    }
    if (input.WebIdentityToken != null) {
        entries["WebIdentityToken"] = input.WebIdentityToken;
    }
    if (input.ProviderId != null) {
        entries["ProviderId"] = input.ProviderId;
    }
    if (input.PolicyArns != null) {
        const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    return entries;
};
const se_DecodeAuthorizationMessageRequest = (input, context) => {
    const entries = {};
    if (input.EncodedMessage != null) {
        entries["EncodedMessage"] = input.EncodedMessage;
    }
    return entries;
};
const se_GetAccessKeyInfoRequest = (input, context) => {
    const entries = {};
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    return entries;
};
const se_GetCallerIdentityRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_GetFederationTokenRequest = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.PolicyArns != null) {
        const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetSessionTokenRequest = (input, context) => {
    const entries = {};
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.TokenCode != null) {
        entries["TokenCode"] = input.TokenCode;
    }
    return entries;
};
const se_policyDescriptorListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PolicyDescriptorType(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PolicyDescriptorType = (input, context) => {
    const entries = {};
    if (input.arn != null) {
        entries["arn"] = input.arn;
    }
    return entries;
};
const se_ProvidedContext = (input, context) => {
    const entries = {};
    if (input.ProviderArn != null) {
        entries["ProviderArn"] = input.ProviderArn;
    }
    if (input.ContextAssertion != null) {
        entries["ContextAssertion"] = input.ContextAssertion;
    }
    return entries;
};
const se_ProvidedContextsListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ProvidedContext(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_tagKeyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_tagListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const de_AssumedRoleUser = (output, context) => {
    const contents = {};
    if (output["AssumedRoleId"] !== undefined) {
        contents.AssumedRoleId = (0, smithy_client_1.expectString)(output["AssumedRoleId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const de_AssumeRoleResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const de_AssumeRoleWithSAMLResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["Subject"] !== undefined) {
        contents.Subject = (0, smithy_client_1.expectString)(output["Subject"]);
    }
    if (output["SubjectType"] !== undefined) {
        contents.SubjectType = (0, smithy_client_1.expectString)(output["SubjectType"]);
    }
    if (output["Issuer"] !== undefined) {
        contents.Issuer = (0, smithy_client_1.expectString)(output["Issuer"]);
    }
    if (output["Audience"] !== undefined) {
        contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
    }
    if (output["NameQualifier"] !== undefined) {
        contents.NameQualifier = (0, smithy_client_1.expectString)(output["NameQualifier"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const de_AssumeRoleWithWebIdentityResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["SubjectFromWebIdentityToken"] !== undefined) {
        contents.SubjectFromWebIdentityToken = (0, smithy_client_1.expectString)(output["SubjectFromWebIdentityToken"]);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["Provider"] !== undefined) {
        contents.Provider = (0, smithy_client_1.expectString)(output["Provider"]);
    }
    if (output["Audience"] !== undefined) {
        contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const de_Credentials = (output, context) => {
    const contents = {};
    if (output["AccessKeyId"] !== undefined) {
        contents.AccessKeyId = (0, smithy_client_1.expectString)(output["AccessKeyId"]);
    }
    if (output["SecretAccessKey"] !== undefined) {
        contents.SecretAccessKey = (0, smithy_client_1.expectString)(output["SecretAccessKey"]);
    }
    if (output["SessionToken"] !== undefined) {
        contents.SessionToken = (0, smithy_client_1.expectString)(output["SessionToken"]);
    }
    if (output["Expiration"] !== undefined) {
        contents.Expiration = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["Expiration"]));
    }
    return contents;
};
const de_DecodeAuthorizationMessageResponse = (output, context) => {
    const contents = {};
    if (output["DecodedMessage"] !== undefined) {
        contents.DecodedMessage = (0, smithy_client_1.expectString)(output["DecodedMessage"]);
    }
    return contents;
};
const de_ExpiredTokenException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_FederatedUser = (output, context) => {
    const contents = {};
    if (output["FederatedUserId"] !== undefined) {
        contents.FederatedUserId = (0, smithy_client_1.expectString)(output["FederatedUserId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const de_GetAccessKeyInfoResponse = (output, context) => {
    const contents = {};
    if (output["Account"] !== undefined) {
        contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    return contents;
};
const de_GetCallerIdentityResponse = (output, context) => {
    const contents = {};
    if (output["UserId"] !== undefined) {
        contents.UserId = (0, smithy_client_1.expectString)(output["UserId"]);
    }
    if (output["Account"] !== undefined) {
        contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const de_GetFederationTokenResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["FederatedUser"] !== undefined) {
        contents.FederatedUser = de_FederatedUser(output["FederatedUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    return contents;
};
const de_GetSessionTokenResponse = (output, context) => {
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    return contents;
};
const de_IDPCommunicationErrorException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_IDPRejectedClaimException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_InvalidAuthorizationMessageException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_InvalidIdentityTokenException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_MalformedPolicyDocumentException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_PackedPolicyTooLargeException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_RegionDisabledException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(STSServiceException_1.STSServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => (0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};


/***/ }),

/***/ 83405:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(7947));
const defaultStsRoleAssumers_1 = __nccwpck_require__(90048);
const credential_provider_node_1 = __nccwpck_require__(75531);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(52642);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, defaultStsRoleAssumers_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 52642:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const endpointResolver_1 = __nccwpck_require__(41203);
const getRuntimeConfig = (config) => ({
    apiVersion: "2011-06-15",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "STS",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
    utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 80255:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromEnv = exports.ENV_EXPIRATION = exports.ENV_SESSION = exports.ENV_SECRET = exports.ENV_KEY = void 0;
const property_provider_1 = __nccwpck_require__(79721);
exports.ENV_KEY = "AWS_ACCESS_KEY_ID";
exports.ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
exports.ENV_SESSION = "AWS_SESSION_TOKEN";
exports.ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
const fromEnv = () => async () => {
    const accessKeyId = process.env[exports.ENV_KEY];
    const secretAccessKey = process.env[exports.ENV_SECRET];
    const sessionToken = process.env[exports.ENV_SESSION];
    const expiry = process.env[exports.ENV_EXPIRATION];
    if (accessKeyId && secretAccessKey) {
        return {
            accessKeyId,
            secretAccessKey,
            ...(sessionToken && { sessionToken }),
            ...(expiry && { expiration: new Date(expiry) }),
        };
    }
    throw new property_provider_1.CredentialsProviderError("Unable to find environment variable credentials.");
};
exports.fromEnv = fromEnv;


/***/ }),

/***/ 15972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80255), exports);


/***/ }),

/***/ 55442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromIni = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const resolveProfileData_1 = __nccwpck_require__(95653);
const fromIni = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    return (0, resolveProfileData_1.resolveProfileData)((0, shared_ini_file_loader_1.getProfileName)(init), profiles, init);
};
exports.fromIni = fromIni;


/***/ }),

/***/ 74203:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(55442), exports);


/***/ }),

/***/ 60853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAssumeRoleCredentials = exports.isAssumeRoleProfile = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const resolveCredentialSource_1 = __nccwpck_require__(82458);
const resolveProfileData_1 = __nccwpck_require__(95653);
const isAssumeRoleProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.role_arn === "string" &&
    ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 &&
    ["undefined", "string"].indexOf(typeof arg.external_id) > -1 &&
    ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 &&
    (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
exports.isAssumeRoleProfile = isAssumeRoleProfile;
const isAssumeRoleWithSourceProfile = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
const isAssumeRoleWithProviderProfile = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
const resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (!options.roleAssumer) {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
    }
    const { source_profile } = data;
    if (source_profile && source_profile in visitedProfiles) {
        throw new property_provider_1.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile` +
            ` ${(0, shared_ini_file_loader_1.getProfileName)(options)}. Profiles visited: ` +
            Object.keys(visitedProfiles).join(", "), false);
    }
    const sourceCredsProvider = source_profile
        ? (0, resolveProfileData_1.resolveProfileData)(source_profile, profiles, options, {
            ...visitedProfiles,
            [source_profile]: true,
        })
        : (0, resolveCredentialSource_1.resolveCredentialSource)(data.credential_source, profileName)();
    const params = {
        RoleArn: data.role_arn,
        RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
        ExternalId: data.external_id,
    };
    const { mfa_serial } = data;
    if (mfa_serial) {
        if (!options.mfaCodeProvider) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
        }
        params.SerialNumber = mfa_serial;
        params.TokenCode = await options.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options.roleAssumer(sourceCreds, params);
};
exports.resolveAssumeRoleCredentials = resolveAssumeRoleCredentials;


/***/ }),

/***/ 82458:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveCredentialSource = void 0;
const credential_provider_env_1 = __nccwpck_require__(15972);
const credential_provider_imds_1 = __nccwpck_require__(7477);
const property_provider_1 = __nccwpck_require__(79721);
const resolveCredentialSource = (credentialSource, profileName) => {
    const sourceProvidersMap = {
        EcsContainer: credential_provider_imds_1.fromContainerMetadata,
        Ec2InstanceMetadata: credential_provider_imds_1.fromInstanceMetadata,
        Environment: credential_provider_env_1.fromEnv,
    };
    if (credentialSource in sourceProvidersMap) {
        return sourceProvidersMap[credentialSource]();
    }
    else {
        throw new property_provider_1.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, ` +
            `expected EcsContainer or Ec2InstanceMetadata or Environment.`);
    }
};
exports.resolveCredentialSource = resolveCredentialSource;


/***/ }),

/***/ 69993:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProcessCredentials = exports.isProcessProfile = void 0;
const credential_provider_process_1 = __nccwpck_require__(89969);
const isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
exports.isProcessProfile = isProcessProfile;
const resolveProcessCredentials = async (options, profile) => (0, credential_provider_process_1.fromProcess)({
    ...options,
    profile,
})();
exports.resolveProcessCredentials = resolveProcessCredentials;


/***/ }),

/***/ 95653:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProfileData = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const resolveAssumeRoleCredentials_1 = __nccwpck_require__(60853);
const resolveProcessCredentials_1 = __nccwpck_require__(69993);
const resolveSsoCredentials_1 = __nccwpck_require__(59867);
const resolveStaticCredentials_1 = __nccwpck_require__(33071);
const resolveWebIdentityCredentials_1 = __nccwpck_require__(58342);
const resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (Object.keys(visitedProfiles).length > 0 && (0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
        return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveAssumeRoleCredentials_1.isAssumeRoleProfile)(data)) {
        return (0, resolveAssumeRoleCredentials_1.resolveAssumeRoleCredentials)(profileName, profiles, options, visitedProfiles);
    }
    if ((0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
        return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveWebIdentityCredentials_1.isWebIdentityProfile)(data)) {
        return (0, resolveWebIdentityCredentials_1.resolveWebIdentityCredentials)(data, options);
    }
    if ((0, resolveProcessCredentials_1.isProcessProfile)(data)) {
        return (0, resolveProcessCredentials_1.resolveProcessCredentials)(options, profileName);
    }
    if ((0, resolveSsoCredentials_1.isSsoProfile)(data)) {
        return (0, resolveSsoCredentials_1.resolveSsoCredentials)(data);
    }
    throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
};
exports.resolveProfileData = resolveProfileData;


/***/ }),

/***/ 59867:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSsoCredentials = exports.isSsoProfile = void 0;
const credential_provider_sso_1 = __nccwpck_require__(26414);
var credential_provider_sso_2 = __nccwpck_require__(26414);
Object.defineProperty(exports, "isSsoProfile", ({ enumerable: true, get: function () { return credential_provider_sso_2.isSsoProfile; } }));
const resolveSsoCredentials = (data) => {
    const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = (0, credential_provider_sso_1.validateSsoProfile)(data);
    return (0, credential_provider_sso_1.fromSSO)({
        ssoStartUrl: sso_start_url,
        ssoAccountId: sso_account_id,
        ssoSession: sso_session,
        ssoRegion: sso_region,
        ssoRoleName: sso_role_name,
    })();
};
exports.resolveSsoCredentials = resolveSsoCredentials;


/***/ }),

/***/ 33071:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveStaticCredentials = exports.isStaticCredsProfile = void 0;
const isStaticCredsProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.aws_access_key_id === "string" &&
    typeof arg.aws_secret_access_key === "string" &&
    ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
exports.isStaticCredsProfile = isStaticCredsProfile;
const resolveStaticCredentials = (profile) => Promise.resolve({
    accessKeyId: profile.aws_access_key_id,
    secretAccessKey: profile.aws_secret_access_key,
    sessionToken: profile.aws_session_token,
});
exports.resolveStaticCredentials = resolveStaticCredentials;


/***/ }),

/***/ 58342:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveWebIdentityCredentials = exports.isWebIdentityProfile = void 0;
const credential_provider_web_identity_1 = __nccwpck_require__(15646);
const isWebIdentityProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.web_identity_token_file === "string" &&
    typeof arg.role_arn === "string" &&
    ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
exports.isWebIdentityProfile = isWebIdentityProfile;
const resolveWebIdentityCredentials = async (profile, options) => (0, credential_provider_web_identity_1.fromTokenFile)({
    webIdentityTokenFile: profile.web_identity_token_file,
    roleArn: profile.role_arn,
    roleSessionName: profile.role_session_name,
    roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
})();
exports.resolveWebIdentityCredentials = resolveWebIdentityCredentials;


/***/ }),

/***/ 15560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultProvider = void 0;
const credential_provider_env_1 = __nccwpck_require__(15972);
const credential_provider_ini_1 = __nccwpck_require__(74203);
const credential_provider_process_1 = __nccwpck_require__(89969);
const credential_provider_sso_1 = __nccwpck_require__(26414);
const credential_provider_web_identity_1 = __nccwpck_require__(15646);
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const remoteProvider_1 = __nccwpck_require__(50626);
const defaultProvider = (init = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)(...(init.profile || process.env[shared_ini_file_loader_1.ENV_PROFILE] ? [] : [(0, credential_provider_env_1.fromEnv)()]), (0, credential_provider_sso_1.fromSSO)(init), (0, credential_provider_ini_1.fromIni)(init), (0, credential_provider_process_1.fromProcess)(init), (0, credential_provider_web_identity_1.fromTokenFile)(init), (0, remoteProvider_1.remoteProvider)(init), async () => {
    throw new property_provider_1.CredentialsProviderError("Could not load credentials from any providers", false);
}), (credentials) => credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000, (credentials) => credentials.expiration !== undefined);
exports.defaultProvider = defaultProvider;


/***/ }),

/***/ 75531:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(15560), exports);


/***/ }),

/***/ 50626:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.remoteProvider = exports.ENV_IMDS_DISABLED = void 0;
const credential_provider_imds_1 = __nccwpck_require__(7477);
const property_provider_1 = __nccwpck_require__(79721);
exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const remoteProvider = (init) => {
    if (process.env[credential_provider_imds_1.ENV_CMDS_RELATIVE_URI] || process.env[credential_provider_imds_1.ENV_CMDS_FULL_URI]) {
        return (0, credential_provider_imds_1.fromContainerMetadata)(init);
    }
    if (process.env[exports.ENV_IMDS_DISABLED]) {
        return async () => {
            throw new property_provider_1.CredentialsProviderError("EC2 Instance Metadata Service access disabled");
        };
    }
    return (0, credential_provider_imds_1.fromInstanceMetadata)(init);
};
exports.remoteProvider = remoteProvider;


/***/ }),

/***/ 72650:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromProcess = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const resolveProcessCredentials_1 = __nccwpck_require__(74926);
const fromProcess = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    return (0, resolveProcessCredentials_1.resolveProcessCredentials)((0, shared_ini_file_loader_1.getProfileName)(init), profiles);
};
exports.fromProcess = fromProcess;


/***/ }),

/***/ 41104:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValidatedProcessCredentials = void 0;
const getValidatedProcessCredentials = (profileName, data) => {
    if (data.Version !== 1) {
        throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
    }
    if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
        throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
    }
    if (data.Expiration) {
        const currentTime = new Date();
        const expireTime = new Date(data.Expiration);
        if (expireTime < currentTime) {
            throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
        }
    }
    return {
        accessKeyId: data.AccessKeyId,
        secretAccessKey: data.SecretAccessKey,
        ...(data.SessionToken && { sessionToken: data.SessionToken }),
        ...(data.Expiration && { expiration: new Date(data.Expiration) }),
    };
};
exports.getValidatedProcessCredentials = getValidatedProcessCredentials;


/***/ }),

/***/ 89969:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(72650), exports);


/***/ }),

/***/ 74926:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProcessCredentials = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const child_process_1 = __nccwpck_require__(32081);
const util_1 = __nccwpck_require__(73837);
const getValidatedProcessCredentials_1 = __nccwpck_require__(41104);
const resolveProcessCredentials = async (profileName, profiles) => {
    const profile = profiles[profileName];
    if (profiles[profileName]) {
        const credentialProcess = profile["credential_process"];
        if (credentialProcess !== undefined) {
            const execPromise = (0, util_1.promisify)(child_process_1.exec);
            try {
                const { stdout } = await execPromise(credentialProcess);
                let data;
                try {
                    data = JSON.parse(stdout.trim());
                }
                catch (_a) {
                    throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
                }
                return (0, getValidatedProcessCredentials_1.getValidatedProcessCredentials)(profileName, data);
            }
            catch (error) {
                throw new property_provider_1.CredentialsProviderError(error.message);
            }
        }
        else {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
        }
    }
    else {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
    }
};
exports.resolveProcessCredentials = resolveProcessCredentials;


/***/ }),

/***/ 35959:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSSO = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const isSsoProfile_1 = __nccwpck_require__(32572);
const resolveSSOCredentials_1 = __nccwpck_require__(94729);
const validateSsoProfile_1 = __nccwpck_require__(48098);
const fromSSO = (init = {}) => async () => {
    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init;
    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
        const profile = profiles[profileName];
        if (!profile) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} was not found.`);
        }
        if (!(0, isSsoProfile_1.isSsoProfile)(profile)) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
        }
        if (profile === null || profile === void 0 ? void 0 : profile.sso_session) {
            const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init);
            const session = ssoSessions[profile.sso_session];
            const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
            if (ssoRegion && ssoRegion !== session.sso_region) {
                throw new property_provider_1.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
            }
            if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
                throw new property_provider_1.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
            }
            profile.sso_region = session.sso_region;
            profile.sso_start_url = session.sso_start_url;
        }
        const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = (0, validateSsoProfile_1.validateSsoProfile)(profile);
        return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
            ssoStartUrl: sso_start_url,
            ssoSession: sso_session,
            ssoAccountId: sso_account_id,
            ssoRegion: sso_region,
            ssoRoleName: sso_role_name,
            ssoClient: ssoClient,
            profile: profileName,
        });
    }
    else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
        throw new property_provider_1.CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " +
            '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
    }
    else {
        return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
            ssoStartUrl,
            ssoSession,
            ssoAccountId,
            ssoRegion,
            ssoRoleName,
            ssoClient,
            profile: profileName,
        });
    }
};
exports.fromSSO = fromSSO;


/***/ }),

/***/ 26414:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(35959), exports);
tslib_1.__exportStar(__nccwpck_require__(32572), exports);
tslib_1.__exportStar(__nccwpck_require__(86623), exports);
tslib_1.__exportStar(__nccwpck_require__(48098), exports);


/***/ }),

/***/ 32572:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSsoProfile = void 0;
const isSsoProfile = (arg) => arg &&
    (typeof arg.sso_start_url === "string" ||
        typeof arg.sso_account_id === "string" ||
        typeof arg.sso_session === "string" ||
        typeof arg.sso_region === "string" ||
        typeof arg.sso_role_name === "string");
exports.isSsoProfile = isSsoProfile;


/***/ }),

/***/ 94729:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSSOCredentials = void 0;
const client_sso_1 = __nccwpck_require__(82666);
const token_providers_1 = __nccwpck_require__(52843);
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const EXPIRE_WINDOW_MS = 15 * 60 * 1000;
const SHOULD_FAIL_CREDENTIAL_CHAIN = false;
const resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile, }) => {
    let token;
    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
    if (ssoSession) {
        try {
            const _token = await (0, token_providers_1.fromSso)({ profile })();
            token = {
                accessToken: _token.token,
                expiresAt: new Date(_token.expiration).toISOString(),
            };
        }
        catch (e) {
            throw new property_provider_1.CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    else {
        try {
            token = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoStartUrl);
        }
        catch (e) {
            throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {
        throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { accessToken } = token;
    const sso = ssoClient || new client_sso_1.SSOClient({ region: ssoRegion });
    let ssoResp;
    try {
        ssoResp = await sso.send(new client_sso_1.GetRoleCredentialsCommand({
            accountId: ssoAccountId,
            roleName: ssoRoleName,
            accessToken,
        }));
    }
    catch (e) {
        throw property_provider_1.CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
        throw new property_provider_1.CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
};
exports.resolveSSOCredentials = resolveSSOCredentials;


/***/ }),

/***/ 86623:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 48098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSsoProfile = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const validateSsoProfile = (profile) => {
    const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
    if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
        throw new property_provider_1.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` +
            `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
    }
    return profile;
};
exports.validateSsoProfile = validateSsoProfile;


/***/ }),

/***/ 35614:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromTokenFile = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fs_1 = __nccwpck_require__(57147);
const fromWebToken_1 = __nccwpck_require__(47905);
const ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
const ENV_ROLE_ARN = "AWS_ROLE_ARN";
const ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
const fromTokenFile = (init = {}) => async () => {
    var _a, _b, _c;
    const webIdentityTokenFile = (_a = init === null || init === void 0 ? void 0 : init.webIdentityTokenFile) !== null && _a !== void 0 ? _a : process.env[ENV_TOKEN_FILE];
    const roleArn = (_b = init === null || init === void 0 ? void 0 : init.roleArn) !== null && _b !== void 0 ? _b : process.env[ENV_ROLE_ARN];
    const roleSessionName = (_c = init === null || init === void 0 ? void 0 : init.roleSessionName) !== null && _c !== void 0 ? _c : process.env[ENV_ROLE_SESSION_NAME];
    if (!webIdentityTokenFile || !roleArn) {
        throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified");
    }
    return (0, fromWebToken_1.fromWebToken)({
        ...init,
        webIdentityToken: (0, fs_1.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
        roleArn,
        roleSessionName,
    })();
};
exports.fromTokenFile = fromTokenFile;


/***/ }),

/***/ 47905:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromWebToken = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromWebToken = (init) => () => {
    const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity, } = init;
    if (!roleAssumerWithWebIdentity) {
        throw new property_provider_1.CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity,` +
            ` but no role assumption callback was provided.`, false);
    }
    return roleAssumerWithWebIdentity({
        RoleArn: roleArn,
        RoleSessionName: roleSessionName !== null && roleSessionName !== void 0 ? roleSessionName : `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: webIdentityToken,
        ProviderId: providerId,
        PolicyArns: policyArns,
        Policy: policy,
        DurationSeconds: durationSeconds,
    });
};
exports.fromWebToken = fromWebToken;


/***/ }),

/***/ 15646:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(35614), exports);
tslib_1.__exportStar(__nccwpck_require__(47905), exports);


/***/ }),

/***/ 22545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHostHeaderPlugin = exports.hostHeaderMiddlewareOptions = exports.hostHeaderMiddleware = exports.resolveHostHeaderConfig = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
function resolveHostHeaderConfig(input) {
    return input;
}
exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
const hostHeaderMiddleware = (options) => (next) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request))
        return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = "";
    }
    else if (!request.headers["host"]) {
        let host = request.hostname;
        if (request.port != null)
            host += `:${request.port}`;
        request.headers["host"] = host;
    }
    return next(args);
};
exports.hostHeaderMiddleware = hostHeaderMiddleware;
exports.hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true,
};
const getHostHeaderPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.hostHeaderMiddleware)(options), exports.hostHeaderMiddlewareOptions);
    },
});
exports.getHostHeaderPlugin = getHostHeaderPlugin;


/***/ }),

/***/ 20014:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(9754), exports);


/***/ }),

/***/ 9754:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLoggerPlugin = exports.loggerMiddlewareOptions = exports.loggerMiddleware = void 0;
const loggerMiddleware = () => (next, context) => async (args) => {
    var _a, _b;
    try {
        const response = await next(args);
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== void 0 ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog !== null && overrideOutputFilterSensitiveLog !== void 0 ? overrideOutputFilterSensitiveLog : context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response.output;
        (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, {
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            output: outputFilterSensitiveLog(outputWithoutMetadata),
            metadata: $metadata,
        });
        return response;
    }
    catch (error) {
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== void 0 ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
        (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, {
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            error,
            metadata: error.$metadata,
        });
        throw error;
    }
};
exports.loggerMiddleware = loggerMiddleware;
exports.loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true,
};
const getLoggerPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.loggerMiddleware)(), exports.loggerMiddlewareOptions);
    },
});
exports.getLoggerPlugin = getLoggerPlugin;


/***/ }),

/***/ 85525:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRecursionDetectionPlugin = exports.addRecursionDetectionMiddlewareOptions = exports.recursionDetectionMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = (options) => (next) => async (args) => {
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request) ||
        options.runtime !== "node" ||
        request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
        return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceId = process.env[ENV_TRACE_ID];
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
        ...args,
        request,
    });
};
exports.recursionDetectionMiddleware = recursionDetectionMiddleware;
exports.addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low",
};
const getRecursionDetectionPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.recursionDetectionMiddleware)(options), exports.addRecursionDetectionMiddlewareOptions);
    },
});
exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;


/***/ }),

/***/ 55959:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveStsAuthConfig = void 0;
const middleware_signing_1 = __nccwpck_require__(14935);
const resolveStsAuthConfig = (input, { stsClientCtor }) => (0, middleware_signing_1.resolveAwsAuthConfig)({
    ...input,
    stsClientCtor,
});
exports.resolveStsAuthConfig = resolveStsAuthConfig;


/***/ }),

/***/ 84193:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSigV4AuthConfig = exports.resolveAwsAuthConfig = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const signature_v4_1 = __nccwpck_require__(11528);
const util_middleware_1 = __nccwpck_require__(2390);
const CREDENTIAL_EXPIRE_WINDOW = 300000;
const resolveAwsAuthConfig = (input) => {
    const normalizedCreds = input.credentials
        ? normalizeCredentialProvider(input.credentials)
        : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
        signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    }
    else if (input.regionInfoProvider) {
        signer = () => (0, util_middleware_1.normalizeProvider)(input.region)()
            .then(async (region) => [
            (await input.regionInfoProvider(region, {
                useFipsEndpoint: await input.useFipsEndpoint(),
                useDualstackEndpoint: await input.useDualstackEndpoint(),
            })) || {},
            region,
        ])
            .then(([regionInfo, region]) => {
            const { signingRegion, signingService } = regionInfo;
            input.signingRegion = input.signingRegion || signingRegion || region;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
                ...input,
                credentials: normalizedCreds,
                region: input.signingRegion,
                service: input.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        });
    }
    else {
        signer = async (authScheme) => {
            authScheme = Object.assign({}, {
                name: "sigv4",
                signingName: input.signingName || input.defaultSigningName,
                signingRegion: await (0, util_middleware_1.normalizeProvider)(input.region)(),
                properties: {},
            }, authScheme);
            const signingRegion = authScheme.signingRegion;
            const signingService = authScheme.signingName;
            input.signingRegion = input.signingRegion || signingRegion;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
                ...input,
                credentials: normalizedCreds,
                region: input.signingRegion,
                service: input.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        };
    }
    return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer,
    };
};
exports.resolveAwsAuthConfig = resolveAwsAuthConfig;
const resolveSigV4AuthConfig = (input) => {
    const normalizedCreds = input.credentials
        ? normalizeCredentialProvider(input.credentials)
        : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
        signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    }
    else {
        signer = (0, util_middleware_1.normalizeProvider)(new signature_v4_1.SignatureV4({
            credentials: normalizedCreds,
            region: input.region,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath,
        }));
    }
    return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer,
    };
};
exports.resolveSigV4AuthConfig = resolveSigV4AuthConfig;
const normalizeCredentialProvider = (credentials) => {
    if (typeof credentials === "function") {
        return (0, property_provider_1.memoize)(credentials, (credentials) => credentials.expiration !== undefined &&
            credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials) => credentials.expiration !== undefined);
    }
    return (0, util_middleware_1.normalizeProvider)(credentials);
};


/***/ }),

/***/ 88053:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin = exports.awsAuthMiddlewareOptions = exports.awsAuthMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const getSkewCorrectedDate_1 = __nccwpck_require__(68253);
const getUpdatedSystemClockOffset_1 = __nccwpck_require__(35863);
const awsAuthMiddleware = (options) => (next, context) => async function (args) {
    var _a, _b, _c, _d;
    if (!protocol_http_1.HttpRequest.isInstance(args.request))
        return next(args);
    const authScheme = (_c = (_b = (_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.authSchemes) === null || _c === void 0 ? void 0 : _c[0];
    const multiRegionOverride = (authScheme === null || authScheme === void 0 ? void 0 : authScheme.name) === "sigv4a" ? (_d = authScheme === null || authScheme === void 0 ? void 0 : authScheme.signingRegionSet) === null || _d === void 0 ? void 0 : _d.join(",") : undefined;
    const signer = await options.signer(authScheme);
    const output = await next({
        ...args,
        request: await signer.sign(args.request, {
            signingDate: (0, getSkewCorrectedDate_1.getSkewCorrectedDate)(options.systemClockOffset),
            signingRegion: multiRegionOverride || context["signing_region"],
            signingService: context["signing_service"],
        }),
    }).catch((error) => {
        var _a;
        const serverTime = (_a = error.ServerTime) !== null && _a !== void 0 ? _a : getDateHeader(error.$response);
        if (serverTime) {
            options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(serverTime, options.systemClockOffset);
        }
        throw error;
    });
    const dateHeader = getDateHeader(output.response);
    if (dateHeader) {
        options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(dateHeader, options.systemClockOffset);
    }
    return output;
};
exports.awsAuthMiddleware = awsAuthMiddleware;
const getDateHeader = (response) => { var _a, _b, _c; return protocol_http_1.HttpResponse.isInstance(response) ? (_b = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.date) !== null && _b !== void 0 ? _b : (_c = response.headers) === null || _c === void 0 ? void 0 : _c.Date : undefined; };
exports.awsAuthMiddlewareOptions = {
    name: "awsAuthMiddleware",
    tags: ["SIGNATURE", "AWSAUTH"],
    relation: "after",
    toMiddleware: "retryMiddleware",
    override: true,
};
const getAwsAuthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, exports.awsAuthMiddleware)(options), exports.awsAuthMiddlewareOptions);
    },
});
exports.getAwsAuthPlugin = getAwsAuthPlugin;
exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin;


/***/ }),

/***/ 14935:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(84193), exports);
tslib_1.__exportStar(__nccwpck_require__(88053), exports);


/***/ }),

/***/ 68253:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSkewCorrectedDate = void 0;
const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
exports.getSkewCorrectedDate = getSkewCorrectedDate;


/***/ }),

/***/ 35863:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUpdatedSystemClockOffset = void 0;
const isClockSkewed_1 = __nccwpck_require__(85301);
const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if ((0, isClockSkewed_1.isClockSkewed)(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
};
exports.getUpdatedSystemClockOffset = getUpdatedSystemClockOffset;


/***/ }),

/***/ 85301:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isClockSkewed = void 0;
const getSkewCorrectedDate_1 = __nccwpck_require__(68253);
const isClockSkewed = (clockTime, systemClockOffset) => Math.abs((0, getSkewCorrectedDate_1.getSkewCorrectedDate)(systemClockOffset).getTime() - clockTime) >= 300000;
exports.isClockSkewed = isClockSkewed;


/***/ }),

/***/ 36546:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveUserAgentConfig = void 0;
function resolveUserAgentConfig(input) {
    return {
        ...input,
        customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
    };
}
exports.resolveUserAgentConfig = resolveUserAgentConfig;


/***/ }),

/***/ 28025:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UA_ESCAPE_CHAR = exports.UA_VALUE_ESCAPE_REGEX = exports.UA_NAME_ESCAPE_REGEX = exports.UA_NAME_SEPARATOR = exports.SPACE = exports.X_AMZ_USER_AGENT = exports.USER_AGENT = void 0;
exports.USER_AGENT = "user-agent";
exports.X_AMZ_USER_AGENT = "x-amz-user-agent";
exports.SPACE = " ";
exports.UA_NAME_SEPARATOR = "/";
exports.UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
exports.UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
exports.UA_ESCAPE_CHAR = "-";


/***/ }),

/***/ 64688:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(36546), exports);
tslib_1.__exportStar(__nccwpck_require__(76236), exports);


/***/ }),

/***/ 76236:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserAgentPlugin = exports.getUserAgentMiddlewareOptions = exports.userAgentMiddleware = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const protocol_http_1 = __nccwpck_require__(64418);
const constants_1 = __nccwpck_require__(28025);
const userAgentMiddleware = (options) => (next, context) => async (args) => {
    var _a, _b;
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request))
        return next(args);
    const { headers } = request;
    const userAgent = ((_a = context === null || context === void 0 ? void 0 : context.userAgent) === null || _a === void 0 ? void 0 : _a.map(escapeUserAgent)) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    const customUserAgent = ((_b = options === null || options === void 0 ? void 0 : options.customUserAgent) === null || _b === void 0 ? void 0 : _b.map(escapeUserAgent)) || [];
    const prefix = (0, util_endpoints_1.getUserAgentPrefix)();
    const sdkUserAgentValue = (prefix ? [prefix] : [])
        .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
        .join(constants_1.SPACE);
    const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent,
    ].join(constants_1.SPACE);
    if (options.runtime !== "browser") {
        if (normalUAValue) {
            headers[constants_1.X_AMZ_USER_AGENT] = headers[constants_1.X_AMZ_USER_AGENT]
                ? `${headers[constants_1.USER_AGENT]} ${normalUAValue}`
                : normalUAValue;
        }
        headers[constants_1.USER_AGENT] = sdkUserAgentValue;
    }
    else {
        headers[constants_1.X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
        ...args,
        request,
    });
};
exports.userAgentMiddleware = userAgentMiddleware;
const escapeUserAgent = (userAgentPair) => {
    var _a;
    const name = userAgentPair[0]
        .split(constants_1.UA_NAME_SEPARATOR)
        .map((part) => part.replace(constants_1.UA_NAME_ESCAPE_REGEX, constants_1.UA_ESCAPE_CHAR))
        .join(constants_1.UA_NAME_SEPARATOR);
    const version = (_a = userAgentPair[1]) === null || _a === void 0 ? void 0 : _a.replace(constants_1.UA_VALUE_ESCAPE_REGEX, constants_1.UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(constants_1.UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
        uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version]
        .filter((item) => item && item.length > 0)
        .reduce((acc, item, index) => {
        switch (index) {
            case 0:
                return item;
            case 1:
                return `${acc}/${item}`;
            default:
                return `${acc}#${item}`;
        }
    }, "");
};
exports.getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true,
};
const getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.userAgentMiddleware)(config), exports.getUserAgentMiddlewareOptions);
    },
});
exports.getUserAgentPlugin = getUserAgentPlugin;


/***/ }),

/***/ 92242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.REFRESH_MESSAGE = exports.EXPIRE_WINDOW_MS = void 0;
exports.EXPIRE_WINDOW_MS = 5 * 60 * 1000;
exports.REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;


/***/ }),

/***/ 85125:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSso = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const constants_1 = __nccwpck_require__(92242);
const getNewSsoOidcToken_1 = __nccwpck_require__(93601);
const validateTokenExpiry_1 = __nccwpck_require__(28418);
const validateTokenKey_1 = __nccwpck_require__(2488);
const writeSSOTokenToFile_1 = __nccwpck_require__(48552);
const lastRefreshAttemptTime = new Date(0);
const fromSso = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
    const profile = profiles[profileName];
    if (!profile) {
        throw new property_provider_1.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
    }
    else if (!profile["sso_session"]) {
        throw new property_provider_1.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
    }
    const ssoSessionName = profile["sso_session"];
    const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init);
    const ssoSession = ssoSessions[ssoSessionName];
    if (!ssoSession) {
        throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
    }
    for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
        if (!ssoSession[ssoSessionRequiredKey]) {
            throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
        }
    }
    const ssoStartUrl = ssoSession["sso_start_url"];
    const ssoRegion = ssoSession["sso_region"];
    let ssoToken;
    try {
        ssoToken = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoSessionName);
    }
    catch (e) {
        throw new property_provider_1.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${constants_1.REFRESH_MESSAGE}`, false);
    }
    (0, validateTokenKey_1.validateTokenKey)("accessToken", ssoToken.accessToken);
    (0, validateTokenKey_1.validateTokenKey)("expiresAt", ssoToken.expiresAt);
    const { accessToken, expiresAt } = ssoToken;
    const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
    if (existingToken.expiration.getTime() - Date.now() > constants_1.EXPIRE_WINDOW_MS) {
        return existingToken;
    }
    if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
        (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
        return existingToken;
    }
    (0, validateTokenKey_1.validateTokenKey)("clientId", ssoToken.clientId, true);
    (0, validateTokenKey_1.validateTokenKey)("clientSecret", ssoToken.clientSecret, true);
    (0, validateTokenKey_1.validateTokenKey)("refreshToken", ssoToken.refreshToken, true);
    try {
        lastRefreshAttemptTime.setTime(Date.now());
        const newSsoOidcToken = await (0, getNewSsoOidcToken_1.getNewSsoOidcToken)(ssoToken, ssoRegion);
        (0, validateTokenKey_1.validateTokenKey)("accessToken", newSsoOidcToken.accessToken);
        (0, validateTokenKey_1.validateTokenKey)("expiresIn", newSsoOidcToken.expiresIn);
        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
        try {
            await (0, writeSSOTokenToFile_1.writeSSOTokenToFile)(ssoSessionName, {
                ...ssoToken,
                accessToken: newSsoOidcToken.accessToken,
                expiresAt: newTokenExpiration.toISOString(),
                refreshToken: newSsoOidcToken.refreshToken,
            });
        }
        catch (error) {
        }
        return {
            token: newSsoOidcToken.accessToken,
            expiration: newTokenExpiration,
        };
    }
    catch (error) {
        (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
        return existingToken;
    }
};
exports.fromSso = fromSso;


/***/ }),

/***/ 63258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromStatic = ({ token }) => async () => {
    if (!token || !token.token) {
        throw new property_provider_1.TokenProviderError(`Please pass a valid token to fromStatic`, false);
    }
    return token;
};
exports.fromStatic = fromStatic;


/***/ }),

/***/ 93601:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNewSsoOidcToken = void 0;
const client_sso_oidc_1 = __nccwpck_require__(54527);
const getSsoOidcClient_1 = __nccwpck_require__(99775);
const getNewSsoOidcToken = (ssoToken, ssoRegion) => {
    const ssoOidcClient = (0, getSsoOidcClient_1.getSsoOidcClient)(ssoRegion);
    return ssoOidcClient.send(new client_sso_oidc_1.CreateTokenCommand({
        clientId: ssoToken.clientId,
        clientSecret: ssoToken.clientSecret,
        refreshToken: ssoToken.refreshToken,
        grantType: "refresh_token",
    }));
};
exports.getNewSsoOidcToken = getNewSsoOidcToken;


/***/ }),

/***/ 99775:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSsoOidcClient = void 0;
const client_sso_oidc_1 = __nccwpck_require__(54527);
const ssoOidcClientsHash = {};
const getSsoOidcClient = (ssoRegion) => {
    if (ssoOidcClientsHash[ssoRegion]) {
        return ssoOidcClientsHash[ssoRegion];
    }
    const ssoOidcClient = new client_sso_oidc_1.SSOOIDCClient({ region: ssoRegion });
    ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
    return ssoOidcClient;
};
exports.getSsoOidcClient = getSsoOidcClient;


/***/ }),

/***/ 52843:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(85125), exports);
tslib_1.__exportStar(__nccwpck_require__(63258), exports);
tslib_1.__exportStar(__nccwpck_require__(70195), exports);


/***/ }),

/***/ 70195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nodeProvider = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromSso_1 = __nccwpck_require__(85125);
const nodeProvider = (init = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromSso_1.fromSso)(init), async () => {
    throw new property_provider_1.TokenProviderError("Could not load token from any providers", false);
}), (token) => token.expiration !== undefined && token.expiration.getTime() - Date.now() < 300000, (token) => token.expiration !== undefined);
exports.nodeProvider = nodeProvider;


/***/ }),

/***/ 28418:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTokenExpiry = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const constants_1 = __nccwpck_require__(92242);
const validateTokenExpiry = (token) => {
    if (token.expiration && token.expiration.getTime() < Date.now()) {
        throw new property_provider_1.TokenProviderError(`Token is expired. ${constants_1.REFRESH_MESSAGE}`, false);
    }
};
exports.validateTokenExpiry = validateTokenExpiry;


/***/ }),

/***/ 2488:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTokenKey = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const constants_1 = __nccwpck_require__(92242);
const validateTokenKey = (key, value, forRefresh = false) => {
    if (typeof value === "undefined") {
        throw new property_provider_1.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${constants_1.REFRESH_MESSAGE}`, false);
    }
};
exports.validateTokenKey = validateTokenKey;


/***/ }),

/***/ 48552:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeSSOTokenToFile = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const fs_1 = __nccwpck_require__(57147);
const { writeFile } = fs_1.promises;
const writeSSOTokenToFile = (id, ssoToken) => {
    const tokenFilepath = (0, shared_ini_file_loader_1.getSSOTokenFilepath)(id);
    const tokenString = JSON.stringify(ssoToken, null, 2);
    return writeFile(tokenFilepath, tokenString);
};
exports.writeSSOTokenToFile = writeSSOTokenToFile;


/***/ }),

/***/ 52562:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 26913:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpAuthLocation = void 0;
var types_1 = __nccwpck_require__(55756);
Object.defineProperty(exports, "HttpAuthLocation", ({ enumerable: true, get: function () { return types_1.HttpAuthLocation; } }));


/***/ }),

/***/ 14994:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 65861:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 76527:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 48470:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 28045:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 67736:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 13268:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 90142:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostAddressType = void 0;
var HostAddressType;
(function (HostAddressType) {
    HostAddressType["AAAA"] = "AAAA";
    HostAddressType["A"] = "A";
})(HostAddressType = exports.HostAddressType || (exports.HostAddressType = {}));


/***/ }),

/***/ 62338:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 99385:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointURLScheme = void 0;
var types_1 = __nccwpck_require__(55756);
Object.defineProperty(exports, "EndpointURLScheme", ({ enumerable: true, get: function () { return types_1.EndpointURLScheme; } }));


/***/ }),

/***/ 37521:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 61393:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 51821:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 92635:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 71301:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 21268:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 7192:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 10640:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(51821), exports);
tslib_1.__exportStar(__nccwpck_require__(92635), exports);
tslib_1.__exportStar(__nccwpck_require__(71301), exports);
tslib_1.__exportStar(__nccwpck_require__(21268), exports);
tslib_1.__exportStar(__nccwpck_require__(7192), exports);


/***/ }),

/***/ 89029:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(52562), exports);
tslib_1.__exportStar(__nccwpck_require__(26913), exports);
tslib_1.__exportStar(__nccwpck_require__(14994), exports);
tslib_1.__exportStar(__nccwpck_require__(65861), exports);
tslib_1.__exportStar(__nccwpck_require__(76527), exports);
tslib_1.__exportStar(__nccwpck_require__(48470), exports);
tslib_1.__exportStar(__nccwpck_require__(28045), exports);
tslib_1.__exportStar(__nccwpck_require__(67736), exports);
tslib_1.__exportStar(__nccwpck_require__(13268), exports);
tslib_1.__exportStar(__nccwpck_require__(90142), exports);
tslib_1.__exportStar(__nccwpck_require__(62338), exports);
tslib_1.__exportStar(__nccwpck_require__(99385), exports);
tslib_1.__exportStar(__nccwpck_require__(37521), exports);
tslib_1.__exportStar(__nccwpck_require__(61393), exports);
tslib_1.__exportStar(__nccwpck_require__(10640), exports);
tslib_1.__exportStar(__nccwpck_require__(89910), exports);
tslib_1.__exportStar(__nccwpck_require__(36678), exports);
tslib_1.__exportStar(__nccwpck_require__(39931), exports);
tslib_1.__exportStar(__nccwpck_require__(42620), exports);
tslib_1.__exportStar(__nccwpck_require__(89062), exports);
tslib_1.__exportStar(__nccwpck_require__(89546), exports);
tslib_1.__exportStar(__nccwpck_require__(80316), exports);
tslib_1.__exportStar(__nccwpck_require__(57835), exports);
tslib_1.__exportStar(__nccwpck_require__(91678), exports);
tslib_1.__exportStar(__nccwpck_require__(93818), exports);
tslib_1.__exportStar(__nccwpck_require__(51991), exports);
tslib_1.__exportStar(__nccwpck_require__(24296), exports);
tslib_1.__exportStar(__nccwpck_require__(59416), exports);
tslib_1.__exportStar(__nccwpck_require__(92772), exports);
tslib_1.__exportStar(__nccwpck_require__(20134), exports);
tslib_1.__exportStar(__nccwpck_require__(34465), exports);


/***/ }),

/***/ 89910:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 36678:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 39931:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 42620:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 89062:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 89546:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 80316:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 91678:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 93818:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 51991:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 24296:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 59416:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestHandlerProtocol = void 0;
var types_1 = __nccwpck_require__(55756);
Object.defineProperty(exports, "RequestHandlerProtocol", ({ enumerable: true, get: function () { return types_1.RequestHandlerProtocol; } }));


/***/ }),

/***/ 92772:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 20134:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 34465:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 81809:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debugId = void 0;
exports.debugId = "endpoints";


/***/ }),

/***/ 27617:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(81809), exports);
tslib_1.__exportStar(__nccwpck_require__(46833), exports);


/***/ }),

/***/ 46833:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toDebugString = void 0;
function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
        return input;
    }
    if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
}
exports.toDebugString = toDebugString;


/***/ }),

/***/ 13350:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(37482), exports);
tslib_1.__exportStar(__nccwpck_require__(73442), exports);
tslib_1.__exportStar(__nccwpck_require__(36563), exports);
tslib_1.__exportStar(__nccwpck_require__(57433), exports);


/***/ }),

/***/ 46835:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(48079), exports);
tslib_1.__exportStar(__nccwpck_require__(34711), exports);
tslib_1.__exportStar(__nccwpck_require__(37482), exports);


/***/ }),

/***/ 48079:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVirtualHostableS3Bucket = void 0;
const isIpAddress_1 = __nccwpck_require__(73442);
const isValidHostLabel_1 = __nccwpck_require__(57373);
const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
        for (const label of value.split(".")) {
            if (!(0, exports.isVirtualHostableS3Bucket)(label)) {
                return false;
            }
        }
        return true;
    }
    if (!(0, isValidHostLabel_1.isValidHostLabel)(value)) {
        return false;
    }
    if (value.length < 3 || value.length > 63) {
        return false;
    }
    if (value !== value.toLowerCase()) {
        return false;
    }
    if ((0, isIpAddress_1.isIpAddress)(value)) {
        return false;
    }
    return true;
};
exports.isVirtualHostableS3Bucket = isVirtualHostableS3Bucket;


/***/ }),

/***/ 34711:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseArn = void 0;
const parseArn = (value) => {
    const segments = value.split(":");
    if (segments.length < 6)
        return null;
    const [arn, partition, service, region, accountId, ...resourceId] = segments;
    if (arn !== "arn" || partition === "" || service === "" || resourceId[0] === "")
        return null;
    return {
        partition,
        service,
        region,
        accountId,
        resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId,
    };
};
exports.parseArn = parseArn;


/***/ }),

/***/ 37482:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserAgentPrefix = exports.useDefaultPartitionInfo = exports.setPartitionInfo = exports.partition = void 0;
const tslib_1 = __nccwpck_require__(4351);
const partitions_json_1 = tslib_1.__importDefault(__nccwpck_require__(95367));
let selectedPartitionsInfo = partitions_json_1.default;
let selectedUserAgentPrefix = "";
const partition = (value) => {
    const { partitions } = selectedPartitionsInfo;
    for (const partition of partitions) {
        const { regions, outputs } = partition;
        for (const [region, regionData] of Object.entries(regions)) {
            if (region === value) {
                return {
                    ...outputs,
                    ...regionData,
                };
            }
        }
    }
    for (const partition of partitions) {
        const { regionRegex, outputs } = partition;
        if (new RegExp(regionRegex).test(value)) {
            return {
                ...outputs,
            };
        }
    }
    const DEFAULT_PARTITION = partitions.find((partition) => partition.id === "aws");
    if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex," +
            " and default partition with id 'aws' doesn't exist.");
    }
    return {
        ...DEFAULT_PARTITION.outputs,
    };
};
exports.partition = partition;
const setPartitionInfo = (partitionsInfo, userAgentPrefix = "") => {
    selectedPartitionsInfo = partitionsInfo;
    selectedUserAgentPrefix = userAgentPrefix;
};
exports.setPartitionInfo = setPartitionInfo;
const useDefaultPartitionInfo = () => {
    (0, exports.setPartitionInfo)(partitions_json_1.default, "");
};
exports.useDefaultPartitionInfo = useDefaultPartitionInfo;
const getUserAgentPrefix = () => selectedUserAgentPrefix;
exports.getUserAgentPrefix = getUserAgentPrefix;


/***/ }),

/***/ 55370:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.booleanEquals = void 0;
const booleanEquals = (value1, value2) => value1 === value2;
exports.booleanEquals = booleanEquals;


/***/ }),

/***/ 20767:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAttr = void 0;
const types_1 = __nccwpck_require__(57433);
const getAttrPathList_1 = __nccwpck_require__(81844);
const getAttr = (value, path) => (0, getAttrPathList_1.getAttrPathList)(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
        throw new types_1.EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    }
    else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
    }
    return acc[index];
}, value);
exports.getAttr = getAttr;


/***/ }),

/***/ 81844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAttrPathList = void 0;
const types_1 = __nccwpck_require__(57433);
const getAttrPathList = (path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
            if (part.indexOf("]") !== part.length - 1) {
                throw new types_1.EndpointError(`Path: '${path}' does not end with ']'`);
            }
            const arrayIndex = part.slice(squareBracketIndex + 1, -1);
            if (Number.isNaN(parseInt(arrayIndex))) {
                throw new types_1.EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
            }
            if (squareBracketIndex !== 0) {
                pathList.push(part.slice(0, squareBracketIndex));
            }
            pathList.push(arrayIndex);
        }
        else {
            pathList.push(part);
        }
    }
    return pathList;
};
exports.getAttrPathList = getAttrPathList;


/***/ }),

/***/ 83188:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aws = void 0;
const tslib_1 = __nccwpck_require__(4351);
exports.aws = tslib_1.__importStar(__nccwpck_require__(46835));
tslib_1.__exportStar(__nccwpck_require__(55370), exports);
tslib_1.__exportStar(__nccwpck_require__(20767), exports);
tslib_1.__exportStar(__nccwpck_require__(78816), exports);
tslib_1.__exportStar(__nccwpck_require__(57373), exports);
tslib_1.__exportStar(__nccwpck_require__(29692), exports);
tslib_1.__exportStar(__nccwpck_require__(22780), exports);
tslib_1.__exportStar(__nccwpck_require__(55182), exports);
tslib_1.__exportStar(__nccwpck_require__(48305), exports);
tslib_1.__exportStar(__nccwpck_require__(6535), exports);


/***/ }),

/***/ 73442:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isIpAddress = void 0;
const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value) => IP_V4_REGEX.test(value) || (value.startsWith("[") && value.endsWith("]"));
exports.isIpAddress = isIpAddress;


/***/ }),

/***/ 78816:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSet = void 0;
const isSet = (value) => value != null;
exports.isSet = isSet;


/***/ }),

/***/ 57373:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidHostLabel = void 0;
const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
        if (!(0, exports.isValidHostLabel)(label)) {
            return false;
        }
    }
    return true;
};
exports.isValidHostLabel = isValidHostLabel;


/***/ }),

/***/ 29692:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.not = void 0;
const not = (value) => !value;
exports.not = not;


/***/ }),

/***/ 22780:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseURL = void 0;
const types_1 = __nccwpck_require__(89029);
const isIpAddress_1 = __nccwpck_require__(73442);
const DEFAULT_PORTS = {
    [types_1.EndpointURLScheme.HTTP]: 80,
    [types_1.EndpointURLScheme.HTTPS]: 443,
};
const parseURL = (value) => {
    const whatwgURL = (() => {
        try {
            if (value instanceof URL) {
                return value;
            }
            if (typeof value === "object" && "hostname" in value) {
                const { hostname, port, protocol = "", path = "", query = {} } = value;
                const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
                url.search = Object.entries(query)
                    .map(([k, v]) => `${k}=${v}`)
                    .join("&");
                return url;
            }
            return new URL(value);
        }
        catch (error) {
            return null;
        }
    })();
    if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
        return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(types_1.EndpointURLScheme).includes(scheme)) {
        return null;
    }
    const isIp = (0, isIpAddress_1.isIpAddress)(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ||
        (typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`));
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp,
    };
};
exports.parseURL = parseURL;


/***/ }),

/***/ 55182:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringEquals = void 0;
const stringEquals = (value1, value2) => value1 === value2;
exports.stringEquals = stringEquals;


/***/ }),

/***/ 48305:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.substring = void 0;
const substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
        return null;
    }
    if (!reverse) {
        return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
};
exports.substring = substring;


/***/ }),

/***/ 6535:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uriEncode = void 0;
const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
exports.uriEncode = uriEncode;


/***/ }),

/***/ 36563:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpoint = void 0;
const debug_1 = __nccwpck_require__(27617);
const types_1 = __nccwpck_require__(57433);
const utils_1 = __nccwpck_require__(81114);
const resolveEndpoint = (ruleSetObject, options) => {
    var _a, _b, _c, _d, _e, _f;
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `${debug_1.debugId} Initial EndpointParams: ${(0, debug_1.toDebugString)(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters)
        .filter(([, v]) => v.default != null)
        .map(([k, v]) => [k, v.default]);
    if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
            endpointParams[paramKey] = (_c = endpointParams[paramKey]) !== null && _c !== void 0 ? _c : paramDefaultValue;
        }
    }
    const requiredParams = Object.entries(parameters)
        .filter(([, v]) => v.required)
        .map(([k]) => k);
    for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
            throw new types_1.EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
    }
    const endpoint = (0, utils_1.evaluateRules)(rules, { endpointParams, logger, referenceRecord: {} });
    if ((_d = options.endpointParams) === null || _d === void 0 ? void 0 : _d.Endpoint) {
        try {
            const givenEndpoint = new URL(options.endpointParams.Endpoint);
            const { protocol, port } = givenEndpoint;
            endpoint.url.protocol = protocol;
            endpoint.url.port = port;
        }
        catch (e) {
        }
    }
    (_f = (_e = options.logger) === null || _e === void 0 ? void 0 : _e.debug) === null || _f === void 0 ? void 0 : _f.call(_e, `${debug_1.debugId} Resolved endpoint: ${(0, debug_1.toDebugString)(endpoint)}`);
    return endpoint;
};
exports.resolveEndpoint = resolveEndpoint;


/***/ }),

/***/ 82605:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointError = void 0;
class EndpointError extends Error {
    constructor(message) {
        super(message);
        this.name = "EndpointError";
    }
}
exports.EndpointError = EndpointError;


/***/ }),

/***/ 21261:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 20312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 56083:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 21767:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57433:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(82605), exports);
tslib_1.__exportStar(__nccwpck_require__(21261), exports);
tslib_1.__exportStar(__nccwpck_require__(20312), exports);
tslib_1.__exportStar(__nccwpck_require__(56083), exports);
tslib_1.__exportStar(__nccwpck_require__(21767), exports);
tslib_1.__exportStar(__nccwpck_require__(41811), exports);


/***/ }),

/***/ 41811:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 65075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.callFunction = void 0;
const tslib_1 = __nccwpck_require__(4351);
const lib = tslib_1.__importStar(__nccwpck_require__(83188));
const evaluateExpression_1 = __nccwpck_require__(82980);
const callFunction = ({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : (0, evaluateExpression_1.evaluateExpression)(arg, "arg", options));
    return fn.split(".").reduce((acc, key) => acc[key], lib)(...evaluatedArgs);
};
exports.callFunction = callFunction;


/***/ }),

/***/ 77851:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateCondition = void 0;
const debug_1 = __nccwpck_require__(27617);
const types_1 = __nccwpck_require__(57433);
const callFunction_1 = __nccwpck_require__(65075);
const evaluateCondition = ({ assign, ...fnArgs }, options) => {
    var _a, _b;
    if (assign && assign in options.referenceRecord) {
        throw new types_1.EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = (0, callFunction_1.callFunction)(fnArgs, options);
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `evaluateCondition: ${(0, debug_1.toDebugString)(fnArgs)} = ${(0, debug_1.toDebugString)(value)}`);
    return {
        result: value === "" ? true : !!value,
        ...(assign != null && { toAssign: { name: assign, value } }),
    };
};
exports.evaluateCondition = evaluateCondition;


/***/ }),

/***/ 59169:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateConditions = void 0;
const debug_1 = __nccwpck_require__(27617);
const evaluateCondition_1 = __nccwpck_require__(77851);
const evaluateConditions = (conditions = [], options) => {
    var _a, _b;
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
        const { result, toAssign } = (0, evaluateCondition_1.evaluateCondition)(condition, {
            ...options,
            referenceRecord: {
                ...options.referenceRecord,
                ...conditionsReferenceRecord,
            },
        });
        if (!result) {
            return { result };
        }
        if (toAssign) {
            conditionsReferenceRecord[toAssign.name] = toAssign.value;
            (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `assign: ${toAssign.name} := ${(0, debug_1.toDebugString)(toAssign.value)}`);
        }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
};
exports.evaluateConditions = evaluateConditions;


/***/ }),

/***/ 35324:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateEndpointRule = void 0;
const debug_1 = __nccwpck_require__(27617);
const evaluateConditions_1 = __nccwpck_require__(59169);
const getEndpointHeaders_1 = __nccwpck_require__(88268);
const getEndpointProperties_1 = __nccwpck_require__(34973);
const getEndpointUrl_1 = __nccwpck_require__(23602);
const evaluateEndpointRule = (endpointRule, options) => {
    var _a, _b;
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    };
    const { url, properties, headers } = endpoint;
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `Resolving endpoint from template: ${(0, debug_1.toDebugString)(endpoint)}`);
    return {
        ...(headers != undefined && {
            headers: (0, getEndpointHeaders_1.getEndpointHeaders)(headers, endpointRuleOptions),
        }),
        ...(properties != undefined && {
            properties: (0, getEndpointProperties_1.getEndpointProperties)(properties, endpointRuleOptions),
        }),
        url: (0, getEndpointUrl_1.getEndpointUrl)(url, endpointRuleOptions),
    };
};
exports.evaluateEndpointRule = evaluateEndpointRule;


/***/ }),

/***/ 12110:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateErrorRule = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateConditions_1 = __nccwpck_require__(59169);
const evaluateExpression_1 = __nccwpck_require__(82980);
const evaluateErrorRule = (errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    throw new types_1.EndpointError((0, evaluateExpression_1.evaluateExpression)(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    }));
};
exports.evaluateErrorRule = evaluateErrorRule;


/***/ }),

/***/ 82980:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateExpression = void 0;
const types_1 = __nccwpck_require__(57433);
const callFunction_1 = __nccwpck_require__(65075);
const evaluateTemplate_1 = __nccwpck_require__(57535);
const getReferenceValue_1 = __nccwpck_require__(68810);
const evaluateExpression = (obj, keyName, options) => {
    if (typeof obj === "string") {
        return (0, evaluateTemplate_1.evaluateTemplate)(obj, options);
    }
    else if (obj["fn"]) {
        return (0, callFunction_1.callFunction)(obj, options);
    }
    else if (obj["ref"]) {
        return (0, getReferenceValue_1.getReferenceValue)(obj, options);
    }
    throw new types_1.EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
exports.evaluateExpression = evaluateExpression;


/***/ }),

/***/ 59738:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateRules = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateEndpointRule_1 = __nccwpck_require__(35324);
const evaluateErrorRule_1 = __nccwpck_require__(12110);
const evaluateTreeRule_1 = __nccwpck_require__(26587);
const evaluateRules = (rules, options) => {
    for (const rule of rules) {
        if (rule.type === "endpoint") {
            const endpointOrUndefined = (0, evaluateEndpointRule_1.evaluateEndpointRule)(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else if (rule.type === "error") {
            (0, evaluateErrorRule_1.evaluateErrorRule)(rule, options);
        }
        else if (rule.type === "tree") {
            const endpointOrUndefined = (0, evaluateTreeRule_1.evaluateTreeRule)(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else {
            throw new types_1.EndpointError(`Unknown endpoint rule: ${rule}`);
        }
    }
    throw new types_1.EndpointError(`Rules evaluation failed`);
};
exports.evaluateRules = evaluateRules;


/***/ }),

/***/ 57535:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateTemplate = void 0;
const lib_1 = __nccwpck_require__(83188);
const evaluateTemplate = (template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(currentIndex));
            break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex));
            break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
            currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
            const [refName, attrName] = parameterName.split("#");
            evaluatedTemplateArr.push((0, lib_1.getAttr)(templateContext[refName], attrName));
        }
        else {
            evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
};
exports.evaluateTemplate = evaluateTemplate;


/***/ }),

/***/ 26587:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateTreeRule = void 0;
const evaluateConditions_1 = __nccwpck_require__(59169);
const evaluateRules_1 = __nccwpck_require__(59738);
const evaluateTreeRule = (treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    return (0, evaluateRules_1.evaluateRules)(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    });
};
exports.evaluateTreeRule = evaluateTreeRule;


/***/ }),

/***/ 88268:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointHeaders = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateExpression_1 = __nccwpck_require__(82980);
const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = (0, evaluateExpression_1.evaluateExpression)(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
            throw new types_1.EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
    }),
}), {});
exports.getEndpointHeaders = getEndpointHeaders;


/***/ }),

/***/ 34973:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointProperties = void 0;
const getEndpointProperty_1 = __nccwpck_require__(42978);
const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: (0, getEndpointProperty_1.getEndpointProperty)(propertyVal, options),
}), {});
exports.getEndpointProperties = getEndpointProperties;


/***/ }),

/***/ 42978:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointProperty = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateTemplate_1 = __nccwpck_require__(57535);
const getEndpointProperties_1 = __nccwpck_require__(34973);
const getEndpointProperty = (property, options) => {
    if (Array.isArray(property)) {
        return property.map((propertyEntry) => (0, exports.getEndpointProperty)(propertyEntry, options));
    }
    switch (typeof property) {
        case "string":
            return (0, evaluateTemplate_1.evaluateTemplate)(property, options);
        case "object":
            if (property === null) {
                throw new types_1.EndpointError(`Unexpected endpoint property: ${property}`);
            }
            return (0, getEndpointProperties_1.getEndpointProperties)(property, options);
        case "boolean":
            return property;
        default:
            throw new types_1.EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
};
exports.getEndpointProperty = getEndpointProperty;


/***/ }),

/***/ 23602:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointUrl = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateExpression_1 = __nccwpck_require__(82980);
const getEndpointUrl = (endpointUrl, options) => {
    const expression = (0, evaluateExpression_1.evaluateExpression)(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
        try {
            return new URL(expression);
        }
        catch (error) {
            console.error(`Failed to construct URL with ${expression}`, error);
            throw error;
        }
    }
    throw new types_1.EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};
exports.getEndpointUrl = getEndpointUrl;


/***/ }),

/***/ 68810:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getReferenceValue = void 0;
const getReferenceValue = ({ ref }, options) => {
    const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    return referenceRecord[ref];
};
exports.getReferenceValue = getReferenceValue;


/***/ }),

/***/ 81114:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(59738), exports);


/***/ }),

/***/ 98095:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultUserAgent = exports.UA_APP_ID_INI_NAME = exports.UA_APP_ID_ENV_NAME = void 0;
const node_config_provider_1 = __nccwpck_require__(33461);
const os_1 = __nccwpck_require__(22037);
const process_1 = __nccwpck_require__(77282);
const is_crt_available_1 = __nccwpck_require__(68390);
exports.UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
exports.UA_APP_ID_INI_NAME = "sdk-ua-app-id";
const defaultUserAgent = ({ serviceId, clientVersion }) => {
    const sections = [
        ["aws-sdk-js", clientVersion],
        ["ua", "2.0"],
        [`os/${(0, os_1.platform)()}`, (0, os_1.release)()],
        ["lang/js"],
        ["md/nodejs", `${process_1.versions.node}`],
    ];
    const crtAvailable = (0, is_crt_available_1.isCrtAvailable)();
    if (crtAvailable) {
        sections.push(crtAvailable);
    }
    if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
    }
    if (process_1.env.AWS_EXECUTION_ENV) {
        sections.push([`exec-env/${process_1.env.AWS_EXECUTION_ENV}`]);
    }
    const appIdPromise = (0, node_config_provider_1.loadConfig)({
        environmentVariableSelector: (env) => env[exports.UA_APP_ID_ENV_NAME],
        configFileSelector: (profile) => profile[exports.UA_APP_ID_INI_NAME],
        default: undefined,
    })();
    let resolvedUserAgent = undefined;
    return async () => {
        if (!resolvedUserAgent) {
            const appId = await appIdPromise;
            resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        }
        return resolvedUserAgent;
    };
};
exports.defaultUserAgent = defaultUserAgent;


/***/ }),

/***/ 68390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCrtAvailable = void 0;
const isCrtAvailable = () => {
    try {
        if ( true && __nccwpck_require__(87578)) {
            return ["md/crt-avail"];
        }
        return null;
    }
    catch (e) {
        return null;
    }
};
exports.isCrtAvailable = isCrtAvailable;


/***/ }),

/***/ 28172:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = exports.fromUtf8 = void 0;
const pureJs_1 = __nccwpck_require__(21590);
const whatwgEncodingApi_1 = __nccwpck_require__(89215);
const fromUtf8 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
exports.fromUtf8 = fromUtf8;
const toUtf8 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 21590:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = exports.fromUtf8 = void 0;
const fromUtf8 = (input) => {
    const bytes = [];
    for (let i = 0, len = input.length; i < len; i++) {
        const value = input.charCodeAt(i);
        if (value < 0x80) {
            bytes.push(value);
        }
        else if (value < 0x800) {
            bytes.push((value >> 6) | 0b11000000, (value & 0b111111) | 0b10000000);
        }
        else if (i + 1 < input.length && (value & 0xfc00) === 0xd800 && (input.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            const surrogatePair = 0x10000 + ((value & 0b1111111111) << 10) + (input.charCodeAt(++i) & 0b1111111111);
            bytes.push((surrogatePair >> 18) | 0b11110000, ((surrogatePair >> 12) & 0b111111) | 0b10000000, ((surrogatePair >> 6) & 0b111111) | 0b10000000, (surrogatePair & 0b111111) | 0b10000000);
        }
        else {
            bytes.push((value >> 12) | 0b11100000, ((value >> 6) & 0b111111) | 0b10000000, (value & 0b111111) | 0b10000000);
        }
    }
    return Uint8Array.from(bytes);
};
exports.fromUtf8 = fromUtf8;
const toUtf8 = (input) => {
    let decoded = "";
    for (let i = 0, len = input.length; i < len; i++) {
        const byte = input[i];
        if (byte < 0x80) {
            decoded += String.fromCharCode(byte);
        }
        else if (0b11000000 <= byte && byte < 0b11100000) {
            const nextByte = input[++i];
            decoded += String.fromCharCode(((byte & 0b11111) << 6) | (nextByte & 0b111111));
        }
        else if (0b11110000 <= byte && byte < 0b101101101) {
            const surrogatePair = [byte, input[++i], input[++i], input[++i]];
            const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
            decoded += decodeURIComponent(encoded);
        }
        else {
            decoded += String.fromCharCode(((byte & 0b1111) << 12) | ((input[++i] & 0b111111) << 6) | (input[++i] & 0b111111));
        }
    }
    return decoded;
};
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 89215:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = exports.fromUtf8 = void 0;
function fromUtf8(input) {
    return new TextEncoder().encode(input);
}
exports.fromUtf8 = fromUtf8;
function toUtf8(input) {
    return new TextDecoder("utf-8").decode(input);
}
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 43779:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_DUALSTACK_ENDPOINT = exports.CONFIG_USE_DUALSTACK_ENDPOINT = exports.ENV_USE_DUALSTACK_ENDPOINT = void 0;
const util_config_provider_1 = __nccwpck_require__(83375);
exports.ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
exports.CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
exports.DEFAULT_USE_DUALSTACK_ENDPOINT = false;
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 17994:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_FIPS_ENDPOINT = exports.CONFIG_USE_FIPS_ENDPOINT = exports.ENV_USE_FIPS_ENDPOINT = void 0;
const util_config_provider_1 = __nccwpck_require__(83375);
exports.ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
exports.CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
exports.DEFAULT_USE_FIPS_ENDPOINT = false;
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 18421:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(43779), exports);
tslib_1.__exportStar(__nccwpck_require__(17994), exports);
tslib_1.__exportStar(__nccwpck_require__(37432), exports);
tslib_1.__exportStar(__nccwpck_require__(61892), exports);


/***/ }),

/***/ 37432:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveCustomEndpointsConfig = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const resolveCustomEndpointsConfig = (input) => {
    var _a, _b;
    const { endpoint, urlParser } = input;
    return {
        ...input,
        tls: (_a = input.tls) !== null && _a !== void 0 ? _a : true,
        endpoint: (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
        isCustomEndpoint: true,
        useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== void 0 ? _b : false),
    };
};
exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;


/***/ }),

/***/ 61892:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpointsConfig = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const getEndpointFromRegion_1 = __nccwpck_require__(48570);
const resolveEndpointsConfig = (input) => {
    var _a, _b;
    const useDualstackEndpoint = (0, util_middleware_1.normalizeProvider)((_a = input.useDualstackEndpoint) !== null && _a !== void 0 ? _a : false);
    const { endpoint, useFipsEndpoint, urlParser } = input;
    return {
        ...input,
        tls: (_b = input.tls) !== null && _b !== void 0 ? _b : true,
        endpoint: endpoint
            ? (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
            : () => (0, getEndpointFromRegion_1.getEndpointFromRegion)({ ...input, useDualstackEndpoint, useFipsEndpoint }),
        isCustomEndpoint: !!endpoint,
        useDualstackEndpoint,
    };
};
exports.resolveEndpointsConfig = resolveEndpointsConfig;


/***/ }),

/***/ 48570:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointFromRegion = void 0;
const getEndpointFromRegion = async (input) => {
    var _a;
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
        throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = (_a = (await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint }))) !== null && _a !== void 0 ? _a : {};
    if (!hostname) {
        throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
};
exports.getEndpointFromRegion = getEndpointFromRegion;


/***/ }),

/***/ 53098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(18421), exports);
tslib_1.__exportStar(__nccwpck_require__(221), exports);
tslib_1.__exportStar(__nccwpck_require__(86985), exports);


/***/ }),

/***/ 33898:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_REGION_CONFIG_FILE_OPTIONS = exports.NODE_REGION_CONFIG_OPTIONS = exports.REGION_INI_NAME = exports.REGION_ENV_NAME = void 0;
exports.REGION_ENV_NAME = "AWS_REGION";
exports.REGION_INI_NAME = "region";
exports.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.REGION_ENV_NAME],
    configFileSelector: (profile) => profile[exports.REGION_INI_NAME],
    default: () => {
        throw new Error("Region is missing");
    },
};
exports.NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials",
};


/***/ }),

/***/ 49506:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRealRegion = void 0;
const isFipsRegion_1 = __nccwpck_require__(43870);
const getRealRegion = (region) => (0, isFipsRegion_1.isFipsRegion)(region)
    ? ["fips-aws-global", "aws-fips"].includes(region)
        ? "us-east-1"
        : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
    : region;
exports.getRealRegion = getRealRegion;


/***/ }),

/***/ 221:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(33898), exports);
tslib_1.__exportStar(__nccwpck_require__(87065), exports);


/***/ }),

/***/ 43870:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFipsRegion = void 0;
const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
exports.isFipsRegion = isFipsRegion;


/***/ }),

/***/ 87065:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRegionConfig = void 0;
const getRealRegion_1 = __nccwpck_require__(49506);
const isFipsRegion_1 = __nccwpck_require__(43870);
const resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
        throw new Error("Region is missing");
    }
    return {
        ...input,
        region: async () => {
            if (typeof region === "string") {
                return (0, getRealRegion_1.getRealRegion)(region);
            }
            const providedRegion = await region();
            return (0, getRealRegion_1.getRealRegion)(providedRegion);
        },
        useFipsEndpoint: async () => {
            const providedRegion = typeof region === "string" ? region : await region();
            if ((0, isFipsRegion_1.isFipsRegion)(providedRegion)) {
                return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        },
    };
};
exports.resolveRegionConfig = resolveRegionConfig;


/***/ }),

/***/ 19814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 14832:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 99760:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHostnameFromVariants = void 0;
const getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => {
    var _a;
    return (_a = variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))) === null || _a === void 0 ? void 0 : _a.hostname;
};
exports.getHostnameFromVariants = getHostnameFromVariants;


/***/ }),

/***/ 77792:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRegionInfo = void 0;
const getHostnameFromVariants_1 = __nccwpck_require__(99760);
const getResolvedHostname_1 = __nccwpck_require__(1487);
const getResolvedPartition_1 = __nccwpck_require__(44441);
const getResolvedSigningRegion_1 = __nccwpck_require__(92281);
const getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash, }) => {
    var _a, _b, _c, _d, _e, _f;
    const partition = (0, getResolvedPartition_1.getResolvedPartition)(region, { partitionHash });
    const resolvedRegion = region in regionHash ? region : (_b = (_a = partitionHash[partition]) === null || _a === void 0 ? void 0 : _a.endpoint) !== null && _b !== void 0 ? _b : region;
    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
    const regionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_c = regionHash[resolvedRegion]) === null || _c === void 0 ? void 0 : _c.variants, hostnameOptions);
    const partitionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_d = partitionHash[partition]) === null || _d === void 0 ? void 0 : _d.variants, hostnameOptions);
    const hostname = (0, getResolvedHostname_1.getResolvedHostname)(resolvedRegion, { regionHostname, partitionHostname });
    if (hostname === undefined) {
        throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
    }
    const signingRegion = (0, getResolvedSigningRegion_1.getResolvedSigningRegion)(hostname, {
        signingRegion: (_e = regionHash[resolvedRegion]) === null || _e === void 0 ? void 0 : _e.signingRegion,
        regionRegex: partitionHash[partition].regionRegex,
        useFipsEndpoint,
    });
    return {
        partition,
        signingService,
        hostname,
        ...(signingRegion && { signingRegion }),
        ...(((_f = regionHash[resolvedRegion]) === null || _f === void 0 ? void 0 : _f.signingService) && {
            signingService: regionHash[resolvedRegion].signingService,
        }),
    };
};
exports.getRegionInfo = getRegionInfo;


/***/ }),

/***/ 1487:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedHostname = void 0;
const getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname
    ? regionHostname
    : partitionHostname
        ? partitionHostname.replace("{region}", resolvedRegion)
        : undefined;
exports.getResolvedHostname = getResolvedHostname;


/***/ }),

/***/ 44441:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedPartition = void 0;
const getResolvedPartition = (region, { partitionHash }) => { var _a; return (_a = Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region))) !== null && _a !== void 0 ? _a : "aws"; };
exports.getResolvedPartition = getResolvedPartition;


/***/ }),

/***/ 92281:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedSigningRegion = void 0;
const getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
    if (signingRegion) {
        return signingRegion;
    }
    else if (useFipsEndpoint) {
        const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
        const regionRegexmatchArray = hostname.match(regionRegexJs);
        if (regionRegexmatchArray) {
            return regionRegexmatchArray[0].slice(1, -1);
        }
    }
};
exports.getResolvedSigningRegion = getResolvedSigningRegion;


/***/ }),

/***/ 86985:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(19814), exports);
tslib_1.__exportStar(__nccwpck_require__(14832), exports);
tslib_1.__exportStar(__nccwpck_require__(77792), exports);


/***/ }),

/***/ 18044:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Endpoint = void 0;
var Endpoint;
(function (Endpoint) {
    Endpoint["IPv4"] = "http://169.254.169.254";
    Endpoint["IPv6"] = "http://[fd00:ec2::254]";
})(Endpoint = exports.Endpoint || (exports.Endpoint = {}));


/***/ }),

/***/ 57342:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENDPOINT_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_NAME = exports.ENV_ENDPOINT_NAME = void 0;
exports.ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
exports.CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
exports.ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_NAME],
    configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_NAME],
    default: undefined,
};


/***/ }),

/***/ 80991:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointMode = void 0;
var EndpointMode;
(function (EndpointMode) {
    EndpointMode["IPv4"] = "IPv4";
    EndpointMode["IPv6"] = "IPv6";
})(EndpointMode = exports.EndpointMode || (exports.EndpointMode = {}));


/***/ }),

/***/ 88337:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENDPOINT_MODE_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_MODE_NAME = exports.ENV_ENDPOINT_MODE_NAME = void 0;
const EndpointMode_1 = __nccwpck_require__(80991);
exports.ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
exports.CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
exports.ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode_1.EndpointMode.IPv4,
};


/***/ }),

/***/ 89227:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromContainerMetadata = exports.ENV_CMDS_AUTH_TOKEN = exports.ENV_CMDS_RELATIVE_URI = exports.ENV_CMDS_FULL_URI = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const url_1 = __nccwpck_require__(57310);
const httpRequest_1 = __nccwpck_require__(32199);
const ImdsCredentials_1 = __nccwpck_require__(6894);
const RemoteProviderInit_1 = __nccwpck_require__(98533);
const retry_1 = __nccwpck_require__(91351);
exports.ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
exports.ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
exports.ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
const fromContainerMetadata = (init = {}) => {
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
    return () => (0, retry_1.retry)(async () => {
        const requestOptions = await getCmdsUri();
        const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
        if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
            throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
        }
        return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
    }, maxRetries);
};
exports.fromContainerMetadata = fromContainerMetadata;
const requestFromEcsImds = async (timeout, options) => {
    if (process.env[exports.ENV_CMDS_AUTH_TOKEN]) {
        options.headers = {
            ...options.headers,
            Authorization: process.env[exports.ENV_CMDS_AUTH_TOKEN],
        };
    }
    const buffer = await (0, httpRequest_1.httpRequest)({
        ...options,
        timeout,
    });
    return buffer.toString();
};
const CMDS_IP = "169.254.170.2";
const GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true,
};
const GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true,
};
const getCmdsUri = async () => {
    if (process.env[exports.ENV_CMDS_RELATIVE_URI]) {
        return {
            hostname: CMDS_IP,
            path: process.env[exports.ENV_CMDS_RELATIVE_URI],
        };
    }
    if (process.env[exports.ENV_CMDS_FULL_URI]) {
        const parsed = (0, url_1.parse)(process.env[exports.ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
            throw new property_provider_1.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
            throw new property_provider_1.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
        }
        return {
            ...parsed,
            port: parsed.port ? parseInt(parsed.port, 10) : undefined,
        };
    }
    throw new property_provider_1.CredentialsProviderError("The container metadata credential provider cannot be used unless" +
        ` the ${exports.ENV_CMDS_RELATIVE_URI} or ${exports.ENV_CMDS_FULL_URI} environment` +
        " variable is set", false);
};


/***/ }),

/***/ 52207:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromInstanceMetadata = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const httpRequest_1 = __nccwpck_require__(32199);
const ImdsCredentials_1 = __nccwpck_require__(6894);
const RemoteProviderInit_1 = __nccwpck_require__(98533);
const retry_1 = __nccwpck_require__(91351);
const getInstanceMetadataEndpoint_1 = __nccwpck_require__(92460);
const staticStabilityProvider_1 = __nccwpck_require__(74035);
const IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
const IMDS_TOKEN_PATH = "/latest/api/token";
const fromInstanceMetadata = (init = {}) => (0, staticStabilityProvider_1.staticStabilityProvider)(getInstanceImdsProvider(init), { logger: init.logger });
exports.fromInstanceMetadata = fromInstanceMetadata;
const getInstanceImdsProvider = (init) => {
    let disableFetchToken = false;
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
    const getCredentials = async (maxRetries, options) => {
        const profile = (await (0, retry_1.retry)(async () => {
            let profile;
            try {
                profile = await getProfile(options);
            }
            catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return profile;
        }, maxRetries)).trim();
        return (0, retry_1.retry)(async () => {
            let creds;
            try {
                creds = await getCredentialsFromProfile(profile, options);
            }
            catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return creds;
        }, maxRetries);
    };
    return async () => {
        const endpoint = await (0, getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint)();
        if (disableFetchToken) {
            return getCredentials(maxRetries, { ...endpoint, timeout });
        }
        else {
            let token;
            try {
                token = (await getMetadataToken({ ...endpoint, timeout })).toString();
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.statusCode) === 400) {
                    throw Object.assign(error, {
                        message: "EC2 Metadata token request returned error",
                    });
                }
                else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
                    disableFetchToken = true;
                }
                return getCredentials(maxRetries, { ...endpoint, timeout });
            }
            return getCredentials(maxRetries, {
                ...endpoint,
                headers: {
                    "x-aws-ec2-metadata-token": token,
                },
                timeout,
            });
        }
    };
};
const getMetadataToken = async (options) => (0, httpRequest_1.httpRequest)({
    ...options,
    path: IMDS_TOKEN_PATH,
    method: "PUT",
    headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600",
    },
});
const getProfile = async (options) => (await (0, httpRequest_1.httpRequest)({ ...options, path: IMDS_PATH })).toString();
const getCredentialsFromProfile = async (profile, options) => {
    const credsResponse = JSON.parse((await (0, httpRequest_1.httpRequest)({
        ...options,
        path: IMDS_PATH + profile,
    })).toString());
    if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
        throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
    }
    return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
};


/***/ }),

/***/ 7477:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInstanceMetadataEndpoint = exports.httpRequest = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(89227), exports);
tslib_1.__exportStar(__nccwpck_require__(52207), exports);
tslib_1.__exportStar(__nccwpck_require__(98533), exports);
tslib_1.__exportStar(__nccwpck_require__(45036), exports);
var httpRequest_1 = __nccwpck_require__(32199);
Object.defineProperty(exports, "httpRequest", ({ enumerable: true, get: function () { return httpRequest_1.httpRequest; } }));
var getInstanceMetadataEndpoint_1 = __nccwpck_require__(92460);
Object.defineProperty(exports, "getInstanceMetadataEndpoint", ({ enumerable: true, get: function () { return getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint; } }));


/***/ }),

/***/ 6894:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromImdsCredentials = exports.isImdsCredentials = void 0;
const isImdsCredentials = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.AccessKeyId === "string" &&
    typeof arg.SecretAccessKey === "string" &&
    typeof arg.Token === "string" &&
    typeof arg.Expiration === "string";
exports.isImdsCredentials = isImdsCredentials;
const fromImdsCredentials = (creds) => ({
    accessKeyId: creds.AccessKeyId,
    secretAccessKey: creds.SecretAccessKey,
    sessionToken: creds.Token,
    expiration: new Date(creds.Expiration),
});
exports.fromImdsCredentials = fromImdsCredentials;


/***/ }),

/***/ 98533:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.providerConfigFromInit = exports.DEFAULT_MAX_RETRIES = exports.DEFAULT_TIMEOUT = void 0;
exports.DEFAULT_TIMEOUT = 1000;
exports.DEFAULT_MAX_RETRIES = 0;
const providerConfigFromInit = ({ maxRetries = exports.DEFAULT_MAX_RETRIES, timeout = exports.DEFAULT_TIMEOUT, }) => ({ maxRetries, timeout });
exports.providerConfigFromInit = providerConfigFromInit;


/***/ }),

/***/ 32199:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.httpRequest = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const buffer_1 = __nccwpck_require__(14300);
const http_1 = __nccwpck_require__(13685);
function httpRequest(options) {
    return new Promise((resolve, reject) => {
        var _a;
        const req = (0, http_1.request)({
            method: "GET",
            ...options,
            hostname: (_a = options.hostname) === null || _a === void 0 ? void 0 : _a.replace(/^\[(.+)\]$/, "$1"),
        });
        req.on("error", (err) => {
            reject(Object.assign(new property_provider_1.ProviderError("Unable to connect to instance metadata service"), err));
            req.destroy();
        });
        req.on("timeout", () => {
            reject(new property_provider_1.ProviderError("TimeoutError from instance metadata service"));
            req.destroy();
        });
        req.on("response", (res) => {
            const { statusCode = 400 } = res;
            if (statusCode < 200 || 300 <= statusCode) {
                reject(Object.assign(new property_provider_1.ProviderError("Error response received from instance metadata service"), { statusCode }));
                req.destroy();
            }
            const chunks = [];
            res.on("data", (chunk) => {
                chunks.push(chunk);
            });
            res.on("end", () => {
                resolve(buffer_1.Buffer.concat(chunks));
                req.destroy();
            });
        });
        req.end();
    });
}
exports.httpRequest = httpRequest;


/***/ }),

/***/ 91351:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retry = void 0;
const retry = (toRetry, maxRetries) => {
    let promise = toRetry();
    for (let i = 0; i < maxRetries; i++) {
        promise = promise.catch(toRetry);
    }
    return promise;
};
exports.retry = retry;


/***/ }),

/***/ 45036:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 22666:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExtendedInstanceMetadataCredentials = void 0;
const STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
const STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
const STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
const getExtendedInstanceMetadataCredentials = (credentials, logger) => {
    var _a;
    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS +
        Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
    const newExpiration = new Date(Date.now() + refreshInterval * 1000);
    logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " +
        "credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " +
        STATIC_STABILITY_DOC_URL);
    const originalExpiration = (_a = credentials.originalExpiration) !== null && _a !== void 0 ? _a : credentials.expiration;
    return {
        ...credentials,
        ...(originalExpiration ? { originalExpiration } : {}),
        expiration: newExpiration,
    };
};
exports.getExtendedInstanceMetadataCredentials = getExtendedInstanceMetadataCredentials;


/***/ }),

/***/ 92460:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInstanceMetadataEndpoint = void 0;
const node_config_provider_1 = __nccwpck_require__(33461);
const url_parser_1 = __nccwpck_require__(14681);
const Endpoint_1 = __nccwpck_require__(18044);
const EndpointConfigOptions_1 = __nccwpck_require__(57342);
const EndpointMode_1 = __nccwpck_require__(80991);
const EndpointModeConfigOptions_1 = __nccwpck_require__(88337);
const getInstanceMetadataEndpoint = async () => (0, url_parser_1.parseUrl)((await getFromEndpointConfig()) || (await getFromEndpointModeConfig()));
exports.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
const getFromEndpointConfig = async () => (0, node_config_provider_1.loadConfig)(EndpointConfigOptions_1.ENDPOINT_CONFIG_OPTIONS)();
const getFromEndpointModeConfig = async () => {
    const endpointMode = await (0, node_config_provider_1.loadConfig)(EndpointModeConfigOptions_1.ENDPOINT_MODE_CONFIG_OPTIONS)();
    switch (endpointMode) {
        case EndpointMode_1.EndpointMode.IPv4:
            return Endpoint_1.Endpoint.IPv4;
        case EndpointMode_1.EndpointMode.IPv6:
            return Endpoint_1.Endpoint.IPv6;
        default:
            throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode_1.EndpointMode)}`);
    }
};


/***/ }),

/***/ 74035:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.staticStabilityProvider = void 0;
const getExtendedInstanceMetadataCredentials_1 = __nccwpck_require__(22666);
const staticStabilityProvider = (provider, options = {}) => {
    const logger = (options === null || options === void 0 ? void 0 : options.logger) || console;
    let pastCredentials;
    return async () => {
        let credentials;
        try {
            credentials = await provider();
            if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
                credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(credentials, logger);
            }
        }
        catch (e) {
            if (pastCredentials) {
                logger.warn("Credential renew failed: ", e);
                credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(pastCredentials, logger);
            }
            else {
                throw e;
            }
        }
        pastCredentials = credentials;
        return credentials;
    };
};
exports.staticStabilityProvider = staticStabilityProvider;


/***/ }),

/***/ 11014:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventStreamCodec = void 0;
const crc32_1 = __nccwpck_require__(47327);
const HeaderMarshaller_1 = __nccwpck_require__(74712);
const splitMessage_1 = __nccwpck_require__(20597);
class EventStreamCodec {
    constructor(toUtf8, fromUtf8) {
        this.headerMarshaller = new HeaderMarshaller_1.HeaderMarshaller(toUtf8, fromUtf8);
        this.messageBuffer = [];
        this.isEndOfStream = false;
    }
    feed(message) {
        this.messageBuffer.push(this.decode(message));
    }
    endOfStream() {
        this.isEndOfStream = true;
    }
    getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessage() {
                return message;
            },
            isEndOfStream() {
                return isEndOfStream;
            },
        };
    }
    getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessages() {
                return messages;
            },
            isEndOfStream() {
                return isEndOfStream;
            },
        };
    }
    encode({ headers: rawHeaders, body }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new crc32_1.Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
    }
    decode(message) {
        const { headers, body } = (0, splitMessage_1.splitMessage)(message);
        return { headers: this.headerMarshaller.parse(headers), body };
    }
    formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
    }
}
exports.EventStreamCodec = EventStreamCodec;


/***/ }),

/***/ 74712:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderMarshaller = void 0;
const util_hex_encoding_1 = __nccwpck_require__(45364);
const Int64_1 = __nccwpck_require__(46086);
class HeaderMarshaller {
    constructor(toUtf8, fromUtf8) {
        this.toUtf8 = toUtf8;
        this.fromUtf8 = fromUtf8;
    }
    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
            const bytes = this.fromUtf8(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }
    formatHeaderValue(header) {
        switch (header.type) {
            case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
                return Uint8Array.from([2, header.value]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = this.fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64_1.Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set((0, util_hex_encoding_1.fromHex)(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }
    parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
            const nameLength = headers.getUint8(position++);
            const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
            position += nameLength;
            switch (headers.getUint8(position++)) {
                case 0:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: true,
                    };
                    break;
                case 1:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: false,
                    };
                    break;
                case 2:
                    out[name] = {
                        type: BYTE_TAG,
                        value: headers.getInt8(position++),
                    };
                    break;
                case 3:
                    out[name] = {
                        type: SHORT_TAG,
                        value: headers.getInt16(position, false),
                    };
                    position += 2;
                    break;
                case 4:
                    out[name] = {
                        type: INT_TAG,
                        value: headers.getInt32(position, false),
                    };
                    position += 4;
                    break;
                case 5:
                    out[name] = {
                        type: LONG_TAG,
                        value: new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),
                    };
                    position += 8;
                    break;
                case 6:
                    const binaryLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: BINARY_TAG,
                        value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),
                    };
                    position += binaryLength;
                    break;
                case 7:
                    const stringLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: STRING_TAG,
                        value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),
                    };
                    position += stringLength;
                    break;
                case 8:
                    out[name] = {
                        type: TIMESTAMP_TAG,
                        value: new Date(new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),
                    };
                    position += 8;
                    break;
                case 9:
                    const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
                    position += 16;
                    out[name] = {
                        type: UUID_TAG,
                        value: `${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(0, 4))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(4, 6))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(6, 8))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(8, 10))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(10))}`,
                    };
                    break;
                default:
                    throw new Error(`Unrecognized header type tag`);
            }
        }
        return out;
    }
}
exports.HeaderMarshaller = HeaderMarshaller;
var HEADER_VALUE_TYPE;
(function (HEADER_VALUE_TYPE) {
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const BOOLEAN_TAG = "boolean";
const BYTE_TAG = "byte";
const SHORT_TAG = "short";
const INT_TAG = "integer";
const LONG_TAG = "long";
const BINARY_TAG = "binary";
const STRING_TAG = "string";
const TIMESTAMP_TAG = "timestamp";
const UUID_TAG = "uuid";
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;


/***/ }),

/***/ 46086:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Int64 = void 0;
const util_hex_encoding_1 = __nccwpck_require__(45364);
class Int64 {
    constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }
    static fromNumber(number) {
        if (number > 9223372036854776000 || number < -9223372036854776000) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate(bytes);
        }
        return new Int64(bytes);
    }
    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 0b10000000;
        if (negative) {
            negate(bytes);
        }
        return parseInt((0, util_hex_encoding_1.toHex)(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
        return String(this.valueOf());
    }
}
exports.Int64 = Int64;
function negate(bytes) {
    for (let i = 0; i < 8; i++) {
        bytes[i] ^= 0xff;
    }
    for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0)
            break;
    }
}


/***/ }),

/***/ 73684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57255:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageDecoderStream = void 0;
class MessageDecoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
            const decoded = this.options.decoder.decode(bytes);
            yield decoded;
        }
    }
}
exports.MessageDecoderStream = MessageDecoderStream;


/***/ }),

/***/ 52362:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageEncoderStream = void 0;
class MessageEncoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
            const encoded = this.options.encoder.encode(msg);
            yield encoded;
        }
        if (this.options.includeEndFrame) {
            yield new Uint8Array(0);
        }
    }
}
exports.MessageEncoderStream = MessageEncoderStream;


/***/ }),

/***/ 62379:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmithyMessageDecoderStream = void 0;
class SmithyMessageDecoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const message of this.options.messageStream) {
            const deserialized = await this.options.deserializer(message);
            if (deserialized === undefined)
                continue;
            yield deserialized;
        }
    }
}
exports.SmithyMessageDecoderStream = SmithyMessageDecoderStream;


/***/ }),

/***/ 12484:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmithyMessageEncoderStream = void 0;
class SmithyMessageEncoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const chunk of this.options.inputStream) {
            const payloadBuf = this.options.serializer(chunk);
            yield payloadBuf;
        }
    }
}
exports.SmithyMessageEncoderStream = SmithyMessageEncoderStream;


/***/ }),

/***/ 56459:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(11014), exports);
tslib_1.__exportStar(__nccwpck_require__(74712), exports);
tslib_1.__exportStar(__nccwpck_require__(46086), exports);
tslib_1.__exportStar(__nccwpck_require__(73684), exports);
tslib_1.__exportStar(__nccwpck_require__(57255), exports);
tslib_1.__exportStar(__nccwpck_require__(52362), exports);
tslib_1.__exportStar(__nccwpck_require__(62379), exports);
tslib_1.__exportStar(__nccwpck_require__(12484), exports);


/***/ }),

/***/ 20597:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitMessage = void 0;
const crc32_1 = __nccwpck_require__(47327);
const PRELUDE_MEMBER_LENGTH = 4;
const PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
const CHECKSUM_LENGTH = 4;
const MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
    if (byteLength < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength);
    const messageLength = view.getUint32(0, false);
    if (byteLength !== messageLength) {
        throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
    const checksummer = new crc32_1.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)),
    };
}
exports.splitMessage = splitMessage;


/***/ }),

/***/ 3081:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const util_utf8_1 = __nccwpck_require__(41895);
const buffer_1 = __nccwpck_require__(14300);
const crypto_1 = __nccwpck_require__(6113);
class Hash {
    constructor(algorithmIdentifier, secret) {
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
    }
    update(toHash, encoding) {
        this.hash.update((0, util_utf8_1.toUint8Array)(castSourceData(toHash, encoding)));
    }
    digest() {
        return Promise.resolve(this.hash.digest());
    }
    reset() {
        this.hash = this.secret
            ? (0, crypto_1.createHmac)(this.algorithmIdentifier, castSourceData(this.secret))
            : (0, crypto_1.createHash)(this.algorithmIdentifier);
    }
}
exports.Hash = Hash;
function castSourceData(toCast, encoding) {
    if (buffer_1.Buffer.isBuffer(toCast)) {
        return toCast;
    }
    if (typeof toCast === "string") {
        return (0, util_buffer_from_1.fromString)(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
        return (0, util_buffer_from_1.fromArrayBuffer)(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(toCast);
}


/***/ }),

/***/ 10780:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isArrayBuffer = void 0;
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
exports.isArrayBuffer = isArrayBuffer;


/***/ }),

/***/ 82800:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContentLengthPlugin = exports.contentLengthMiddlewareOptions = exports.contentLengthMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
        const request = args.request;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            const { body, headers } = request;
            if (body &&
                Object.keys(headers)
                    .map((str) => str.toLowerCase())
                    .indexOf(CONTENT_LENGTH_HEADER) === -1) {
                try {
                    const length = bodyLengthChecker(body);
                    request.headers = {
                        ...request.headers,
                        [CONTENT_LENGTH_HEADER]: String(length),
                    };
                }
                catch (error) {
                }
            }
        }
        return next({
            ...args,
            request,
        });
    };
}
exports.contentLengthMiddleware = contentLengthMiddleware;
exports.contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true,
};
const getContentLengthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), exports.contentLengthMiddlewareOptions);
    },
});
exports.getContentLengthPlugin = getContentLengthPlugin;


/***/ }),

/***/ 465:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConfigValueProvider = void 0;
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        var _a;
        const configValue = (_a = config[configKey]) !== null && _a !== void 0 ? _a : config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};
exports.createConfigValueProvider = createConfigValueProvider;


/***/ }),

/***/ 73929:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveParams = exports.getEndpointFromInstructions = void 0;
const service_customizations_1 = __nccwpck_require__(13105);
const createConfigValueProvider_1 = __nccwpck_require__(465);
const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    const endpointParams = await (0, exports.resolveParams)(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
exports.getEndpointFromInstructions = getEndpointFromInstructions;
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    var _a;
    const endpointParams = {};
    const instructions = ((_a = instructionsSupplier === null || instructionsSupplier === void 0 ? void 0 : instructionsSupplier.getEndpointParameterInstructions) === null || _a === void 0 ? void 0 : _a.call(instructionsSupplier)) || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await (0, createConfigValueProvider_1.createConfigValueProvider)(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await (0, service_customizations_1.resolveParamsForS3)(endpointParams);
    }
    return endpointParams;
};
exports.resolveParams = resolveParams;


/***/ }),

/***/ 50890:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(73929), exports);
tslib_1.__exportStar(__nccwpck_require__(38938), exports);


/***/ }),

/***/ 38938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toEndpointV1 = void 0;
const url_parser_1 = __nccwpck_require__(14681);
const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return (0, url_parser_1.parseUrl)(endpoint.url);
        }
        return endpoint;
    }
    return (0, url_parser_1.parseUrl)(endpoint);
};
exports.toEndpointV1 = toEndpointV1;


/***/ }),

/***/ 55520:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.endpointMiddleware = void 0;
const getEndpointFromInstructions_1 = __nccwpck_require__(73929);
const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        var _a, _b;
        const endpoint = await (0, getEndpointFromInstructions_1.getEndpointFromInstructions)(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = (_a = endpoint.properties) === null || _a === void 0 ? void 0 : _a.authSchemes;
        const authScheme = (_b = context.authSchemes) === null || _b === void 0 ? void 0 : _b[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
        }
        return next({
            ...args,
        });
    };
};
exports.endpointMiddleware = endpointMiddleware;


/***/ }),

/***/ 71329:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointPlugin = exports.endpointMiddlewareOptions = void 0;
const middleware_serde_1 = __nccwpck_require__(81238);
const endpointMiddleware_1 = __nccwpck_require__(55520);
exports.endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middleware_serde_1.serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, endpointMiddleware_1.endpointMiddleware)({
            config,
            instructions,
        }), exports.endpointMiddlewareOptions);
    },
});
exports.getEndpointPlugin = getEndpointPlugin;


/***/ }),

/***/ 82918:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(50890), exports);
tslib_1.__exportStar(__nccwpck_require__(55520), exports);
tslib_1.__exportStar(__nccwpck_require__(71329), exports);
tslib_1.__exportStar(__nccwpck_require__(74139), exports);
tslib_1.__exportStar(__nccwpck_require__(39720), exports);


/***/ }),

/***/ 74139:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpointConfig = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const toEndpointV1_1 = __nccwpck_require__(38938);
const resolveEndpointConfig = (input) => {
    var _a, _b, _c;
    const tls = (_a = input.tls) !== null && _a !== void 0 ? _a : true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => (0, toEndpointV1_1.toEndpointV1)(await (0, util_middleware_1.normalizeProvider)(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== void 0 ? _b : false),
        useFipsEndpoint: (0, util_middleware_1.normalizeProvider)((_c = input.useFipsEndpoint) !== null && _c !== void 0 ? _c : false),
    };
};
exports.resolveEndpointConfig = resolveEndpointConfig;


/***/ }),

/***/ 13105:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(19194), exports);


/***/ }),

/***/ 19194:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isArnBucketName = exports.isDnsCompatibleBucketName = exports.S3_HOSTNAME_PATTERN = exports.DOT_PATTERN = exports.resolveParamsForS3 = void 0;
const resolveParamsForS3 = async (endpointParams) => {
    const bucket = (endpointParams === null || endpointParams === void 0 ? void 0 : endpointParams.Bucket) || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if ((0, exports.isArnBucketName)(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!(0, exports.isDnsCompatibleBucketName)(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
exports.resolveParamsForS3 = resolveParamsForS3;
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
exports.DOT_PATTERN = /\./;
exports.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
exports.isDnsCompatibleBucketName = isDnsCompatibleBucketName;
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, region, account, typeOrId] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = [arn, partition, service, account, typeOrId].filter(Boolean).length === 5;
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return arn === "arn" && !!partition && !!service && !!account && !!typeOrId;
};
exports.isArnBucketName = isArnBucketName;


/***/ }),

/***/ 39720:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 80155:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveRetryStrategy = void 0;
const util_retry_1 = __nccwpck_require__(84902);
const StandardRetryStrategy_1 = __nccwpck_require__(94582);
class AdaptiveRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        const { rateLimiter, ...superOptions } = options !== null && options !== void 0 ? options : {};
        super(maxAttemptsProvider, superOptions);
        this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new util_retry_1.DefaultRateLimiter();
        this.mode = util_retry_1.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
        return super.retry(next, args, {
            beforeRequest: async () => {
                return this.rateLimiter.getSendToken();
            },
            afterRequest: (response) => {
                this.rateLimiter.updateClientSendingRate(response);
            },
        });
    }
}
exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


/***/ }),

/***/ 94582:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardRetryStrategy = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const service_error_classification_1 = __nccwpck_require__(6375);
const util_retry_1 = __nccwpck_require__(84902);
const uuid_1 = __nccwpck_require__(75840);
const defaultRetryQuota_1 = __nccwpck_require__(29991);
const delayDecider_1 = __nccwpck_require__(9465);
const retryDecider_1 = __nccwpck_require__(67653);
const util_1 = __nccwpck_require__(42827);
class StandardRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        var _a, _b, _c;
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = util_retry_1.RETRY_MODES.STANDARD;
        this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : retryDecider_1.defaultRetryDecider;
        this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : delayDecider_1.defaultDelayDecider;
        this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : (0, defaultRetryQuota_1.getDefaultRetryQuota)(util_retry_1.INITIAL_RETRY_TOKENS);
    }
    shouldRetry(error, attempts, maxAttempts) {
        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
        let maxAttempts;
        try {
            maxAttempts = await this.maxAttemptsProvider();
        }
        catch (error) {
            maxAttempts = util_retry_1.DEFAULT_MAX_ATTEMPTS;
        }
        return maxAttempts;
    }
    async retry(next, args, options) {
        let retryTokenAmount;
        let attempts = 0;
        let totalDelay = 0;
        const maxAttempts = await this.getMaxAttempts();
        const { request } = args;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
        }
        while (true) {
            try {
                if (protocol_http_1.HttpRequest.isInstance(request)) {
                    request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                if (options === null || options === void 0 ? void 0 : options.beforeRequest) {
                    await options.beforeRequest();
                }
                const { response, output } = await next(args);
                if (options === null || options === void 0 ? void 0 : options.afterRequest) {
                    options.afterRequest(response);
                }
                this.retryQuota.releaseRetryTokens(retryTokenAmount);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalDelay;
                return { response, output };
            }
            catch (e) {
                const err = (0, util_1.asSdkError)(e);
                attempts++;
                if (this.shouldRetry(err, attempts, maxAttempts)) {
                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
                    const delayFromDecider = this.delayDecider((0, service_error_classification_1.isThrottlingError)(err) ? util_retry_1.THROTTLING_RETRY_DELAY_BASE : util_retry_1.DEFAULT_RETRY_DELAY_BASE, attempts);
                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);
                    totalDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    continue;
                }
                if (!err.$metadata) {
                    err.$metadata = {};
                }
                err.$metadata.attempts = attempts;
                err.$metadata.totalRetryDelay = totalDelay;
                throw err;
            }
        }
    }
}
exports.StandardRetryStrategy = StandardRetryStrategy;
const getDelayFromRetryAfterHeader = (response) => {
    if (!protocol_http_1.HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
};


/***/ }),

/***/ 58709:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = exports.CONFIG_RETRY_MODE = exports.ENV_RETRY_MODE = exports.resolveRetryConfig = exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = exports.CONFIG_MAX_ATTEMPTS = exports.ENV_MAX_ATTEMPTS = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const util_retry_1 = __nccwpck_require__(84902);
exports.ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
exports.CONFIG_MAX_ATTEMPTS = "max_attempts";
exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        const value = env[exports.ENV_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Environment variable ${exports.ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    configFileSelector: (profile) => {
        const value = profile[exports.CONFIG_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Shared config file entry ${exports.CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    default: util_retry_1.DEFAULT_MAX_ATTEMPTS,
};
const resolveRetryConfig = (input) => {
    var _a;
    const { retryStrategy } = input;
    const maxAttempts = (0, util_middleware_1.normalizeProvider)((_a = input.maxAttempts) !== null && _a !== void 0 ? _a : util_retry_1.DEFAULT_MAX_ATTEMPTS);
    return {
        ...input,
        maxAttempts,
        retryStrategy: async () => {
            if (retryStrategy) {
                return retryStrategy;
            }
            const retryMode = await (0, util_middleware_1.normalizeProvider)(input.retryMode)();
            if (retryMode === util_retry_1.RETRY_MODES.ADAPTIVE) {
                return new util_retry_1.AdaptiveRetryStrategy(maxAttempts);
            }
            return new util_retry_1.StandardRetryStrategy(maxAttempts);
        },
    };
};
exports.resolveRetryConfig = resolveRetryConfig;
exports.ENV_RETRY_MODE = "AWS_RETRY_MODE";
exports.CONFIG_RETRY_MODE = "retry_mode";
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[exports.CONFIG_RETRY_MODE],
    default: util_retry_1.DEFAULT_RETRY_MODE,
};


/***/ }),

/***/ 29991:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRetryQuota = void 0;
const util_retry_1 = __nccwpck_require__(84902);
const getDefaultRetryQuota = (initialRetryTokens, options) => {
    var _a, _b, _c;
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : util_retry_1.NO_RETRY_INCREMENT;
    const retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : util_retry_1.RETRY_COST;
    const timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : util_retry_1.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error) => (error.name === "TimeoutError" ? timeoutRetryCost : retryCost);
    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error) => {
        if (!hasRetryTokens(error)) {
            throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(error);
        availableCapacity -= capacityAmount;
        return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount) => {
        availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
        hasRetryTokens,
        retrieveRetryTokens,
        releaseRetryTokens,
    });
};
exports.getDefaultRetryQuota = getDefaultRetryQuota;


/***/ }),

/***/ 9465:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultDelayDecider = void 0;
const util_retry_1 = __nccwpck_require__(84902);
const defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(util_retry_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
exports.defaultDelayDecider = defaultDelayDecider;


/***/ }),

/***/ 96039:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80155), exports);
tslib_1.__exportStar(__nccwpck_require__(94582), exports);
tslib_1.__exportStar(__nccwpck_require__(58709), exports);
tslib_1.__exportStar(__nccwpck_require__(9465), exports);
tslib_1.__exportStar(__nccwpck_require__(76556), exports);
tslib_1.__exportStar(__nccwpck_require__(67653), exports);
tslib_1.__exportStar(__nccwpck_require__(81434), exports);


/***/ }),

/***/ 76556:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOmitRetryHeadersPlugin = exports.omitRetryHeadersMiddlewareOptions = exports.omitRetryHeadersMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const util_retry_1 = __nccwpck_require__(84902);
const omitRetryHeadersMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (protocol_http_1.HttpRequest.isInstance(request)) {
        delete request.headers[util_retry_1.INVOCATION_ID_HEADER];
        delete request.headers[util_retry_1.REQUEST_HEADER];
    }
    return next(args);
};
exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
exports.omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true,
};
const getOmitRetryHeadersPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, exports.omitRetryHeadersMiddleware)(), exports.omitRetryHeadersMiddlewareOptions);
    },
});
exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;


/***/ }),

/***/ 67653:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultRetryDecider = void 0;
const service_error_classification_1 = __nccwpck_require__(6375);
const defaultRetryDecider = (error) => {
    if (!error) {
        return false;
    }
    return (0, service_error_classification_1.isRetryableByTrait)(error) || (0, service_error_classification_1.isClockSkewError)(error) || (0, service_error_classification_1.isThrottlingError)(error) || (0, service_error_classification_1.isTransientError)(error);
};
exports.defaultRetryDecider = defaultRetryDecider;


/***/ }),

/***/ 81434:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRetryAfterHint = exports.getRetryPlugin = exports.retryMiddlewareOptions = exports.retryMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const service_error_classification_1 = __nccwpck_require__(6375);
const util_retry_1 = __nccwpck_require__(84902);
const uuid_1 = __nccwpck_require__(75840);
const util_1 = __nccwpck_require__(42827);
const retryMiddleware = (options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
        }
        while (true) {
            try {
                if (protocol_http_1.HttpRequest.isInstance(request)) {
                    request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                const { response, output } = await next(args);
                retryStrategy.recordSuccess(retryToken);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalRetryDelay;
                return { response, output };
            }
            catch (e) {
                const retryErrorInfo = getRetryErrorInfo(e);
                lastError = (0, util_1.asSdkError)(e);
                try {
                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                }
                catch (refreshError) {
                    if (!lastError.$metadata) {
                        lastError.$metadata = {};
                    }
                    lastError.$metadata.attempts = attempts + 1;
                    lastError.$metadata.totalRetryDelay = totalRetryDelay;
                    throw lastError;
                }
                attempts = retryToken.getRetryCount();
                const delay = retryToken.getRetryDelay();
                totalRetryDelay += delay;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
        }
    }
    else {
        retryStrategy = retryStrategy;
        if (retryStrategy === null || retryStrategy === void 0 ? void 0 : retryStrategy.mode)
            context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
    }
};
exports.retryMiddleware = retryMiddleware;
const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
    typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
    typeof retryStrategy.recordSuccess !== "undefined";
const getRetryErrorInfo = (error) => {
    const errorInfo = {
        errorType: getRetryErrorType(error),
    };
    const retryAfterHint = (0, exports.getRetryAfterHint)(error.$response);
    if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
};
const getRetryErrorType = (error) => {
    if ((0, service_error_classification_1.isThrottlingError)(error))
        return "THROTTLING";
    if ((0, service_error_classification_1.isTransientError)(error))
        return "TRANSIENT";
    if ((0, service_error_classification_1.isServerError)(error))
        return "SERVER_ERROR";
    return "CLIENT_ERROR";
};
exports.retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true,
};
const getRetryPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.retryMiddleware)(options), exports.retryMiddlewareOptions);
    },
});
exports.getRetryPlugin = getRetryPlugin;
const getRetryAfterHint = (response) => {
    if (!protocol_http_1.HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
};
exports.getRetryAfterHint = getRetryAfterHint;


/***/ }),

/***/ 42827:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asSdkError = void 0;
const asSdkError = (error) => {
    if (error instanceof Error)
        return error;
    if (error instanceof Object)
        return Object.assign(new Error(), error);
    if (typeof error === "string")
        return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
};
exports.asSdkError = asSdkError;


/***/ }),

/***/ 21595:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializerMiddleware = void 0;
const deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
        }
        throw error;
    }
};
exports.deserializerMiddleware = deserializerMiddleware;


/***/ }),

/***/ 81238:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(21595), exports);
tslib_1.__exportStar(__nccwpck_require__(72338), exports);
tslib_1.__exportStar(__nccwpck_require__(23566), exports);


/***/ }),

/***/ 72338:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSerdePlugin = exports.serializerMiddlewareOption = exports.deserializerMiddlewareOption = void 0;
const deserializerMiddleware_1 = __nccwpck_require__(21595);
const serializerMiddleware_1 = __nccwpck_require__(23566);
exports.deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
exports.serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add((0, deserializerMiddleware_1.deserializerMiddleware)(config, deserializer), exports.deserializerMiddlewareOption);
            commandStack.add((0, serializerMiddleware_1.serializerMiddleware)(config, serializer), exports.serializerMiddlewareOption);
        },
    };
}
exports.getSerdePlugin = getSerdePlugin;


/***/ }),

/***/ 23566:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializerMiddleware = void 0;
const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    var _a;
    const endpoint = ((_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.url) && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};
exports.serializerMiddleware = serializerMiddleware;


/***/ }),

/***/ 2404:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constructStack = void 0;
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.name && entry.name === toRemove) {
                isRemoved = true;
                entriesNameSet.delete(toRemove);
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                if (entry.name)
                    entriesNameSet.delete(entry.name);
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            if (normalizedEntry.name)
                normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            if (normalizedEntry.name)
                normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            if (name) {
                if (entriesNameSet.has(name)) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${name}'`);
                    const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === name);
                    const toOverride = absoluteEntries[toOverrideIndex];
                    if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
                        throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be ` +
                            `overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
                    }
                    absoluteEntries.splice(toOverrideIndex, 1);
                }
                entriesNameSet.add(name);
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override } = options;
            const entry = {
                middleware,
                ...options,
            };
            if (name) {
                if (entriesNameSet.has(name)) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${name}'`);
                    const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === name);
                    const toOverride = relativeEntries[toOverrideIndex];
                    if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                        throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                            `by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
                    }
                    relativeEntries.splice(toOverrideIndex, 1);
                }
                entriesNameSet.add(name);
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo((0, exports.constructStack)()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name } = entry;
                if (tags && tags.includes(toRemove)) {
                    if (name)
                        entriesNameSet.delete(name);
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo((0, exports.constructStack)());
            cloned.use(from);
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                return mw.name + ": " + (mw.tags || []).join(",");
            });
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            return handler;
        },
    };
    return stack;
};
exports.constructStack = constructStack;
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};


/***/ }),

/***/ 97911:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(2404), exports);


/***/ }),

/***/ 54766:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadConfig = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromEnv_1 = __nccwpck_require__(15606);
const fromSharedConfigFiles_1 = __nccwpck_require__(45784);
const fromStatic_1 = __nccwpck_require__(23091);
const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromEnv_1.fromEnv)(environmentVariableSelector), (0, fromSharedConfigFiles_1.fromSharedConfigFiles)(configFileSelector, configuration), (0, fromStatic_1.fromStatic)(defaultValue)));
exports.loadConfig = loadConfig;


/***/ }),

/***/ 15606:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromEnv = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};
exports.fromEnv = fromEnv;


/***/ }),

/***/ 45784:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSharedConfigFiles = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = (0, shared_ini_file_loader_1.getProfileName)(init);
    const { configFile, credentialsFile } = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const configValue = configSelector(mergedProfile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};
exports.fromSharedConfigFiles = fromSharedConfigFiles;


/***/ }),

/***/ 23091:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const isFunction = (func) => typeof func === "function";
const fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : (0, property_provider_1.fromStatic)(defaultValue);
exports.fromStatic = fromStatic;


/***/ }),

/***/ 33461:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(54766), exports);


/***/ }),

/***/ 33946:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODEJS_TIMEOUT_ERROR_CODES = void 0;
exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];


/***/ }),

/***/ 70508:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransformedHeaders = void 0;
const getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};
exports.getTransformedHeaders = getTransformedHeaders;


/***/ }),

/***/ 20258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(96948), exports);
tslib_1.__exportStar(__nccwpck_require__(46999), exports);
tslib_1.__exportStar(__nccwpck_require__(81030), exports);


/***/ }),

/***/ 96948:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttpHandler = exports.DEFAULT_REQUEST_TIMEOUT = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const querystring_builder_1 = __nccwpck_require__(68031);
const http_1 = __nccwpck_require__(13685);
const https_1 = __nccwpck_require__(95687);
const constants_1 = __nccwpck_require__(33946);
const get_transformed_headers_1 = __nccwpck_require__(70508);
const set_connection_timeout_1 = __nccwpck_require__(25545);
const set_socket_keep_alive_1 = __nccwpck_require__(83751);
const set_socket_timeout_1 = __nccwpck_require__(42618);
const write_request_body_1 = __nccwpck_require__(73766);
exports.DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    constructor(options) {
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout !== null && requestTimeout !== void 0 ? requestTimeout : socketTimeout,
            httpAgent: httpAgent || new http_1.Agent({ keepAlive, maxSockets }),
            httpsAgent: httpsAgent || new https_1.Agent({ keepAlive, maxSockets }),
        };
    }
    destroy() {
        var _a, _b, _c, _d;
        (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.httpAgent) === null || _b === void 0 ? void 0 : _b.destroy();
        (_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.httpsAgent) === null || _d === void 0 ? void 0 : _d.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        return new Promise((_resolve, _reject) => {
            var _a, _b;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const queryString = (0, querystring_builder_1.buildQueryString)(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = (_a = request.username) !== null && _a !== void 0 ? _a : "";
                const password = (_b = request.password) !== null && _b !== void 0 ? _b : "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent: isSSL ? this.config.httpsAgent : this.config.httpAgent,
                auth,
            };
            const requestFunc = isSSL ? https_1.request : http_1.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            (0, set_connection_timeout_1.setConnectionTimeout)(req, reject, this.config.connectionTimeout);
            (0, set_socket_timeout_1.setSocketTimeout)(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                (0, set_socket_keep_alive_1.setSocketKeepAlive)(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = (0, write_request_body_1.writeRequestBody)(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
}
exports.NodeHttpHandler = NodeHttpHandler;


/***/ }),

/***/ 5771:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttp2ConnectionManager = void 0;
const tslib_1 = __nccwpck_require__(4351);
const http2_1 = tslib_1.__importDefault(__nccwpck_require__(85158));
const node_http2_connection_pool_1 = __nccwpck_require__(95157);
class NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2_1.default.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new node_http2_connection_pool_1.NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        var _a;
        const cacheKey = this.getUrlString(requestContext);
        (_a = this.sessionCache.get(cacheKey)) === null || _a === void 0 ? void 0 : _a.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}
exports.NodeHttp2ConnectionManager = NodeHttp2ConnectionManager;


/***/ }),

/***/ 95157:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttp2ConnectionPool = void 0;
class NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions !== null && sessions !== void 0 ? sessions : [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}
exports.NodeHttp2ConnectionPool = NodeHttp2ConnectionPool;


/***/ }),

/***/ 46999:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttp2Handler = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const querystring_builder_1 = __nccwpck_require__(68031);
const http2_1 = __nccwpck_require__(85158);
const get_transformed_headers_1 = __nccwpck_require__(70508);
const node_http2_connection_manager_1 = __nccwpck_require__(5771);
const write_request_body_1 = __nccwpck_require__(73766);
class NodeHttp2Handler {
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new node_http2_connection_manager_1.NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            var _a, _b, _c;
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = (_a = request.username) !== null && _a !== void 0 ? _a : "";
                const password = (_b = request.password) !== null && _b !== void 0 ? _b : "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: (_c = this.config) === null || _c === void 0 ? void 0 : _c.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = (0, querystring_builder_1.buildQueryString)(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [http2_1.constants.HTTP2_HEADER_PATH]: path,
                [http2_1.constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = (0, write_request_body_1.writeRequestBody)(req, request, requestTimeout);
        });
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}
exports.NodeHttp2Handler = NodeHttp2Handler;


/***/ }),

/***/ 25545:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setConnectionTimeout = void 0;
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError",
        }));
    }, timeoutInMs);
    request.on("socket", (socket) => {
        if (socket.connecting) {
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
        else {
            clearTimeout(timeoutId);
        }
    });
};
exports.setConnectionTimeout = setConnectionTimeout;


/***/ }),

/***/ 83751:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSocketKeepAlive = void 0;
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};
exports.setSocketKeepAlive = setSocketKeepAlive;


/***/ }),

/***/ 42618:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSocketTimeout = void 0;
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};
exports.setSocketTimeout = setSocketTimeout;


/***/ }),

/***/ 23211:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collector = void 0;
const stream_1 = __nccwpck_require__(12781);
class Collector extends stream_1.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}
exports.Collector = Collector;


/***/ }),

/***/ 81030:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.streamCollector = void 0;
const collector_1 = __nccwpck_require__(23211);
const streamCollector = (stream) => new Promise((resolve, reject) => {
    const collector = new collector_1.Collector();
    stream.pipe(collector);
    stream.on("error", (err) => {
        collector.end();
        reject(err);
    });
    collector.on("error", reject);
    collector.on("finish", function () {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve(bytes);
    });
});
exports.streamCollector = streamCollector;


/***/ }),

/***/ 73766:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeRequestBody = void 0;
const stream_1 = __nccwpck_require__(12781);
const MIN_WAIT_TIME = 1000;
async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    var _a;
    const headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
exports.writeRequestBody = writeRequestBody;
function writeBody(httpRequest, body) {
    if (body instanceof stream_1.Readable) {
        body.pipe(httpRequest);
    }
    else if (body) {
        httpRequest.end(Buffer.from(body));
    }
    else {
        httpRequest.end();
    }
}


/***/ }),

/***/ 63936:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CredentialsProviderError = void 0;
const ProviderError_1 = __nccwpck_require__(23324);
class CredentialsProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}
exports.CredentialsProviderError = CredentialsProviderError;


/***/ }),

/***/ 23324:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProviderError = void 0;
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}
exports.ProviderError = ProviderError;


/***/ }),

/***/ 50429:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenProviderError = void 0;
const ProviderError_1 = __nccwpck_require__(23324);
class TokenProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}
exports.TokenProviderError = TokenProviderError;


/***/ }),

/***/ 45079:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.chain = void 0;
const ProviderError_1 = __nccwpck_require__(23324);
function chain(...providers) {
    return () => {
        let promise = Promise.reject(new ProviderError_1.ProviderError("No providers in chain"));
        for (const provider of providers) {
            promise = promise.catch((err) => {
                if (err === null || err === void 0 ? void 0 : err.tryNextLink) {
                    return provider();
                }
                throw err;
            });
        }
        return promise;
    };
}
exports.chain = chain;


/***/ }),

/***/ 51322:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);
exports.fromStatic = fromStatic;


/***/ }),

/***/ 79721:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(63936), exports);
tslib_1.__exportStar(__nccwpck_require__(23324), exports);
tslib_1.__exportStar(__nccwpck_require__(50429), exports);
tslib_1.__exportStar(__nccwpck_require__(45079), exports);
tslib_1.__exportStar(__nccwpck_require__(51322), exports);
tslib_1.__exportStar(__nccwpck_require__(49762), exports);


/***/ }),

/***/ 49762:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.memoize = void 0;
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};
exports.memoize = memoize;


/***/ }),

/***/ 89179:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Field = void 0;
const types_1 = __nccwpck_require__(55756);
class Field {
    constructor({ name, kind = types_1.FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}
exports.Field = Field;


/***/ }),

/***/ 99242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Fields = void 0;
class Fields {
    constructor({ fields = [], encoding = "utf-8" }) {
        this.entries = {};
        fields.forEach(this.setField.bind(this));
        this.encoding = encoding;
    }
    setField(field) {
        this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
        return this.entries[name.toLowerCase()];
    }
    removeField(name) {
        delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
        return Object.values(this.entries).filter((field) => field.kind === kind);
    }
}
exports.Fields = Fields;


/***/ }),

/***/ 63206:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 38746:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpRequest = void 0;
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
exports.HttpRequest = HttpRequest;
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}


/***/ }),

/***/ 26322:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpResponse = void 0;
class HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}
exports.HttpResponse = HttpResponse;


/***/ }),

/***/ 64418:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(89179), exports);
tslib_1.__exportStar(__nccwpck_require__(99242), exports);
tslib_1.__exportStar(__nccwpck_require__(63206), exports);
tslib_1.__exportStar(__nccwpck_require__(38746), exports);
tslib_1.__exportStar(__nccwpck_require__(26322), exports);
tslib_1.__exportStar(__nccwpck_require__(61466), exports);
tslib_1.__exportStar(__nccwpck_require__(19135), exports);


/***/ }),

/***/ 61466:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidHostname = void 0;
function isValidHostname(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
}
exports.isValidHostname = isValidHostname;


/***/ }),

/***/ 19135:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 68031:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildQueryString = void 0;
const util_uri_escape_1 = __nccwpck_require__(54197);
function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = (0, util_uri_escape_1.escapeUri)(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${(0, util_uri_escape_1.escapeUri)(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${(0, util_uri_escape_1.escapeUri)(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}
exports.buildQueryString = buildQueryString;


/***/ }),

/***/ 4769:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseQueryString = void 0;
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}
exports.parseQueryString = parseQueryString;


/***/ }),

/***/ 68415:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODEJS_TIMEOUT_ERROR_CODES = exports.TRANSIENT_ERROR_STATUS_CODES = exports.TRANSIENT_ERROR_CODES = exports.THROTTLING_ERROR_CODES = exports.CLOCK_SKEW_ERROR_CODES = void 0;
exports.CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch",
];
exports.THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException",
];
exports.TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
exports.TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];


/***/ }),

/***/ 6375:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isServerError = exports.isTransientError = exports.isThrottlingError = exports.isClockSkewError = exports.isRetryableByTrait = void 0;
const constants_1 = __nccwpck_require__(68415);
const isRetryableByTrait = (error) => error.$retryable !== undefined;
exports.isRetryableByTrait = isRetryableByTrait;
const isClockSkewError = (error) => constants_1.CLOCK_SKEW_ERROR_CODES.includes(error.name);
exports.isClockSkewError = isClockSkewError;
const isThrottlingError = (error) => {
    var _a, _b;
    return ((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) === 429 ||
        constants_1.THROTTLING_ERROR_CODES.includes(error.name) ||
        ((_b = error.$retryable) === null || _b === void 0 ? void 0 : _b.throttling) == true;
};
exports.isThrottlingError = isThrottlingError;
const isTransientError = (error) => {
    var _a;
    return constants_1.TRANSIENT_ERROR_CODES.includes(error.name) ||
        constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes((error === null || error === void 0 ? void 0 : error.code) || "") ||
        constants_1.TRANSIENT_ERROR_STATUS_CODES.includes(((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) || 0);
};
exports.isTransientError = isTransientError;
const isServerError = (error) => {
    var _a;
    if (((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) !== undefined) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !(0, exports.isTransientError)(error)) {
            return true;
        }
        return false;
    }
    return false;
};
exports.isServerError = isServerError;


/***/ }),

/***/ 47237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getConfigFilepath = exports.ENV_CONFIG_PATH = void 0;
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(68340);
exports.ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath = () => process.env[exports.ENV_CONFIG_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "config");
exports.getConfigFilepath = getConfigFilepath;


/***/ }),

/***/ 99036:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCredentialsFilepath = exports.ENV_CREDENTIALS_PATH = void 0;
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(68340);
exports.ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[exports.ENV_CREDENTIALS_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "credentials");
exports.getCredentialsFilepath = getCredentialsFilepath;


/***/ }),

/***/ 68340:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHomeDir = void 0;
const os_1 = __nccwpck_require__(22037);
const path_1 = __nccwpck_require__(71017);
const getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    return (0, os_1.homedir)();
};
exports.getHomeDir = getHomeDir;


/***/ }),

/***/ 32041:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProfileData = void 0;
const profileKeyRegex = /^profile\s(["'])?([^\1]+)\1$/;
const getProfileData = (data) => Object.entries(data)
    .filter(([key]) => profileKeyRegex.test(key))
    .reduce((acc, [key, value]) => ({ ...acc, [profileKeyRegex.exec(key)[2]]: value }), {
    ...(data.default && { default: data.default }),
});
exports.getProfileData = getProfileData;


/***/ }),

/***/ 52802:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProfileName = exports.DEFAULT_PROFILE = exports.ENV_PROFILE = void 0;
exports.ENV_PROFILE = "AWS_PROFILE";
exports.DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[exports.ENV_PROFILE] || exports.DEFAULT_PROFILE;
exports.getProfileName = getProfileName;


/***/ }),

/***/ 24740:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSSOTokenFilepath = void 0;
const crypto_1 = __nccwpck_require__(6113);
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(68340);
const getSSOTokenFilepath = (id) => {
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
};
exports.getSSOTokenFilepath = getSSOTokenFilepath;


/***/ }),

/***/ 69678:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSSOTokenFromFile = void 0;
const fs_1 = __nccwpck_require__(57147);
const getSSOTokenFilepath_1 = __nccwpck_require__(24740);
const { readFile } = fs_1.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};
exports.getSSOTokenFromFile = getSSOTokenFromFile;


/***/ }),

/***/ 82820:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSsoSessionData = void 0;
const ssoSessionKeyRegex = /^sso-session\s(["'])?([^\1]+)\1$/;
const getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => ssoSessionKeyRegex.test(key))
    .reduce((acc, [key, value]) => ({ ...acc, [ssoSessionKeyRegex.exec(key)[2]]: value }), {});
exports.getSsoSessionData = getSsoSessionData;


/***/ }),

/***/ 43507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(68340), exports);
tslib_1.__exportStar(__nccwpck_require__(52802), exports);
tslib_1.__exportStar(__nccwpck_require__(24740), exports);
tslib_1.__exportStar(__nccwpck_require__(69678), exports);
tslib_1.__exportStar(__nccwpck_require__(41879), exports);
tslib_1.__exportStar(__nccwpck_require__(34649), exports);
tslib_1.__exportStar(__nccwpck_require__(2546), exports);
tslib_1.__exportStar(__nccwpck_require__(63191), exports);


/***/ }),

/***/ 41879:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadSharedConfigFiles = void 0;
const getConfigFilepath_1 = __nccwpck_require__(47237);
const getCredentialsFilepath_1 = __nccwpck_require__(99036);
const getProfileData_1 = __nccwpck_require__(32041);
const parseIni_1 = __nccwpck_require__(54262);
const slurpFile_1 = __nccwpck_require__(19155);
const swallowError = () => ({});
const loadSharedConfigFiles = async (init = {}) => {
    const { filepath = (0, getCredentialsFilepath_1.getCredentialsFilepath)(), configFilepath = (0, getConfigFilepath_1.getConfigFilepath)() } = init;
    const parsedFiles = await Promise.all([
        (0, slurpFile_1.slurpFile)(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_1.parseIni)
            .then(getProfileData_1.getProfileData)
            .catch(swallowError),
        (0, slurpFile_1.slurpFile)(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_1.parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};
exports.loadSharedConfigFiles = loadSharedConfigFiles;


/***/ }),

/***/ 34649:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadSsoSessionData = void 0;
const getConfigFilepath_1 = __nccwpck_require__(47237);
const getSsoSessionData_1 = __nccwpck_require__(82820);
const parseIni_1 = __nccwpck_require__(54262);
const slurpFile_1 = __nccwpck_require__(19155);
const swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => {
    var _a;
    return (0, slurpFile_1.slurpFile)((_a = init.configFilepath) !== null && _a !== void 0 ? _a : (0, getConfigFilepath_1.getConfigFilepath)())
        .then(parseIni_1.parseIni)
        .then(getSsoSessionData_1.getSsoSessionData)
        .catch(swallowError);
};
exports.loadSsoSessionData = loadSsoSessionData;


/***/ }),

/***/ 19447:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeConfigFiles = void 0;
const mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
            if (merged[key] !== undefined) {
                Object.assign(merged[key], values);
            }
            else {
                merged[key] = values;
            }
        }
    }
    return merged;
};
exports.mergeConfigFiles = mergeConfigFiles;


/***/ }),

/***/ 54262:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseIni = void 0;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni = (iniData) => {
    const map = {};
    let currentSection;
    for (let line of iniData.split(/\r?\n/)) {
        line = line.split(/(^|\s)[;#]/)[0].trim();
        const isSection = line[0] === "[" && line[line.length - 1] === "]";
        if (isSection) {
            currentSection = line.substring(1, line.length - 1);
            if (profileNameBlockList.includes(currentSection)) {
                throw new Error(`Found invalid profile name "${currentSection}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = line.indexOf("=");
            const start = 0;
            const end = line.length - 1;
            const isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
            if (isAssignment) {
                const [name, value] = [
                    line.substring(0, indexOfEqualsSign).trim(),
                    line.substring(indexOfEqualsSign + 1).trim(),
                ];
                map[currentSection] = map[currentSection] || {};
                map[currentSection][name] = value;
            }
        }
    }
    return map;
};
exports.parseIni = parseIni;


/***/ }),

/***/ 2546:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseKnownFiles = void 0;
const loadSharedConfigFiles_1 = __nccwpck_require__(41879);
const mergeConfigFiles_1 = __nccwpck_require__(19447);
const parseKnownFiles = async (init) => {
    const parsedFiles = await (0, loadSharedConfigFiles_1.loadSharedConfigFiles)(init);
    return (0, mergeConfigFiles_1.mergeConfigFiles)(parsedFiles.configFile, parsedFiles.credentialsFile);
};
exports.parseKnownFiles = parseKnownFiles;


/***/ }),

/***/ 19155:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.slurpFile = void 0;
const fs_1 = __nccwpck_require__(57147);
const { readFile } = fs_1.promises;
const filePromisesHash = {};
const slurpFile = (path, options) => {
    if (!filePromisesHash[path] || (options === null || options === void 0 ? void 0 : options.ignoreCache)) {
        filePromisesHash[path] = readFile(path, "utf8");
    }
    return filePromisesHash[path];
};
exports.slurpFile = slurpFile;


/***/ }),

/***/ 63191:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 39733:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureV4 = void 0;
const eventstream_codec_1 = __nccwpck_require__(56459);
const util_hex_encoding_1 = __nccwpck_require__(45364);
const util_middleware_1 = __nccwpck_require__(2390);
const util_utf8_1 = __nccwpck_require__(41895);
const constants_1 = __nccwpck_require__(48644);
const credentialDerivation_1 = __nccwpck_require__(19623);
const getCanonicalHeaders_1 = __nccwpck_require__(51393);
const getCanonicalQuery_1 = __nccwpck_require__(33243);
const getPayloadHash_1 = __nccwpck_require__(48545);
const headerUtil_1 = __nccwpck_require__(62179);
const moveHeadersToQuery_1 = __nccwpck_require__(49828);
const prepareRequest_1 = __nccwpck_require__(60075);
const utilDate_1 = __nccwpck_require__(39299);
class SignatureV4 {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
        this.headerMarshaller = new eventstream_codec_1.HeaderMarshaller(util_utf8_1.toUtf8, util_utf8_1.fromUtf8);
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = (0, util_middleware_1.normalizeProvider)(region);
        this.credentialProvider = (0, util_middleware_1.normalizeProvider)(credentials);
    }
    async presign(originalRequest, options = {}) {
        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > constants_1.MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
        }
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        const request = (0, moveHeadersToQuery_1.moveHeadersToQuery)((0, prepareRequest_1.prepareRequest)(originalRequest), { unhoistableHeaders });
        if (credentials.sessionToken) {
            request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;
        request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[constants_1.EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
        request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await (0, getPayloadHash_1.getPayloadHash)(originalRequest, this.sha256)));
        return request;
    }
    async sign(toSign, options) {
        if (typeof toSign === "string") {
            return this.signString(toSign, options);
        }
        else if (toSign.headers && toSign.payload) {
            return this.signEvent(toSign, options);
        }
        else if (toSign.message) {
            return this.signMessage(toSign, options);
        }
        else {
            return this.signRequest(toSign, options);
        }
    }
    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        const hashedPayload = await (0, getPayloadHash_1.getPayloadHash)({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = (0, util_hex_encoding_1.toHex)(await hash.digest());
        const stringToSign = [
            constants_1.EVENT_ALGORITHM_IDENTIFIER,
            longDate,
            scope,
            priorSignature,
            hashedHeaders,
            hashedPayload,
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
            headers: this.headerMarshaller.format(signableMessage.message.headers),
            payload: signableMessage.message.body,
        }, {
            signingDate,
            signingRegion,
            signingService,
            priorSignature: signableMessage.priorSignature,
        });
        return promise.then((signature) => {
            return { message: signableMessage.message, signature };
        });
    }
    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update((0, util_utf8_1.toUint8Array)(stringToSign));
        return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const request = (0, prepareRequest_1.prepareRequest)(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        request.headers[constants_1.AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await (0, getPayloadHash_1.getPayloadHash)(request, this.sha256);
        if (!(0, headerUtil_1.hasHeader)(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[constants_1.SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[constants_1.AUTH_HEADER] =
            `${constants_1.ALGORITHM_IDENTIFIER} ` +
                `Credential=${credentials.accessKeyId}/${scope}, ` +
                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +
                `Signature=${signature}`;
        return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${(0, getCanonicalQuery_1.getCanonicalQuery)(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update((0, util_utf8_1.toUint8Array)(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${constants_1.ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, util_hex_encoding_1.toHex)(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
            const normalizedPathSegments = [];
            for (const pathSegment of path.split("/")) {
                if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0)
                    continue;
                if (pathSegment === ".")
                    continue;
                if (pathSegment === "..") {
                    normalizedPathSegments.pop();
                }
                else {
                    normalizedPathSegments.push(pathSegment);
                }
            }
            const normalizedPath = `${(path === null || path === void 0 ? void 0 : path.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path === null || path === void 0 ? void 0 : path.endsWith("/")) ? "/" : ""}`;
            const doubleEncoded = encodeURIComponent(normalizedPath);
            return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update((0, util_utf8_1.toUint8Array)(stringToSign));
        return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
        return (0, credentialDerivation_1.getSigningKey)(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" ||
            typeof credentials.accessKeyId !== "string" ||
            typeof credentials.secretAccessKey !== "string") {
            throw new Error("Resolved credential object is not valid");
        }
    }
}
exports.SignatureV4 = SignatureV4;
const formatDate = (now) => {
    const longDate = (0, utilDate_1.iso8601)(now).replace(/[\-:]/g, "");
    return {
        longDate,
        shortDate: longDate.slice(0, 8),
    };
};
const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");


/***/ }),

/***/ 69098:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneQuery = exports.cloneRequest = void 0;
const cloneRequest = ({ headers, query, ...rest }) => ({
    ...rest,
    headers: { ...headers },
    query: query ? (0, exports.cloneQuery)(query) : undefined,
});
exports.cloneRequest = cloneRequest;
const cloneQuery = (query) => Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param,
    };
}, {});
exports.cloneQuery = cloneQuery;


/***/ }),

/***/ 48644:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MAX_PRESIGNED_TTL = exports.KEY_TYPE_IDENTIFIER = exports.MAX_CACHE_SIZE = exports.UNSIGNED_PAYLOAD = exports.EVENT_ALGORITHM_IDENTIFIER = exports.ALGORITHM_IDENTIFIER_V4A = exports.ALGORITHM_IDENTIFIER = exports.UNSIGNABLE_PATTERNS = exports.SEC_HEADER_PATTERN = exports.PROXY_HEADER_PATTERN = exports.ALWAYS_UNSIGNABLE_HEADERS = exports.HOST_HEADER = exports.TOKEN_HEADER = exports.SHA256_HEADER = exports.SIGNATURE_HEADER = exports.GENERATED_HEADERS = exports.DATE_HEADER = exports.AMZ_DATE_HEADER = exports.AUTH_HEADER = exports.REGION_SET_PARAM = exports.TOKEN_QUERY_PARAM = exports.SIGNATURE_QUERY_PARAM = exports.EXPIRES_QUERY_PARAM = exports.SIGNED_HEADERS_QUERY_PARAM = exports.AMZ_DATE_QUERY_PARAM = exports.CREDENTIAL_QUERY_PARAM = exports.ALGORITHM_QUERY_PARAM = void 0;
exports.ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
exports.CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
exports.AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
exports.SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
exports.EXPIRES_QUERY_PARAM = "X-Amz-Expires";
exports.SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
exports.TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
exports.REGION_SET_PARAM = "X-Amz-Region-Set";
exports.AUTH_HEADER = "authorization";
exports.AMZ_DATE_HEADER = exports.AMZ_DATE_QUERY_PARAM.toLowerCase();
exports.DATE_HEADER = "date";
exports.GENERATED_HEADERS = [exports.AUTH_HEADER, exports.AMZ_DATE_HEADER, exports.DATE_HEADER];
exports.SIGNATURE_HEADER = exports.SIGNATURE_QUERY_PARAM.toLowerCase();
exports.SHA256_HEADER = "x-amz-content-sha256";
exports.TOKEN_HEADER = exports.TOKEN_QUERY_PARAM.toLowerCase();
exports.HOST_HEADER = "host";
exports.ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true,
};
exports.PROXY_HEADER_PATTERN = /^proxy-/;
exports.SEC_HEADER_PATTERN = /^sec-/;
exports.UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
exports.ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
exports.ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
exports.EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
exports.UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
exports.MAX_CACHE_SIZE = 50;
exports.KEY_TYPE_IDENTIFIER = "aws4_request";
exports.MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;


/***/ }),

/***/ 19623:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearCredentialCache = exports.getSigningKey = exports.createScope = void 0;
const util_hex_encoding_1 = __nccwpck_require__(45364);
const util_utf8_1 = __nccwpck_require__(41895);
const constants_1 = __nccwpck_require__(48644);
const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;
exports.createScope = createScope;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${(0, util_hex_encoding_1.toHex)(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
    }
    return (signingKeyCache[cacheKey] = key);
};
exports.getSigningKey = getSigningKey;
const clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
        delete signingKeyCache[cacheKey];
    });
};
exports.clearCredentialCache = clearCredentialCache;
const hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update((0, util_utf8_1.toUint8Array)(data));
    return hash.digest();
};


/***/ }),

/***/ 51393:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCanonicalHeaders = void 0;
const constants_1 = __nccwpck_require__(48644);
const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == undefined) {
            continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in constants_1.ALWAYS_UNSIGNABLE_HEADERS ||
            (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) ||
            constants_1.PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
            constants_1.SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                continue;
            }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
};
exports.getCanonicalHeaders = getCanonicalHeaders;


/***/ }),

/***/ 33243:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCanonicalQuery = void 0;
const util_uri_escape_1 = __nccwpck_require__(54197);
const constants_1 = __nccwpck_require__(48644);
const getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query).sort()) {
        if (key.toLowerCase() === constants_1.SIGNATURE_HEADER) {
            continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
            serialized[key] = `${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`;
        }
        else if (Array.isArray(value)) {
            serialized[key] = value
                .slice(0)
                .sort()
                .reduce((encoded, value) => encoded.concat([`${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`]), [])
                .join("&");
        }
    }
    return keys
        .map((key) => serialized[key])
        .filter((serialized) => serialized)
        .join("&");
};
exports.getCanonicalQuery = getCanonicalQuery;


/***/ }),

/***/ 48545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPayloadHash = void 0;
const is_array_buffer_1 = __nccwpck_require__(10780);
const util_hex_encoding_1 = __nccwpck_require__(45364);
const util_utf8_1 = __nccwpck_require__(41895);
const constants_1 = __nccwpck_require__(48644);
const getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === constants_1.SHA256_HEADER) {
            return headers[headerName];
        }
    }
    if (body == undefined) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    }
    else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, is_array_buffer_1.isArrayBuffer)(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update((0, util_utf8_1.toUint8Array)(body));
        return (0, util_hex_encoding_1.toHex)(await hashCtor.digest());
    }
    return constants_1.UNSIGNED_PAYLOAD;
};
exports.getPayloadHash = getPayloadHash;


/***/ }),

/***/ 62179:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteHeader = exports.getHeaderValue = exports.hasHeader = void 0;
const hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return true;
        }
    }
    return false;
};
exports.hasHeader = hasHeader;
const getHeaderValue = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return headers[headerName];
        }
    }
    return undefined;
};
exports.getHeaderValue = getHeaderValue;
const deleteHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            delete headers[headerName];
        }
    }
};
exports.deleteHeader = deleteHeader;


/***/ }),

/***/ 11528:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareRequest = exports.moveHeadersToQuery = exports.getPayloadHash = exports.getCanonicalQuery = exports.getCanonicalHeaders = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(39733), exports);
var getCanonicalHeaders_1 = __nccwpck_require__(51393);
Object.defineProperty(exports, "getCanonicalHeaders", ({ enumerable: true, get: function () { return getCanonicalHeaders_1.getCanonicalHeaders; } }));
var getCanonicalQuery_1 = __nccwpck_require__(33243);
Object.defineProperty(exports, "getCanonicalQuery", ({ enumerable: true, get: function () { return getCanonicalQuery_1.getCanonicalQuery; } }));
var getPayloadHash_1 = __nccwpck_require__(48545);
Object.defineProperty(exports, "getPayloadHash", ({ enumerable: true, get: function () { return getPayloadHash_1.getPayloadHash; } }));
var moveHeadersToQuery_1 = __nccwpck_require__(49828);
Object.defineProperty(exports, "moveHeadersToQuery", ({ enumerable: true, get: function () { return moveHeadersToQuery_1.moveHeadersToQuery; } }));
var prepareRequest_1 = __nccwpck_require__(60075);
Object.defineProperty(exports, "prepareRequest", ({ enumerable: true, get: function () { return prepareRequest_1.prepareRequest; } }));
tslib_1.__exportStar(__nccwpck_require__(19623), exports);


/***/ }),

/***/ 49828:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moveHeadersToQuery = void 0;
const cloneRequest_1 = __nccwpck_require__(69098);
const moveHeadersToQuery = (request, options = {}) => {
    var _a;
    const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !((_a = options.unhoistableHeaders) === null || _a === void 0 ? void 0 : _a.has(lname))) {
            query[name] = headers[name];
            delete headers[name];
        }
    }
    return {
        ...request,
        headers,
        query,
    };
};
exports.moveHeadersToQuery = moveHeadersToQuery;


/***/ }),

/***/ 60075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareRequest = void 0;
const cloneRequest_1 = __nccwpck_require__(69098);
const constants_1 = __nccwpck_require__(48644);
const prepareRequest = (request) => {
    request = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const headerName of Object.keys(request.headers)) {
        if (constants_1.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
            delete request.headers[headerName];
        }
    }
    return request;
};
exports.prepareRequest = prepareRequest;


/***/ }),

/***/ 39299:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toDate = exports.iso8601 = void 0;
const iso8601 = (time) => (0, exports.toDate)(time)
    .toISOString()
    .replace(/\.\d{3}Z$/, "Z");
exports.iso8601 = iso8601;
const toDate = (time) => {
    if (typeof time === "number") {
        return new Date(time * 1000);
    }
    if (typeof time === "string") {
        if (Number(time)) {
            return new Date(Number(time) * 1000);
        }
        return new Date(time);
    }
    return time;
};
exports.toDate = toDate;


/***/ }),

/***/ 70438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoOpLogger = void 0;
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}
exports.NoOpLogger = NoOpLogger;


/***/ }),

/***/ 61600:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = void 0;
const middleware_stack_1 = __nccwpck_require__(97911);
class Client {
    constructor(config) {
        this.middlewareStack = (0, middleware_stack_1.constructStack)();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}
exports.Client = Client;


/***/ }),

/***/ 32813:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.collectBody = void 0;
const util_stream_1 = __nccwpck_require__(96607);
const collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return util_stream_1.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return util_stream_1.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return util_stream_1.Uint8ArrayBlobAdapter.mutate(await fromContext);
};
exports.collectBody = collectBody;


/***/ }),

/***/ 75414:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Command = void 0;
const middleware_stack_1 = __nccwpck_require__(97911);
class Command {
    constructor() {
        this.middlewareStack = (0, middleware_stack_1.constructStack)();
    }
}
exports.Command = Command;


/***/ }),

/***/ 92541:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SENSITIVE_STRING = void 0;
exports.SENSITIVE_STRING = "***SensitiveInformation***";


/***/ }),

/***/ 56929:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAggregatedClient = void 0;
const createAggregatedClient = (commands, Client) => {
    for (const command of Object.keys(commands)) {
        const CommandCtor = commands[command];
        const methodImpl = async function (args, optionsOrCb, cb) {
            const command = new CommandCtor(args);
            if (typeof optionsOrCb === "function") {
                this.send(command, optionsOrCb);
            }
            else if (typeof cb === "function") {
                if (typeof optionsOrCb !== "object")
                    throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                this.send(command, optionsOrCb || {}, cb);
            }
            else {
                return this.send(command, optionsOrCb);
            }
        };
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client.prototype[methodName] = methodImpl;
    }
};
exports.createAggregatedClient = createAggregatedClient;


/***/ }),

/***/ 21737:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEpochTimestamp = exports.parseRfc7231DateTime = exports.parseRfc3339DateTimeWithOffset = exports.parseRfc3339DateTime = exports.dateToUtcString = void 0;
const parse_utils_1 = __nccwpck_require__(74857);
const DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
exports.dateToUtcString = dateToUtcString;
const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
exports.parseRfc3339DateTime = parseRfc3339DateTime;
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
exports.parseRfc3339DateTimeWithOffset = parseRfc3339DateTimeWithOffset;
const IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
exports.parseRfc7231DateTime = parseRfc7231DateTime;
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = (0, parse_utils_1.strictParseDouble)(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
exports.parseEpochTimestamp = parseEpochTimestamp;
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = (0, parse_utils_1.strictParseByte)(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return (0, parse_utils_1.strictParseFloat32)("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};


/***/ }),

/***/ 9681:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withBaseException = exports.throwDefaultError = void 0;
const exceptions_1 = __nccwpck_require__(88074);
const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: (parsedBody === null || parsedBody === void 0 ? void 0 : parsedBody.code) || (parsedBody === null || parsedBody === void 0 ? void 0 : parsedBody.Code) || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw (0, exceptions_1.decorateServiceException)(response, parsedBody);
};
exports.throwDefaultError = throwDefaultError;
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        (0, exports.throwDefaultError)({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
exports.withBaseException = withBaseException;
const deserializeMetadata = (output) => {
    var _a, _b;
    return ({
        httpStatusCode: output.statusCode,
        requestId: (_b = (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"]) !== null && _b !== void 0 ? _b : output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
};


/***/ }),

/***/ 11163:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadConfigsForDefaultMode = void 0;
const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};
exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;


/***/ }),

/***/ 91809:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emitWarningIfUnsupportedVersion = void 0;
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 14) {
        warningEmitted = true;
    }
};
exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;


/***/ }),

/***/ 88074:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateServiceException = exports.ServiceException = void 0;
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
exports.ServiceException = ServiceException;
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};
exports.decorateServiceException = decorateServiceException;


/***/ }),

/***/ 76016:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendedEncodeURIComponent = void 0;
function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
exports.extendedEncodeURIComponent = extendedEncodeURIComponent;


/***/ }),

/***/ 42638:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getArrayIfSingleItem = void 0;
const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
exports.getArrayIfSingleItem = getArrayIfSingleItem;


/***/ }),

/***/ 92188:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValueFromTextNode = void 0;
const getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
            obj[key] = obj[key][textNodeName];
        }
        else if (typeof obj[key] === "object" && obj[key] !== null) {
            obj[key] = (0, exports.getValueFromTextNode)(obj[key]);
        }
    }
    return obj;
};
exports.getValueFromTextNode = getValueFromTextNode;


/***/ }),

/***/ 63570:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(70438), exports);
tslib_1.__exportStar(__nccwpck_require__(61600), exports);
tslib_1.__exportStar(__nccwpck_require__(32813), exports);
tslib_1.__exportStar(__nccwpck_require__(75414), exports);
tslib_1.__exportStar(__nccwpck_require__(92541), exports);
tslib_1.__exportStar(__nccwpck_require__(56929), exports);
tslib_1.__exportStar(__nccwpck_require__(21737), exports);
tslib_1.__exportStar(__nccwpck_require__(9681), exports);
tslib_1.__exportStar(__nccwpck_require__(11163), exports);
tslib_1.__exportStar(__nccwpck_require__(91809), exports);
tslib_1.__exportStar(__nccwpck_require__(88074), exports);
tslib_1.__exportStar(__nccwpck_require__(76016), exports);
tslib_1.__exportStar(__nccwpck_require__(42638), exports);
tslib_1.__exportStar(__nccwpck_require__(92188), exports);
tslib_1.__exportStar(__nccwpck_require__(32964), exports);
tslib_1.__exportStar(__nccwpck_require__(83495), exports);
tslib_1.__exportStar(__nccwpck_require__(74857), exports);
tslib_1.__exportStar(__nccwpck_require__(15342), exports);
tslib_1.__exportStar(__nccwpck_require__(53456), exports);
tslib_1.__exportStar(__nccwpck_require__(1752), exports);
tslib_1.__exportStar(__nccwpck_require__(92480), exports);


/***/ }),

/***/ 32964:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyJsonString = exports.StringWrapper = void 0;
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
exports.StringWrapper = StringWrapper;
exports.StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: exports.StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(exports.StringWrapper, String);
class LazyJsonString extends exports.StringWrapper {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}
exports.LazyJsonString = LazyJsonString;


/***/ }),

/***/ 83495:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.take = exports.convertMap = exports.map = void 0;
function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
exports.map = map;
const convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
        output[k] = [, v];
    }
    return output;
};
exports.convertMap = convertMap;
const take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
exports.take = take;
const mapWithFilter = (target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [, instruction];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        }
        else if (customFilterPassed) {
            target[targetKey] = value();
        }
    }
    else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_) => _ != null;
const pass = (_) => _;


/***/ }),

/***/ 74857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logger = exports.strictParseByte = exports.strictParseShort = exports.strictParseInt32 = exports.strictParseInt = exports.strictParseLong = exports.limitedParseFloat32 = exports.limitedParseFloat = exports.handleFloat = exports.limitedParseDouble = exports.strictParseFloat32 = exports.strictParseFloat = exports.strictParseDouble = exports.expectUnion = exports.expectString = exports.expectObject = exports.expectNonNull = exports.expectByte = exports.expectShort = exports.expectInt32 = exports.expectInt = exports.expectLong = exports.expectFloat32 = exports.expectNumber = exports.expectBoolean = exports.parseBoolean = void 0;
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
exports.parseBoolean = parseBoolean;
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
exports.expectBoolean = expectBoolean;
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                exports.logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
exports.expectNumber = expectNumber;
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = (0, exports.expectNumber)(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
exports.expectFloat32 = expectFloat32;
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
exports.expectLong = expectLong;
exports.expectInt = exports.expectLong;
const expectInt32 = (value) => expectSizedInt(value, 32);
exports.expectInt32 = expectInt32;
const expectShort = (value) => expectSizedInt(value, 16);
exports.expectShort = expectShort;
const expectByte = (value) => expectSizedInt(value, 8);
exports.expectByte = expectByte;
const expectSizedInt = (value, size) => {
    const expected = (0, exports.expectLong)(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
exports.expectNonNull = expectNonNull;
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
exports.expectObject = expectObject;
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        exports.logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
exports.expectString = expectString;
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = (0, exports.expectObject)(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
exports.expectUnion = expectUnion;
const strictParseDouble = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectNumber)(parseNumber(value));
    }
    return (0, exports.expectNumber)(value);
};
exports.strictParseDouble = strictParseDouble;
exports.strictParseFloat = exports.strictParseDouble;
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectFloat32)(parseNumber(value));
    }
    return (0, exports.expectFloat32)(value);
};
exports.strictParseFloat32 = strictParseFloat32;
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectNumber)(value);
};
exports.limitedParseDouble = limitedParseDouble;
exports.handleFloat = exports.limitedParseDouble;
exports.limitedParseFloat = exports.limitedParseDouble;
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectFloat32)(value);
};
exports.limitedParseFloat32 = limitedParseFloat32;
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectLong)(parseNumber(value));
    }
    return (0, exports.expectLong)(value);
};
exports.strictParseLong = strictParseLong;
exports.strictParseInt = exports.strictParseLong;
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectInt32)(parseNumber(value));
    }
    return (0, exports.expectInt32)(value);
};
exports.strictParseInt32 = strictParseInt32;
const strictParseShort = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectShort)(parseNumber(value));
    }
    return (0, exports.expectShort)(value);
};
exports.strictParseShort = strictParseShort;
const strictParseByte = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectByte)(parseNumber(value));
    }
    return (0, exports.expectByte)(value);
};
exports.strictParseByte = strictParseByte;
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
exports.logger = {
    warn: console.warn,
};


/***/ }),

/***/ 15342:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolvedPath = void 0;
const extended_encode_uri_component_1 = __nccwpck_require__(76016);
const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel
            ? labelValue
                .split("/")
                .map((segment) => (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(segment))
                .join("/")
            : (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath;
};
exports.resolvedPath = resolvedPath;


/***/ }),

/***/ 53456:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeFloat = void 0;
const serializeFloat = (value) => {
    if (value !== value) {
        return "NaN";
    }
    switch (value) {
        case Infinity:
            return "Infinity";
        case -Infinity:
            return "-Infinity";
        default:
            return value;
    }
};
exports.serializeFloat = serializeFloat;


/***/ }),

/***/ 1752:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._json = void 0;
const _json = (obj) => {
    if (obj == null) {
        return {};
    }
    if (Array.isArray(obj)) {
        return obj.filter((_) => _ != null);
    }
    if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
            if (obj[key] == null) {
                continue;
            }
            target[key] = (0, exports._json)(obj[key]);
        }
        return target;
    }
    return obj;
};
exports._json = _json;


/***/ }),

/***/ 92480:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitEvery = void 0;
function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
        throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
        return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i = 0; i < segments.length; i++) {
        if (currentSegment === "") {
            currentSegment = segments[i];
        }
        else {
            currentSegment += delimiter + segments[i];
        }
        if ((i + 1) % numDelimiters === 0) {
            compoundSegments.push(currentSegment);
            currentSegment = "";
        }
    }
    if (currentSegment !== "") {
        compoundSegments.push(currentSegment);
    }
    return compoundSegments;
}
exports.splitEvery = splitEvery;


/***/ }),

/***/ 74075:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 48960:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpAuthLocation = void 0;
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation = exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));


/***/ }),

/***/ 63274:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 78340:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 4744:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 68270:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 39580:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(39580), exports);
tslib_1.__exportStar(__nccwpck_require__(98398), exports);
tslib_1.__exportStar(__nccwpck_require__(76522), exports);


/***/ }),

/***/ 98398:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 76522:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 89035:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 7225:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 54126:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointURLScheme = void 0;
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme = exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));


/***/ }),

/***/ 55612:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 43084:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 89843:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 63799:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 21550:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(55612), exports);
tslib_1.__exportStar(__nccwpck_require__(43084), exports);
tslib_1.__exportStar(__nccwpck_require__(89843), exports);
tslib_1.__exportStar(__nccwpck_require__(57658), exports);
tslib_1.__exportStar(__nccwpck_require__(63799), exports);


/***/ }),

/***/ 57658:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 88508:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 18883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldPosition = void 0;
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition = exports.FieldPosition || (exports.FieldPosition = {}));


/***/ }),

/***/ 7545:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 49123:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 28006:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(7545), exports);
tslib_1.__exportStar(__nccwpck_require__(49123), exports);


/***/ }),

/***/ 55756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(74075), exports);
tslib_1.__exportStar(__nccwpck_require__(48960), exports);
tslib_1.__exportStar(__nccwpck_require__(63274), exports);
tslib_1.__exportStar(__nccwpck_require__(78340), exports);
tslib_1.__exportStar(__nccwpck_require__(4744), exports);
tslib_1.__exportStar(__nccwpck_require__(68270), exports);
tslib_1.__exportStar(__nccwpck_require__(57628), exports);
tslib_1.__exportStar(__nccwpck_require__(89035), exports);
tslib_1.__exportStar(__nccwpck_require__(7225), exports);
tslib_1.__exportStar(__nccwpck_require__(54126), exports);
tslib_1.__exportStar(__nccwpck_require__(21550), exports);
tslib_1.__exportStar(__nccwpck_require__(88508), exports);
tslib_1.__exportStar(__nccwpck_require__(18883), exports);
tslib_1.__exportStar(__nccwpck_require__(28006), exports);
tslib_1.__exportStar(__nccwpck_require__(52866), exports);
tslib_1.__exportStar(__nccwpck_require__(17756), exports);
tslib_1.__exportStar(__nccwpck_require__(45489), exports);
tslib_1.__exportStar(__nccwpck_require__(26524), exports);
tslib_1.__exportStar(__nccwpck_require__(14603), exports);
tslib_1.__exportStar(__nccwpck_require__(83752), exports);
tslib_1.__exportStar(__nccwpck_require__(30774), exports);
tslib_1.__exportStar(__nccwpck_require__(14089), exports);
tslib_1.__exportStar(__nccwpck_require__(45678), exports);
tslib_1.__exportStar(__nccwpck_require__(69926), exports);
tslib_1.__exportStar(__nccwpck_require__(9945), exports);
tslib_1.__exportStar(__nccwpck_require__(28564), exports);
tslib_1.__exportStar(__nccwpck_require__(61285), exports);
tslib_1.__exportStar(__nccwpck_require__(50364), exports);
tslib_1.__exportStar(__nccwpck_require__(69304), exports);
tslib_1.__exportStar(__nccwpck_require__(10375), exports);
tslib_1.__exportStar(__nccwpck_require__(66894), exports);
tslib_1.__exportStar(__nccwpck_require__(57887), exports);
tslib_1.__exportStar(__nccwpck_require__(66255), exports);


/***/ }),

/***/ 52866:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 17756:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 45489:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 26524:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 14603:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 83752:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 30774:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 14089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 45678:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 69926:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 9945:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 28564:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 61285:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 50364:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestHandlerProtocol = void 0;
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol = exports.RequestHandlerProtocol || (exports.RequestHandlerProtocol = {}));


/***/ }),

/***/ 69304:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 10375:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 66894:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57887:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 66255:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 14681:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseUrl = void 0;
const querystring_parser_1 = __nccwpck_require__(4769);
const parseUrl = (url) => {
    if (typeof url === "string") {
        return (0, exports.parseUrl)(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = (0, querystring_parser_1.parseQueryString)(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};
exports.parseUrl = parseUrl;


/***/ }),

/***/ 30305:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromBase64 = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};
exports.fromBase64 = fromBase64;


/***/ }),

/***/ 75600:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(30305), exports);
tslib_1.__exportStar(__nccwpck_require__(74730), exports);


/***/ }),

/***/ 74730:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBase64 = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const toBase64 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
exports.toBase64 = toBase64;


/***/ }),

/***/ 54880:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.calculateBodyLength = void 0;
const fs_1 = __nccwpck_require__(57147);
const calculateBodyLength = (body) => {
    if (!body) {
        return 0;
    }
    if (typeof body === "string") {
        return Buffer.from(body).length;
    }
    else if (typeof body.byteLength === "number") {
        return body.byteLength;
    }
    else if (typeof body.size === "number") {
        return body.size;
    }
    else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
        return (0, fs_1.lstatSync)(body.path).size;
    }
    else if (typeof body.fd === "number") {
        return (0, fs_1.fstatSync)(body.fd).size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
};
exports.calculateBodyLength = calculateBodyLength;


/***/ }),

/***/ 68075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(54880), exports);


/***/ }),

/***/ 31381:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromString = exports.fromArrayBuffer = void 0;
const is_array_buffer_1 = __nccwpck_require__(10780);
const buffer_1 = __nccwpck_require__(14300);
const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!(0, is_array_buffer_1.isArrayBuffer)(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return buffer_1.Buffer.from(input, offset, length);
};
exports.fromArrayBuffer = fromArrayBuffer;
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? buffer_1.Buffer.from(input, encoding) : buffer_1.Buffer.from(input);
};
exports.fromString = fromString;


/***/ }),

/***/ 42491:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.booleanSelector = exports.SelectorType = void 0;
var SelectorType;
(function (SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
})(SelectorType = exports.SelectorType || (exports.SelectorType = {}));
const booleanSelector = (obj, key, type) => {
    if (!(key in obj))
        return undefined;
    if (obj[key] === "true")
        return true;
    if (obj[key] === "false")
        return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};
exports.booleanSelector = booleanSelector;


/***/ }),

/***/ 83375:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(42491), exports);


/***/ }),

/***/ 56470:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IMDS_REGION_PATH = exports.DEFAULTS_MODE_OPTIONS = exports.ENV_IMDS_DISABLED = exports.AWS_DEFAULT_REGION_ENV = exports.AWS_REGION_ENV = exports.AWS_EXECUTION_ENV = void 0;
exports.AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
exports.AWS_REGION_ENV = "AWS_REGION";
exports.AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
exports.DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
exports.IMDS_REGION_PATH = "/latest/meta-data/placement/region";


/***/ }),

/***/ 15577:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = void 0;
const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy",
};


/***/ }),

/***/ 72429:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(46217), exports);


/***/ }),

/***/ 46217:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveDefaultsModeConfig = void 0;
const config_resolver_1 = __nccwpck_require__(53098);
const credential_provider_imds_1 = __nccwpck_require__(7477);
const node_config_provider_1 = __nccwpck_require__(33461);
const property_provider_1 = __nccwpck_require__(79721);
const constants_1 = __nccwpck_require__(56470);
const defaultsModeConfig_1 = __nccwpck_require__(15577);
const resolveDefaultsModeConfig = ({ region = (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS), defaultsMode = (0, node_config_provider_1.loadConfig)(defaultsModeConfig_1.NODE_DEFAULTS_MODE_CONFIG_OPTIONS), } = {}) => (0, property_provider_1.memoize)(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode === null || mode === void 0 ? void 0 : mode.toLowerCase()) {
        case "auto":
            return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
            return Promise.resolve(mode === null || mode === void 0 ? void 0 : mode.toLocaleLowerCase());
        case undefined:
            return Promise.resolve("legacy");
        default:
            throw new Error(`Invalid parameter for "defaultsMode", expect ${constants_1.DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
});
exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
const resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
            return "standard";
        }
        if (resolvedRegion === inferredRegion) {
            return "in-region";
        }
        else {
            return "cross-region";
        }
    }
    return "standard";
};
const inferPhysicalRegion = async () => {
    var _a;
    if (process.env[constants_1.AWS_EXECUTION_ENV] && (process.env[constants_1.AWS_REGION_ENV] || process.env[constants_1.AWS_DEFAULT_REGION_ENV])) {
        return (_a = process.env[constants_1.AWS_REGION_ENV]) !== null && _a !== void 0 ? _a : process.env[constants_1.AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[constants_1.ENV_IMDS_DISABLED]) {
        try {
            const endpoint = await (0, credential_provider_imds_1.getInstanceMetadataEndpoint)();
            return (await (0, credential_provider_imds_1.httpRequest)({ ...endpoint, path: constants_1.IMDS_REGION_PATH })).toString();
        }
        catch (e) {
        }
    }
};


/***/ }),

/***/ 45364:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toHex = exports.fromHex = void 0;
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
exports.fromHex = fromHex;
function toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}
exports.toHex = toHex;


/***/ }),

/***/ 2390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80149), exports);


/***/ }),

/***/ 80149:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeProvider = void 0;
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};
exports.normalizeProvider = normalizeProvider;


/***/ }),

/***/ 65053:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveRetryStrategy = void 0;
const config_1 = __nccwpck_require__(93435);
const DefaultRateLimiter_1 = __nccwpck_require__(22234);
const StandardRetryStrategy_1 = __nccwpck_require__(48361);
class AdaptiveRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = config_1.RETRY_MODES.ADAPTIVE;
        const { rateLimiter } = options !== null && options !== void 0 ? options : {};
        this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new DefaultRateLimiter_1.DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy_1.StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
    }
}
exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


/***/ }),

/***/ 25689:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfiguredRetryStrategy = void 0;
const constants_1 = __nccwpck_require__(66302);
const StandardRetryStrategy_1 = __nccwpck_require__(48361);
class ConfiguredRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttempts, computeNextBackoffDelay = constants_1.DEFAULT_RETRY_DELAY_BASE) {
        super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
        if (typeof computeNextBackoffDelay === "number") {
            this.computeNextBackoffDelay = () => computeNextBackoffDelay;
        }
        else {
            this.computeNextBackoffDelay = computeNextBackoffDelay;
        }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
        return token;
    }
}
exports.ConfiguredRetryStrategy = ConfiguredRetryStrategy;


/***/ }),

/***/ 22234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultRateLimiter = void 0;
const service_error_classification_1 = __nccwpck_require__(6375);
class DefaultRateLimiter {
    constructor(options) {
        var _a, _b, _c, _d, _e;
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;
        this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;
        this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;
        this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;
        this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
        return Date.now() / 1000;
    }
    async getSendToken() {
        return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
        if (!this.enabled) {
            return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
            await new Promise((resolve) => setTimeout(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if ((0, service_error_classification_1.isThrottlingError)(response)) {
            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
            this.lastMaxRate = rateToUse;
            this.calculateTimeWindow();
            this.lastThrottleTime = this.getCurrentTimeInSeconds();
            calculatedRate = this.cubicThrottle(rateToUse);
            this.enableTokenBucket();
        }
        else {
            this.calculateTimeWindow();
            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
        this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
        const t = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
            this.requestCount = 0;
            this.lastTxRateBucket = timeBucket;
        }
    }
    getPrecise(num) {
        return parseFloat(num.toFixed(8));
    }
}
exports.DefaultRateLimiter = DefaultRateLimiter;


/***/ }),

/***/ 48361:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardRetryStrategy = void 0;
const config_1 = __nccwpck_require__(93435);
const constants_1 = __nccwpck_require__(66302);
const defaultRetryBackoffStrategy_1 = __nccwpck_require__(21337);
const defaultRetryToken_1 = __nccwpck_require__(1127);
class StandardRetryStrategy {
    constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.mode = config_1.RETRY_MODES.STANDARD;
        this.capacity = constants_1.INITIAL_RETRY_TOKENS;
        this.retryBackoffStrategy = (0, defaultRetryBackoffStrategy_1.getDefaultRetryBackoffStrategy)();
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
        return (0, defaultRetryToken_1.createDefaultRetryToken)({
            retryDelay: constants_1.DEFAULT_RETRY_DELAY_BASE,
            retryCount: 0,
        });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
            const errorType = errorInfo.errorType;
            this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? constants_1.THROTTLING_RETRY_DELAY_BASE : constants_1.DEFAULT_RETRY_DELAY_BASE);
            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
            const retryDelay = errorInfo.retryAfterHint
                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                : delayFromErrorType;
            const capacityCost = this.getCapacityCost(errorType);
            this.capacity -= capacityCost;
            return (0, defaultRetryToken_1.createDefaultRetryToken)({
                retryDelay,
                retryCount: token.getRetryCount() + 1,
                retryCost: capacityCost,
            });
        }
        throw new Error("No retry token available");
    }
    recordSuccess(token) {
        var _a;
        this.capacity = Math.max(constants_1.INITIAL_RETRY_TOKENS, this.capacity + ((_a = token.getRetryCost()) !== null && _a !== void 0 ? _a : constants_1.NO_RETRY_INCREMENT));
    }
    getCapacity() {
        return this.capacity;
    }
    async getMaxAttempts() {
        try {
            return await this.maxAttemptsProvider();
        }
        catch (error) {
            console.warn(`Max attempts provider could not resolve. Using default of ${config_1.DEFAULT_MAX_ATTEMPTS}`);
            return config_1.DEFAULT_MAX_ATTEMPTS;
        }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return (attempts < maxAttempts &&
            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
            this.isRetryableError(errorInfo.errorType));
    }
    getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? constants_1.TIMEOUT_RETRY_COST : constants_1.RETRY_COST;
    }
    isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
}
exports.StandardRetryStrategy = StandardRetryStrategy;


/***/ }),

/***/ 93435:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_RETRY_MODE = exports.DEFAULT_MAX_ATTEMPTS = exports.RETRY_MODES = void 0;
var RETRY_MODES;
(function (RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
})(RETRY_MODES = exports.RETRY_MODES || (exports.RETRY_MODES = {}));
exports.DEFAULT_MAX_ATTEMPTS = 3;
exports.DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;


/***/ }),

/***/ 66302:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.REQUEST_HEADER = exports.INVOCATION_ID_HEADER = exports.NO_RETRY_INCREMENT = exports.TIMEOUT_RETRY_COST = exports.RETRY_COST = exports.INITIAL_RETRY_TOKENS = exports.THROTTLING_RETRY_DELAY_BASE = exports.MAXIMUM_RETRY_DELAY = exports.DEFAULT_RETRY_DELAY_BASE = void 0;
exports.DEFAULT_RETRY_DELAY_BASE = 100;
exports.MAXIMUM_RETRY_DELAY = 20 * 1000;
exports.THROTTLING_RETRY_DELAY_BASE = 500;
exports.INITIAL_RETRY_TOKENS = 500;
exports.RETRY_COST = 5;
exports.TIMEOUT_RETRY_COST = 10;
exports.NO_RETRY_INCREMENT = 1;
exports.INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
exports.REQUEST_HEADER = "amz-sdk-request";


/***/ }),

/***/ 21337:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRetryBackoffStrategy = void 0;
const constants_1 = __nccwpck_require__(66302);
const getDefaultRetryBackoffStrategy = () => {
    let delayBase = constants_1.DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(constants_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay) => {
        delayBase = delay;
    };
    return {
        computeNextBackoffDelay,
        setDelayBase,
    };
};
exports.getDefaultRetryBackoffStrategy = getDefaultRetryBackoffStrategy;


/***/ }),

/***/ 1127:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDefaultRetryToken = void 0;
const constants_1 = __nccwpck_require__(66302);
const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost, }) => {
    const getRetryCount = () => retryCount;
    const getRetryDelay = () => Math.min(constants_1.MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = () => retryCost;
    return {
        getRetryCount,
        getRetryDelay,
        getRetryCost,
    };
};
exports.createDefaultRetryToken = createDefaultRetryToken;


/***/ }),

/***/ 84902:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(65053), exports);
tslib_1.__exportStar(__nccwpck_require__(25689), exports);
tslib_1.__exportStar(__nccwpck_require__(22234), exports);
tslib_1.__exportStar(__nccwpck_require__(48361), exports);
tslib_1.__exportStar(__nccwpck_require__(93435), exports);
tslib_1.__exportStar(__nccwpck_require__(66302), exports);
tslib_1.__exportStar(__nccwpck_require__(75427), exports);


/***/ }),

/***/ 75427:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 22094:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uint8ArrayBlobAdapter = void 0;
const transforms_1 = __nccwpck_require__(82098);
class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return (0, transforms_1.transformFromString)(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return (0, transforms_1.transformToString)(this, encoding);
    }
}
exports.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter;


/***/ }),

/***/ 82098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transformFromString = exports.transformToString = void 0;
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const Uint8ArrayBlobAdapter_1 = __nccwpck_require__(22094);
function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return (0, util_base64_1.toBase64)(payload);
    }
    return (0, util_utf8_1.toUtf8)(payload);
}
exports.transformToString = transformToString;
function transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter_1.Uint8ArrayBlobAdapter.mutate((0, util_base64_1.fromBase64)(str));
    }
    return Uint8ArrayBlobAdapter_1.Uint8ArrayBlobAdapter.mutate((0, util_utf8_1.fromUtf8)(str));
}
exports.transformFromString = transformFromString;


/***/ }),

/***/ 23636:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAwsChunkedEncodingStream = void 0;
const stream_1 = __nccwpck_require__(12781);
const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new stream_1.Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};
exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;


/***/ }),

/***/ 96607:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(22094), exports);
tslib_1.__exportStar(__nccwpck_require__(23636), exports);
tslib_1.__exportStar(__nccwpck_require__(4515), exports);


/***/ }),

/***/ 4515:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sdkStreamMixin = void 0;
const node_http_handler_1 = __nccwpck_require__(20258);
const util_buffer_from_1 = __nccwpck_require__(31381);
const stream_1 = __nccwpck_require__(12781);
const util_1 = __nccwpck_require__(73837);
const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    var _a, _b;
    if (!(stream instanceof stream_1.Readable)) {
        const name = ((_b = (_a = stream === null || stream === void 0 ? void 0 : stream.__proto__) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) || stream;
        throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, node_http_handler_1.streamCollector)(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new util_1.TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof stream_1.Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return stream_1.Readable.toWeb(stream);
        },
    });
};
exports.sdkStreamMixin = sdkStreamMixin;


/***/ }),

/***/ 26174:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUriPath = void 0;
const escape_uri_1 = __nccwpck_require__(60010);
const escapeUriPath = (uri) => uri.split("/").map(escape_uri_1.escapeUri).join("/");
exports.escapeUriPath = escapeUriPath;


/***/ }),

/***/ 60010:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUri = void 0;
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
exports.escapeUri = escapeUri;
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;


/***/ }),

/***/ 54197:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(60010), exports);
tslib_1.__exportStar(__nccwpck_require__(26174), exports);


/***/ }),

/***/ 45917:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromUtf8 = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const fromUtf8 = (input) => {
    const buf = (0, util_buffer_from_1.fromString)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};
exports.fromUtf8 = fromUtf8;


/***/ }),

/***/ 41895:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(45917), exports);
tslib_1.__exportStar(__nccwpck_require__(95470), exports);
tslib_1.__exportStar(__nccwpck_require__(99960), exports);


/***/ }),

/***/ 95470:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUint8Array = void 0;
const fromUtf8_1 = __nccwpck_require__(45917);
const toUint8Array = (data) => {
    if (typeof data === "string") {
        return (0, fromUtf8_1.fromUtf8)(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};
exports.toUint8Array = toUint8Array;


/***/ }),

/***/ 99960:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const toUtf8 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 76991:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createWaiter = void 0;
const poller_1 = __nccwpck_require__(39033);
const utils_1 = __nccwpck_require__(26000);
const waiter_1 = __nccwpck_require__(79089);
const abortTimeout = async (abortSignal) => {
    return new Promise((resolve) => {
        abortSignal.onabort = () => resolve({ state: waiter_1.WaiterState.ABORTED });
    });
};
const createWaiter = async (options, input, acceptorChecks) => {
    const params = {
        ...waiter_1.waiterServiceDefaults,
        ...options,
    };
    (0, utils_1.validateWaiterOptions)(params);
    const exitConditions = [(0, poller_1.runPolling)(params, input, acceptorChecks)];
    if (options.abortController) {
        exitConditions.push(abortTimeout(options.abortController.signal));
    }
    if (options.abortSignal) {
        exitConditions.push(abortTimeout(options.abortSignal));
    }
    return Promise.race(exitConditions);
};
exports.createWaiter = createWaiter;


/***/ }),

/***/ 78011:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(76991), exports);
tslib_1.__exportStar(__nccwpck_require__(79089), exports);


/***/ }),

/***/ 39033:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runPolling = void 0;
const sleep_1 = __nccwpck_require__(62380);
const waiter_1 = __nccwpck_require__(79089);
const exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
    if (attempt > attemptCeiling)
        return maxDelay;
    const delay = minDelay * 2 ** (attempt - 1);
    return randomInRange(minDelay, delay);
};
const randomInRange = (min, max) => min + Math.random() * (max - min);
const runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {
    var _a;
    const { state, reason } = await acceptorChecks(client, input);
    if (state !== waiter_1.WaiterState.RETRY) {
        return { state, reason };
    }
    let currentAttempt = 1;
    const waitUntil = Date.now() + maxWaitTime * 1000;
    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
    while (true) {
        if (((_a = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _a === void 0 ? void 0 : _a.aborted) || (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) {
            return { state: waiter_1.WaiterState.ABORTED };
        }
        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
        if (Date.now() + delay * 1000 > waitUntil) {
            return { state: waiter_1.WaiterState.TIMEOUT };
        }
        await (0, sleep_1.sleep)(delay);
        const { state, reason } = await acceptorChecks(client, input);
        if (state !== waiter_1.WaiterState.RETRY) {
            return { state, reason };
        }
        currentAttempt += 1;
    }
};
exports.runPolling = runPolling;


/***/ }),

/***/ 26000:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(62380), exports);
tslib_1.__exportStar(__nccwpck_require__(6594), exports);


/***/ }),

/***/ 62380:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sleep = void 0;
const sleep = (seconds) => {
    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
};
exports.sleep = sleep;


/***/ }),

/***/ 6594:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateWaiterOptions = void 0;
const validateWaiterOptions = (options) => {
    if (options.maxWaitTime < 1) {
        throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
    }
    else if (options.minDelay < 1) {
        throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
    }
    else if (options.maxDelay < 1) {
        throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
    }
    else if (options.maxWaitTime <= options.minDelay) {
        throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
    else if (options.maxDelay < options.minDelay) {
        throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
};
exports.validateWaiterOptions = validateWaiterOptions;


/***/ }),

/***/ 79089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkExceptions = exports.WaiterState = exports.waiterServiceDefaults = void 0;
exports.waiterServiceDefaults = {
    minDelay: 2,
    maxDelay: 120,
};
var WaiterState;
(function (WaiterState) {
    WaiterState["ABORTED"] = "ABORTED";
    WaiterState["FAILURE"] = "FAILURE";
    WaiterState["SUCCESS"] = "SUCCESS";
    WaiterState["RETRY"] = "RETRY";
    WaiterState["TIMEOUT"] = "TIMEOUT";
})(WaiterState = exports.WaiterState || (exports.WaiterState = {}));
const checkExceptions = (result) => {
    if (result.state === WaiterState.ABORTED) {
        const abortError = new Error(`${JSON.stringify({
            ...result,
            reason: "Request was aborted",
        })}`);
        abortError.name = "AbortError";
        throw abortError;
    }
    else if (result.state === WaiterState.TIMEOUT) {
        const timeoutError = new Error(`${JSON.stringify({
            ...result,
            reason: "Waiter has timed out",
        })}`);
        timeoutError.name = "TimeoutError";
        throw timeoutError;
    }
    else if (result.state !== WaiterState.SUCCESS) {
        throw new Error(`${JSON.stringify({ result })}`);
    }
    return result;
};
exports.checkExceptions = checkExceptions;


/***/ }),

/***/ 14812:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports =
{
  parallel      : __nccwpck_require__(8210),
  serial        : __nccwpck_require__(50445),
  serialOrdered : __nccwpck_require__(3578)
};


/***/ }),

/***/ 1700:
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ 72794:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var defer = __nccwpck_require__(15295);

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ 15295:
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ 9023:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var async = __nccwpck_require__(72794)
  , abort = __nccwpck_require__(1700)
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ 42474:
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ 37942:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var abort = __nccwpck_require__(1700)
  , async = __nccwpck_require__(72794)
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ 8210:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var iterate    = __nccwpck_require__(9023)
  , initState  = __nccwpck_require__(42474)
  , terminator = __nccwpck_require__(37942)
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ 50445:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var serialOrdered = __nccwpck_require__(3578);

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ 3578:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var iterate    = __nccwpck_require__(9023)
  , initState  = __nccwpck_require__(42474)
  , terminator = __nccwpck_require__(37942)
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ 91403:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var CombinedStream = __nccwpck_require__(85443);
var util = __nccwpck_require__(73837);
var path = __nccwpck_require__(71017);
var http = __nccwpck_require__(13685);
var https = __nccwpck_require__(95687);
var parseUrl = (__nccwpck_require__(57310).parse);
var fs = __nccwpck_require__(57147);
var Stream = (__nccwpck_require__(12781).Stream);
var mime = __nccwpck_require__(43583);
var asynckit = __nccwpck_require__(14812);
var populate = __nccwpck_require__(47027);

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity > read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};


/***/ }),

/***/ 47027:
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ 85443:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var util = __nccwpck_require__(73837);
var Stream = (__nccwpck_require__(12781).Stream);
var DelayedStream = __nccwpck_require__(18611);

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ 28222:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __nccwpck_require__(46243)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 46243:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __nccwpck_require__(80900);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 38237:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __nccwpck_require__(28222);
} else {
	module.exports = __nccwpck_require__(35332);
}


/***/ }),

/***/ 35332:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

const tty = __nccwpck_require__(76224);
const util = __nccwpck_require__(73837);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __nccwpck_require__(59318);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __nccwpck_require__(46243)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 18611:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Stream = (__nccwpck_require__(12781).Stream);
var util = __nccwpck_require__(73837);

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ 12437:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = __nccwpck_require__(57147)
const path = __nccwpck_require__(71017)
const os = __nccwpck_require__(22037)
const crypto = __nccwpck_require__(6113)
const packageJson = __nccwpck_require__(49968)

const version = packageJson.version

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

// Parse src into an Object
function parse (src) {
  const obj = {}

  // Convert buffer to string
  let lines = src.toString()

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n')

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]

    // Default undefined or null to empty string
    let value = (match[2] || '')

    // Remove whitespace
    value = value.trim()

    // Check if double quoted
    const maybeQuote = value[0]

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n')
      value = value.replace(/\\r/g, '\r')
    }

    // Add to object
    obj[key] = value
  }

  return obj
}

function _parseVault (options) {
  const vaultPath = _vaultPath(options)

  // Parse .env.vault
  const result = DotenvModule.configDotenv({ path: vaultPath })
  if (!result.parsed) {
    throw new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenv.org/vault/.env.vault?environment=prod"
  const keys = _dotenvKey(options).split(',')
  const length = keys.length

  let decrypted
  for (let i = 0; i < length; i++) {
    try {
      // Get full key
      const key = keys[i].trim()

      // Get instructions for decrypt
      const attrs = _instructions(result, key)

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)

      break
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted)
}

function _log (message) {
  console.log(`[dotenv@${version}][INFO] ${message}`)
}

function _warn (message) {
  console.log(`[dotenv@${version}][WARN] ${message}`)
}

function _debug (message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`)
}

function _dotenvKey (options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY
  }

  // fallback to empty string
  return ''
}

function _instructions (result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      throw new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development')
    }

    throw error
  }

  // Get decrypt key
  const key = uri.password
  if (!key) {
    throw new Error('INVALID_DOTENV_KEY: Missing key part')
  }

  // Get environment
  const environment = uri.searchParams.get('environment')
  if (!environment) {
    throw new Error('INVALID_DOTENV_KEY: Missing environment part')
  }

  // Get ciphertext payload
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`
  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)
  }

  return { ciphertext, key }
}

function _vaultPath (options) {
  let dotenvPath = path.resolve(process.cwd(), '.env')

  if (options && options.path && options.path.length > 0) {
    dotenvPath = options.path
  }

  // Locate .env.vault
  return dotenvPath.endsWith('.vault') ? dotenvPath : `${dotenvPath}.vault`
}

function _resolveHome (envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
}

function _configVault (options) {
  _log('Loading env from encrypted .env.vault')

  const parsed = DotenvModule._parseVault(options)

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsed, options)

  return { parsed }
}

function configDotenv (options) {
  let dotenvPath = path.resolve(process.cwd(), '.env')
  let encoding = 'utf8'
  const debug = Boolean(options && options.debug)

  if (options) {
    if (options.path != null) {
      dotenvPath = _resolveHome(options.path)
    }
    if (options.encoding != null) {
      encoding = options.encoding
    }
  }

  try {
    // Specifying an encoding returns a string instead of a buffer
    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))

    let processEnv = process.env
    if (options && options.processEnv != null) {
      processEnv = options.processEnv
    }

    DotenvModule.populate(processEnv, parsed, options)

    return { parsed }
  } catch (e) {
    if (debug) {
      _debug(`Failed to load ${dotenvPath} ${e.message}`)
    }

    return { error: e }
  }
}

// Populates process.env from .env file
function config (options) {
  const vaultPath = _vaultPath(options)

  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options)
  }

  // dotenvKey exists but .env.vault file does not exist
  if (!fs.existsSync(vaultPath)) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)

    return DotenvModule.configDotenv(options)
  }

  return DotenvModule._configVault(options)
}

function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex')
  let ciphertext = Buffer.from(encrypted, 'base64')

  const nonce = ciphertext.slice(0, 12)
  const authTag = ciphertext.slice(-16)
  ciphertext = ciphertext.slice(12, -16)

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)
    aesgcm.setAuthTag(authTag)
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const isRange = error instanceof RangeError
    const invalidKeyLength = error.message === 'Invalid key length'
    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'

    if (isRange || invalidKeyLength) {
      const msg = 'INVALID_DOTENV_KEY: It must be 64 characters long (or more)'
      throw new Error(msg)
    } else if (decryptionFailed) {
      const msg = 'DECRYPTION_FAILED: Please check your DOTENV_KEY'
      throw new Error(msg)
    } else {
      console.error('Error: ', error.code)
      console.error('Error: ', error.message)
      throw error
    }
  }
}

// Populate process.env with parsed values
function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options && options.debug)
  const override = Boolean(options && options.override)

  if (typeof parsed !== 'object') {
    throw new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')
  }

  // Set process.env
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key]
      }

      if (debug) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`)
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`)
        }
      }
    } else {
      processEnv[key] = parsed[key]
    }
  }
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
}

module.exports.configDotenv = DotenvModule.configDotenv
module.exports._configVault = DotenvModule._configVault
module.exports._parseVault = DotenvModule._parseVault
module.exports.config = DotenvModule.config
module.exports.decrypt = DotenvModule.decrypt
module.exports.parse = DotenvModule.parse
module.exports.populate = DotenvModule.populate

module.exports = DotenvModule


/***/ }),

/***/ 12603:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const validator = __nccwpck_require__(61739);
const XMLParser = __nccwpck_require__(42380);
const XMLBuilder = __nccwpck_require__(80660);

module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
}

/***/ }),

/***/ 38280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ 61739:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(38280);

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1){
            //don't push into stack
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else{
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ 80660:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __nccwpck_require__(72462);

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      }
    }
    return this.j2x(jObj, 0).val;
  }
};

Builder.prototype.j2x = function(jObj, level) {
  let attrStr = '';
  let val = '';
  for (let key in jObj) {
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node
    } else if (jObj[key] === null) {
      if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      }else {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      let listTagVal = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          if(this.options.oneListGroup ){
            listTagVal += this.j2x(item, level + 1).val;
          }else{
            listTagVal += this.processTextOrObjNode(item, key, level)
          }
        } else {
          listTagVal += this.buildTextValNode(item, key, '', level);
        }
      }
      if(this.options.oneListGroup){
        listTagVal = this.buildObjectNode(listTagVal, key, '', level);
      }
      val += listTagVal;
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

Builder.prototype.buildAttrPairStr = function(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
}

function processTextOrObjNode (object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}

Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
  if(val === ""){
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  }else{

    let tagEndExp = '</' + key + this.tagEndChar;
    let piClosingChar = "";
    
    if(key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
  
    if (attrStr && val.indexOf('<') === -1) {
      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    }else {
      return (
        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
        val +
        this.indentate(level) + tagEndExp    );
    }
  }
}

Builder.prototype.closeTag = function(key){
  let closeTag = "";
  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(!this.options.suppressUnpairedNode) closeTag = "/"
  }else if(this.options.suppressEmptyNode){ //empty
    closeTag = "/";
  }else{
    closeTag = `></${key}`
  }
  return closeTag;
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
      // return this.buildTagStr(level,key, attrStr);
    }
  }
}

Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else if(key[0] === "?") {//PI tag
    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
  }else{
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === ''){
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }else{
      return this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar;
    }
  }
}

Builder.prototype.replaceEntitiesValue = function(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix)) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

module.exports = Builder;


/***/ }),

/***/ 72462:
/***/ ((module) => {

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
}

function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName
        else newJPath = `${jPath}.${tagName}`;

        if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
                tagText = options.tagValueProcessor(tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
        } else if (tagName[0] === "?") {
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            isPreviousElementTag = true;
            continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
            newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
                xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
                xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
    }

    return xmlStr;
}

function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@") return key;
    }
}

function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
}
module.exports = toXml;


/***/ }),

/***/ 6072:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const util = __nccwpck_require__(38280);

//TODO: handle comments
function readDocType(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<' && !comment) { //Determine the tag type
                if( hasBody && isEntity(xmlData, i)){
                    i += 7; 
                    [entityName, val,i] = readEntityExp(xmlData,i+1);
                    if(val.indexOf("&") === -1) //Parameter entities are not supported
                        entities[ validateEntityName(entityName) ] = {
                            regx : RegExp( `&${entityName};`,"g"),
                            val: val
                        };
                }
                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
                else if( isComment)                         comment = true;
                else                                        throw new Error("Invalid DOCTYPE");

                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') { //Read tag content
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                        angleBracketsCount--;
                    }
                }else{
                    angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else{
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else{
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

function readEntityExp(xmlData,i){
    //External entities are not supported
    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

    //Parameter entities are not supported
    //    <!ENTITY entityname "&anotherElement;">

    //Internal entities are supported
    //    <!ENTITY entityname "replacement text">
    
    //read EntityName
    let entityName = "";
    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
        // if(xmlData[i] === " ") continue;
        // else 
        entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

    //read Entity Value
    const startChar = xmlData[i++];
    let val = ""
    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
        val += xmlData[i];
    }
    return [entityName, val, i];
}

function isComment(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === '-' &&
    xmlData[i+3] === '-') return true
    return false
}
function isEntity(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'N' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'I' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'Y') return true
    return false
}
function isElement(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'L' &&
    xmlData[i+4] === 'E' &&
    xmlData[i+5] === 'M' &&
    xmlData[i+6] === 'E' &&
    xmlData[i+7] === 'N' &&
    xmlData[i+8] === 'T') return true
    return false
}

function isAttlist(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'A' &&
    xmlData[i+3] === 'T' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'L' &&
    xmlData[i+6] === 'I' &&
    xmlData[i+7] === 'S' &&
    xmlData[i+8] === 'T') return true
    return false
}
function isNotation(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'N' &&
    xmlData[i+3] === 'O' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'A' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'I' &&
    xmlData[i+8] === 'O' &&
    xmlData[i+9] === 'N') return true
    return false
}

function validateEntityName(name){
    if (util.isName(name))
	return name;
    else
        throw new Error(`Invalid entity name ${name}`);
}

module.exports = readDocType;


/***/ }),

/***/ 86993:
/***/ ((__unused_webpack_module, exports) => {


const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs){
      return tagName
    },
    // skipEmptyListItem: false
};
   
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};

exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

/***/ }),

/***/ 25832:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

///@ts-check

const util = __nccwpck_require__(38280);
const xmlNode = __nccwpck_require__(7462);
const readDocType = __nccwpck_require__(6072);
const toNumber = __nccwpck_require__(14526);

const regx =
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
  .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "" },
      "pound" : { regex: /&(pound|#163);/g, val: "" },
      "yen" : { regex: /&(yen|#165);/g, val: "" },
      "euro" : { regex: /&(euro|#8364);/g, val: "" },
      "copyright" : { regex: /&(copy|#169);/g, val: "" },
      "reg" : { regex: /&(reg|#174);/g, val: "" },
      "inr" : { regex: /&(inr|#8377);/g, val: "" },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
  }

}

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    }
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else{
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else{
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath, tagName) {
  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if(aName === "__proto__") aName  = "#__proto__";
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else{
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        //check if last tag of nested tag was unpaired tag
        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0
        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)
          this.tagsNodeStack.pop();
        }else{
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);

        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags){

        }else{
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath)

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.")
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + "." + this.options.cdataPropName, true, false, true);
          // if(!val) val = "";
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else{
          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
          if(val == undefined) val = "";
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
        let tagName= result.tagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            i = result.closeIndex;
          }
          //unpaired tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            i = result.closeIndex;
          }
          //normal tag
          else{
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${tagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          this.addChild(currentNode, childNode, jPath)
        }else{
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          }
    //opening tag
          else{
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
}

function addChild(currentNode, childNode, jPath){
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"])
  if(result === false){
  }else if(typeof result === "string"){
    childNode.tagname = result
    currentNode.addChild(childNode);
  }else{
    currentNode.addChild(childNode);
  }
}

const replaceEntitiesValue = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else{
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
    tagExp = tagExp.substr(separatorIndex + 1);
  }

  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>')

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


module.exports = OrderedObjParser;


/***/ }),

/***/ 42380:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { buildOptions} = __nccwpck_require__(86993);
const OrderedObjParser = __nccwpck_require__(25832);
const { prettify} = __nccwpck_require__(42882);
const validator = __nccwpck_require__(61739);

class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string"){
        }else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else{
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else{
            this.externalEntities[key] = value;
        }
    }
}

module.exports = XMLParser;

/***/ }),

/***/ 42882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else{
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else{
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  
  if (propCount === 0) {
    return true;
  }

  if (
    propCount === 1 &&
    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
  ) {
    return true;
  }

  return false;
}
exports.prettify = prettify;


/***/ }),

/***/ 7462:
/***/ ((module) => {

"use strict";


class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    if(key === "__proto__") key = "#__proto__";
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node.tagname === "__proto__") node.tagname = "#__proto__";
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else{
      this.child.push( { [node.tagname]: node.child });
    }
  };
};


module.exports = XmlNode;

/***/ }),

/***/ 31133:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __nccwpck_require__(38237)("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),

/***/ 67707:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var url = __nccwpck_require__(57310);
var URL = url.URL;
var http = __nccwpck_require__(13685);
var https = __nccwpck_require__(95687);
var Writable = (__nccwpck_require__(12781).Writable);
var assert = __nccwpck_require__(39491);
var debug = __nccwpck_require__(31133);

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL());
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC72305.3.1: When making a request directly to an origin server, []
  // a client MUST send only the absolute path [] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      /* istanbul ignore else */
      if (request === self._currentRequest) {
        // Report any write errors
        /* istanbul ignore if */
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          /* istanbul ignore else */
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC72316.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC72316.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC72316.4: Automatic redirection needs to done with
  // care for methods not known to be safe, []
  // RFC72316.4.23: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop() { /* empty */ }

function parseUrl(input) {
  var parsed;
  /* istanbul ignore else */
  if (useNativeURL) {
    parsed = new URL(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  /* istanbul ignore next */
  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    Error.captureStackTrace(this, this.constructor);
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL && value instanceof URL;
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),

/***/ 31621:
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 47426:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __nccwpck_require__(53765)


/***/ }),

/***/ 43583:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __nccwpck_require__(47426)
var extname = (__nccwpck_require__(71017).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ 80900:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 63329:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var parseUrl = (__nccwpck_require__(57310).parse);

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }

  var proxy =
    getEnv('npm_config_' + proto + '_proxy') ||
    getEnv(proto + '_proxy') ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    // Missing scheme in proxy, default to the requested URL's scheme.
    proxy = proto + '://' + proxy;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      // No wildcards, so stop proxying if there is an exact match.
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    // Stop proxying if the hostname ends with the no_proxy host.
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

exports.getProxyForUrl = getProxyForUrl;


/***/ }),

/***/ 14526:
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
module.exports = toNumber


/***/ }),

/***/ 59318:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const os = __nccwpck_require__(22037);
const tty = __nccwpck_require__(76224);
const hasFlag = __nccwpck_require__(31621);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ 4351:
/***/ ((module) => {

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, Symbol, Reflect, Promise, SuppressedError */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __esDecorate;
var __runInitializers;
var __propKey;
var __setFunctionName;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
var __addDisposableResource;
var __disposeResources;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __esDecorate = function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
            var context = {};
            for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access) context.access[p] = contextIn.access[p];
            context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
            var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.unshift(_);
            }
            else if (_ = accept(result)) {
                if (kind === "field") initializers.unshift(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    };

    __runInitializers = function (thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    };

    __propKey = function (x) {
        return typeof x === "symbol" ? x : "".concat(x);
    };

    __setFunctionName = function (f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
        function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
        function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    __addDisposableResource = function (env, value, async) {
        if (value !== null && value !== void 0) {
            if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
            var dispose, inner;
            if (async) {
                if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                dispose = value[Symbol.asyncDispose];
            }
            if (dispose === void 0) {
                if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                dispose = value[Symbol.dispose];
                if (async) inner = dispose;
            }
            if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
            if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
            env.stack.push({ value: value, dispose: dispose, async: async });
        }
        else if (async) {
            env.stack.push({ async: true });
        }
        return value;
    };

    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    __disposeResources = function (env) {
        function fail(e) {
            env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
});


/***/ }),

/***/ 74294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(54219);


/***/ }),

/***/ 54219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(41808);
var tls = __nccwpck_require__(24404);
var http = __nccwpck_require__(13685);
var https = __nccwpck_require__(95687);
var events = __nccwpck_require__(82361);
var assert = __nccwpck_require__(39491);
var util = __nccwpck_require__(73837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 75840:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(78628));

var _v2 = _interopRequireDefault(__nccwpck_require__(86409));

var _v3 = _interopRequireDefault(__nccwpck_require__(85122));

var _v4 = _interopRequireDefault(__nccwpck_require__(79120));

var _nil = _interopRequireDefault(__nccwpck_require__(25332));

var _version = _interopRequireDefault(__nccwpck_require__(81595));

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

var _parse = _interopRequireDefault(__nccwpck_require__(62746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 4569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 25332:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 62746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 40814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 50807:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 85274:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 18950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 78628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(50807));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 86409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65998));

var _md = _interopRequireDefault(__nccwpck_require__(4569));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 65998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

var _parse = _interopRequireDefault(__nccwpck_require__(62746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 85122:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(50807));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 79120:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65998));

var _sha = _interopRequireDefault(__nccwpck_require__(85274));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 66900:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(40814));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 81595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 6144:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractErrorMessage = void 0;
const core = __importStar(__nccwpck_require__(42186));
const macfc_security_hub_sync_1 = __nccwpck_require__(39465);
function extractErrorMessage(error) {
    if (error instanceof Error) {
        return error.message;
    }
    return 'An unknown error occurred';
}
exports.extractErrorMessage = extractErrorMessage;
// Utility function to get input with fallback to environment variable, can return undefined
function getInputOrEnv(inputName, envName) {
    const inputValue = core.getInput(inputName) || process.env[envName];
    return inputValue;
}
// Utility function to get input with fallback to environment variable and default value
function getDefaultInputOrEnv(inputName, envName, defaultValue) {
    return getInputOrEnv(inputName, envName) || defaultValue;
}
// Utility function to get input with fallback to environment variable and throws an error if it is not set
function getRequiredInputOrEnv(inputName, envName) {
    const inputValue = core.getInput(inputName) || process.env[envName];
    if (!inputValue) {
        throw new Error(`Input for '${inputName}' or environment variable '${envName}' is required but not set.`);
    }
    return inputValue;
}
// Utility function to get input with fallback to environment variable and converts to boolean
function getInputOrEnvAndConvertToBool(inputName, envName, defaultValue = false) {
    const inputValue = core.getInput(inputName) || process.env[envName] || defaultValue.toString();
    return inputValue.trim().toLowerCase() === 'true';
}
function validateAndFilterSeverities(inputSeverities) {
    const allowedSeverities = [
        'INFORMATIONAL',
        'LOW',
        'MEDIUM',
        'HIGH',
        'CRITICAL'
    ];
    const inputSeveritiesArray = inputSeverities
        .split(',')
        .map(severity => severity.trim().toUpperCase())
        .filter(severity => severity);
    // Check each severity in the array against the allowed severities
    inputSeveritiesArray.forEach(severity => {
        if (!allowedSeverities.includes(severity)) {
            throw new Error(`Invalid severity level detected: '${severity}'. Allowed severities are: ${allowedSeverities.join(', ')}.`);
        }
    });
    return inputSeveritiesArray;
}
function parseAndValidateTransitionMap(transitionMapStr) {
    if (!transitionMapStr) {
        return []; // Defaults to wildcard status and transition of 'DONE' if no map is provided
    }
    const transitionMap = transitionMapStr.split(';').map(ruleStr => {
        const [status, transition] = ruleStr
            .split(':')
            .map(part => part.trim().toUpperCase());
        if (!status || !transition) {
            throw new Error(`Invalid transition rule format: '${ruleStr}'. Expected format is 'Status:Transition'.`);
        }
        return { status, transition };
    });
    // Check for the presence of a wildcard transition and validate its uniqueness
    const hasWildcard = transitionMap.some(rule => rule.status === '*');
    if (hasWildcard && transitionMap.length > 1) {
        throw new Error(`Invalid transition map: When using a wildcard transition ('*'), it must be the only transition in the map.`);
    }
    return transitionMap;
}
async function run() {
    try {
        const transitionMapStr = getDefaultInputOrEnv('jira-transition-map', 'JIRA_TRANSITION_MAP', '');
        let customJiraFields;
        const customJiraFieldsStr = getInputOrEnv('jira-custom-fields', 'JIRA_CUSTOM_FIELDS');
        if (customJiraFieldsStr) {
            try {
                customJiraFields = JSON.parse(customJiraFieldsStr);
            }
            catch (e) {
                throw new Error(`Error parsing JSON string for jira-custom-fields input: ${extractErrorMessage(e)}`);
            }
        }
        const transitionMap = parseAndValidateTransitionMap(transitionMapStr);
        const jiraConfig = {
            jiraBaseURI: getDefaultInputOrEnv('jira-base-uri', 'JIRA_BASE_URI', 'https://jiraent.cms.gov'),
            jiraUsername: getRequiredInputOrEnv('jira-username', 'JIRA_USERNAME'),
            jiraToken: getRequiredInputOrEnv('jira-token', 'JIRA_TOKEN'),
            jiraProjectKey: getRequiredInputOrEnv('jira-project-key', 'JIRA_PROJECT'),
            jiraIgnoreStatuses: getDefaultInputOrEnv('jira-ignore-statuses', 'JIRA_IGNORE_STATUSES', 'Done, Closed, Resolved'),
            jiraAssignee: getInputOrEnv('jira-assignee', 'JIRA_ASSIGNEE'),
            transitionMap: transitionMap,
            dryRun: getInputOrEnvAndConvertToBool('dry-run', 'DRY_RUN', false),
            jiraLinkId: getInputOrEnv('jira-link-id', 'JIRA_LINK_ID'),
            jiraLinkType: getDefaultInputOrEnv('jira-link-type', 'JIRA_LINK_TYPE', 'Relates'),
            jiraLinkDirection: getDefaultInputOrEnv('jira-link-direction', 'JIRA_LINK_DIRECTION', 'inward'),
            includeAllProducts: getInputOrEnvAndConvertToBool('include-all-products', 'INCLUDE_ALL_PRODUCTS', false),
            skipProducts: getInputOrEnv('skip-products', 'SKIP_PRODUCTS'),
            jiraLabelsConfig: getInputOrEnv('jira-labels-config', 'JIRA_LABELS_CONFIG')
        };
        const severitiesStr = getDefaultInputOrEnv('aws-severities', 'AWS_SEVERITIES', 'CRITICAL,HIGH,MEDIUM'); //
        const securityHubConfig = {
            region: getDefaultInputOrEnv('aws-region', 'AWS_REGION', 'us-east-1'),
            severities: validateAndFilterSeverities(severitiesStr),
            newIssueDelay: getDefaultInputOrEnv('security-hub-new-issue-delay', 'SECURITY_HUB_NEW_ISSUE_DELAY', '86400000'),
            customJiraFields: customJiraFields,
            includeAllProducts: getInputOrEnvAndConvertToBool('include-all-products', 'INCLUDE_ALL_PRODUCTS', false),
            skipProducts: getInputOrEnv('skip-products', 'SKIP_PRODUCTS')
        };
        const autoClose = getInputOrEnvAndConvertToBool('auto-close', 'AUTO_CLOSE', true);
        core.info('Syncing Security Hub and Jira');
        await new macfc_security_hub_sync_1.SecurityHubJiraSync(jiraConfig, securityHubConfig, autoClose).sync();
    }
    catch (error) {
        core.setFailed(`Sync failed: ${extractErrorMessage(error)}`);
    }
}
run();


/***/ }),

/***/ 70076:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__nccwpck_require__(46461), exports);
__exportStar(__nccwpck_require__(73109), exports);


/***/ }),

/***/ 46461:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Jira = void 0;
const dotenv = __importStar(__nccwpck_require__(12437));
const axios_1 = __importStar(__nccwpck_require__(88757));
const index_1 = __nccwpck_require__(6144);
dotenv.config();
function handleAxiosError(error) {
    // Check if the error is an instance of AxiosError
    if (error instanceof axios_1.AxiosError) {
        let errorDetails = JSON.stringify(error.toJSON(), null, 2);
        // Mask the token in the error details
        errorDetails = errorDetails.replace(/"Authorization": "Bearer [^"]+"/, `"Authorization": "Bearer <REDACTED_TOKEN>"`);
        console.log(errorDetails);
        // Check if the cause of the AxiosError is an AggregateError
        if (error.cause instanceof AggregateError && error.cause.errors) {
            // Map each error in the AggregateError to its message and join them
            const errMsgs = error.cause.errors
                .map(err => (0, index_1.extractErrorMessage)(err))
                .join(', ');
            return `Errors from Axios request: ${errMsgs}`;
        }
        // For non-aggregate AxiosError, extract the single error message
        let errorMessage = `Error from Axios request: ${(0, index_1.extractErrorMessage)(error)}`;
        // Include response data in the error message if available
        if (error.response && error.response.data) {
            errorMessage += `\nResponse data: ${JSON.stringify(error.response.data)}`;
        }
        return errorMessage;
    }
    // Fallback for non-Axios errors
    return `${(0, index_1.extractErrorMessage)(error)}`;
}
class Jira {
    jiraBaseURI;
    jiraProject;
    axiosInstance;
    transitionMap = [];
    jiraAssignee;
    jiraIgnoreStatusesList;
    isDryRun;
    dryRunIssueCounter = 0;
    jiraLabelsConfig;
    constructor(jiraConfig) {
        this.jiraBaseURI = jiraConfig.jiraBaseURI;
        this.jiraProject = jiraConfig.jiraProjectKey;
        this.jiraAssignee = jiraConfig.jiraAssignee;
        this.transitionMap = jiraConfig.transitionMap;
        this.jiraIgnoreStatusesList = jiraConfig.jiraIgnoreStatuses
            .split(',')
            .map(status => status.trim());
        this.isDryRun = jiraConfig.dryRun;
        if (jiraConfig.jiraLabelsConfig) {
            this.jiraLabelsConfig = JSON.parse(jiraConfig.jiraLabelsConfig);
        }
        this.axiosInstance = axios_1.default.create({
            baseURL: jiraConfig.jiraBaseURI,
            headers: {
                Authorization: `Bearer ${jiraConfig.jiraToken}`,
                'Content-Type': 'application/json'
            }
        });
    }
    async getCurrentUser() {
        try {
            const response = await this.axiosInstance.get('/rest/api/2/myself');
            return response.data;
        }
        catch (error) {
            throw new Error(`Error fetching current user: ${handleAxiosError(error)}`);
        }
    }
    async getIssue(issueId) {
        try {
            const response = await this.axiosInstance.get(`/rest/api/2/issue/${issueId}`);
            return response.data;
        }
        catch (error) {
            throw new Error(`Error fetching issue details for issue ${issueId}: ${handleAxiosError(error)}`);
        }
    }
    async getCurrentStatus(issueId) {
        try {
            return (await this.getIssue(issueId)).fields.status.name.toUpperCase();
        }
        catch (error) {
            throw new Error(`Error fetching current status for issue ${issueId}: ${handleAxiosError(error)}`);
        }
    }
    async getIssueTransitions(issueId) {
        try {
            const response = await this.axiosInstance.get(`/rest/api/2/issue/${issueId}/transitions`);
            const transitions = response.data.transitions;
            if (!transitions.every(t => 'id' in t && 'name' in t)) {
                throw new Error('One or more transitions are missing required properties (id, name)');
            }
            return transitions;
        }
        catch (error) {
            throw new Error(`Error fetching issue transitions: ${handleAxiosError(error)}`);
        }
    }
    async transitionIssueByName(issueId, transitionName) {
        if (this.isDryRun) {
            console.log(`[Dry Run] Would transition issue ${issueId} with transition:`, transitionName);
            return;
        }
        try {
            // Fetch available transitions for the issue
            const availableTransitions = await this.getIssueTransitions(issueId);
            // Find the transition ID corresponding to the provided transition name
            console.log("available", availableTransitions);
            const transition = availableTransitions.find(t => t.name.toLocaleUpperCase() === transitionName || t.name.toLowerCase() === transitionName.toLocaleLowerCase());
            if (!transition) {
                throw new Error(`Transition '${transitionName}' not found for issue ${issueId}`);
            }
            // Transition the issue using the found transition ID
            await this.axiosInstance.post(`/rest/api/2/issue/${issueId}/transitions`, {
                transition: { id: transition.id }
            });
            console.log(`Issue ${issueId} transitioned successfully to '${transitionName}'.`);
        }
        catch (error) {
            throw new Error(`Error transitioning issue ${issueId} to '${transitionName}': ${handleAxiosError(error)}`);
        }
    }
    async transitionIssueById(issueId, transitionId, transitionName) {
        if (this.isDryRun) {
            console.log(`[Dry Run] Would transition issue ${issueId} with transition:`, transitionName);
            return;
        }
        try {
            // Transition the issue using the found transition ID
            await this.axiosInstance.post(`/rest/api/2/issue/${issueId}/transitions`, {
                transition: { id: transitionId }
            });
            console.log(`Issue ${issueId} transitioned successfully to '${transitionName}'.`);
        }
        catch (error) {
            throw new Error(`Error transitioning issue ${issueId} to '${transitionName}': ${handleAxiosError(error)}`);
        }
    }
    async removeCurrentUserAsWatcher(issueId) {
        try {
            const currentUser = await this.getCurrentUser();
            console.log(`Remove watcher ${currentUser.name} from ${issueId}`);
            if (this.isDryRun) {
                console.log(`[Dry Run] Would remove ${currentUser.name} from ${issueId} as watcher.`);
                return; // Skip the actual API call
            }
            await this.axiosInstance.delete(`/rest/api/2/issue/${issueId}/watchers`, {
                params: {
                    username: currentUser.name
                }
            });
        }
        catch (error) {
            throw new Error(`Error creating issue or removing watcher: ${handleAxiosError(error)}`);
        }
    }
    static formatLabelQuery(label) {
        return `labels = '${label}'`;
    }
    createSearchLabels(identifyingLabels, config) {
        const labels = [];
        const fields = ['accountId', 'region', 'identify'];
        const values = [...identifyingLabels, 'security-hub'];
        config.forEach(({ labelField: field, labelDelimiter: delim, labelPrefix: prefix }) => {
            const delimiter = delim ?? '';
            const labelPrefix = prefix ?? '';
            if (fields.includes(field)) {
                const index = fields.indexOf(field);
                if (index >= 0) {
                    labels.push(`${labelPrefix}${delimiter}${values[index]?.trim().replace(/ /g, '')}`);
                }
            }
        });
        return labels;
    }
    async getAllSecurityHubIssuesInJiraProject(identifyingLabels) {
        const labelQueries = [...identifyingLabels, 'security-hub']
            .map(label => Jira.formatLabelQuery(label))
            .join(' AND ');
        let finalLabelQuery = labelQueries;
        if (this.jiraLabelsConfig) {
            const config = this.jiraLabelsConfig;
            const configLabels = this.createSearchLabels(identifyingLabels, config);
            const searchQuery = configLabels
                .map(label => Jira.formatLabelQuery(label))
                .join(' AND ');
            if (searchQuery) {
                finalLabelQuery = `(${finalLabelQuery}) OR (${searchQuery})`;
            }
        }
        const projectQuery = `project = '${this.jiraProject}'`;
        const statusQuery = `status not in ('${this.jiraIgnoreStatusesList.join("','" // wrap each closed status in single quotes
        )}')`;
        const fullQuery = [finalLabelQuery, projectQuery, statusQuery].join(' AND ');
        // We  want to do everything possible to prevent matching tickets that we shouldn't
        if (!fullQuery.includes(Jira.formatLabelQuery('security-hub'))) {
            throw new Error("ERROR:  Your query does not include the 'security-hub' label, and is too broad.  Refusing to continue");
        }
        if (!fullQuery.match(Jira.formatLabelQuery('[0-9]{12}'))) {
            throw new Error('ERROR:  Your query does not include an AWS Account ID as a label, and is too broad.  Refusing to continue');
        }
        console.log(fullQuery);
        let totalIssuesReceived = 0;
        let allIssues = [];
        let startAt = 0;
        let total = 0;
        do {
            try {
                const response = await this.axiosInstance.post('/rest/api/2/search', {
                    jql: fullQuery,
                    startAt: startAt,
                    maxResults: 50,
                    fields: ['*all']
                });
                const results = response.data;
                allIssues = allIssues.concat(results.issues);
                totalIssuesReceived += results.issues.length;
                startAt = totalIssuesReceived;
                total = results.total;
            }
            catch (error) {
                throw new Error(`Error getting Security Hub issues from Jira: ${handleAxiosError(error)}`);
            }
        } while (totalIssuesReceived < total);
        return allIssues;
    }
    async createNewIssue(issue) {
        let response;
        try {
            if (this.jiraAssignee) {
                issue.fields.assignee = { name: this.jiraAssignee };
            }
            issue.fields.project = { key: this.jiraProject };
            if (this.isDryRun) {
                console.log(`[Dry Run] Would create a new issue with the following details:`, issue);
                // Return a dry run issue object
                this.dryRunIssueCounter++;
                const dryRunIssue = {
                    id: `dryrun-id-${this.dryRunIssueCounter}`,
                    key: `DRYRUN-KEY-${this.dryRunIssueCounter}`,
                    fields: {
                        description: 'Dry Run Description',
                        issuetype: { name: 'Dry Run Issue' },
                        summary: issue.fields.summary ||
                            `Dry Run Summary ${this.dryRunIssueCounter}`,
                        labels: []
                    },
                    webUrl: `${this.jiraBaseURI}/browse/DRYRUN-KEY-${this.dryRunIssueCounter}`
                };
                return dryRunIssue; // Return a dummy issue
            }
            response = await this.axiosInstance.post('/rest/api/2/issue', issue);
            const newIssue = response.data;
            // Construct the webUrl for the new issue
            newIssue['webUrl'] = `${this.jiraBaseURI}/browse/${newIssue.key}`;
            await this.removeCurrentUserAsWatcher(newIssue.key);
            return newIssue;
        }
        catch (error) {
            throw new Error(`Error creating Jira issue: ${handleAxiosError(error)}`);
        }
    }
    async linkIssues(newIssueKey, issueID, linkType = 'Relates', linkDirection = 'inward') {
        if (this.isDryRun) {
            console.log(`[Dry Run] Would link issues ${newIssueKey} with ${issueID} using type ${linkType} and direction ${linkDirection}`);
            return;
        }
        const linkData = {
            type: { name: linkType },
            inwardIssue: { key: newIssueKey },
            outwardIssue: { key: issueID }
        };
        if (linkDirection === 'outward') {
            const temp = linkData.inwardIssue.key;
            linkData.inwardIssue.key = linkData.outwardIssue.key;
            linkData.outwardIssue.key = temp;
        }
        try {
            const response = await this.axiosInstance.post('/rest/api/2/issueLink', linkData);
            console.log(`Successfully linked issue ${newIssueKey} with ${issueID}:`, response.data);
        }
        catch (error) {
            console.error('Error linking issues:', error);
            throw new Error(`Error linking issues: ${error}`);
        }
    }
    async updateIssueTitleById(issueId, updatedIssue) {
        if (this.isDryRun) {
            console.log(`[Dry Run] Would update issue title for issue ${issueId} with:`, updatedIssue);
            return;
        }
        try {
            const response = await this.axiosInstance.put(`/rest/api/2/issue/${issueId}`, updatedIssue);
            console.log('Issue title updated successfully:', response.data);
        }
        catch (error) {
            throw new Error(`Error updating issue title: ${handleAxiosError(error)}`);
        }
    }
    async addCommentToIssueById(issueId, comment) {
        if (this.isDryRun) {
            console.log(`[Dry Run] Would add comment to issue ${issueId}:`, comment);
            return;
        }
        try {
            await this.axiosInstance.post(`/rest/api/2/issue/${issueId}/comment`, {
                body: comment
            });
            await this.removeCurrentUserAsWatcher(issueId); // Commenting on the issue adds the user as a watcher, so we remove them
        }
        catch (error) {
            throw new Error(`Error adding comment to issue: ${handleAxiosError(error)}`);
        }
    }
    getNextTransition(currentStatus) {
        // First, try to find a specific transition for the current status
        let nextTransition = this.transitionMap.find(rule => rule.status === currentStatus)?.transition;
        // If not found, look for a wildcard transition
        if (!nextTransition) {
            nextTransition = this.transitionMap.find(rule => rule.status === '*')?.transition;
        }
        return nextTransition;
    }
    async applyWildcardTransition(issueId) {
        const wildcardTransition = this.transitionMap.find(rule => rule.status === '*')?.transition;
        if (wildcardTransition) {
            console.log(`Applying wildcard transition '${wildcardTransition}' to issue ${issueId}`);
            await this.transitionIssueByName(issueId, wildcardTransition);
            return true; // Indicate that a wildcard transition was applied
        }
        return false; // No wildcard transition found
    }
    async closeIssueUsingTransitionMap(issueId) {
        if (this.isDryRun) {
            console.log(`[Dry Run] Would apply transition map to issue ${issueId}`);
            return;
        }
        // Attempt to apply a wildcard transition first
        const wildcardApplied = await this.applyWildcardTransition(issueId);
        if (wildcardApplied) {
            console.log(`Wildcard transition applied to issue ${issueId}. Closing process completed.`);
            return; // Exit the method as the wildcard transition takes precedence
        }
        console.log(`Attempting to close ${issueId}: Applying transition map to issue`);
        try {
            for (let i = 0; i <= this.transitionMap.length; i++) {
                const currentStatus = await this.getCurrentStatus(issueId);
                const nextTransition = this.transitionMap.find(rule => rule.status === currentStatus)?.transition;
                if (!nextTransition) {
                    console.log(`No further transitions defined for current status: ${currentStatus}. Issue ${issueId} considered at desired state.`);
                    return; // No mapped transition for current status, considered as terminal state
                }
                // Apply the transition directly from the map
                await this.transitionIssueByName(issueId, nextTransition);
            }
            throw new Error(`Overran transition map for issue ${issueId}.`);
        }
        catch (error) {
            throw new Error(`Error applying transition map to issue ${issueId}: ${(0, index_1.extractErrorMessage)(error)}`);
        }
    }
    async completeWorkflow(issueKey) {
        const opposedStatuses = ["canceled", "backout", "rejected", "cancel", "reject"];
        const doneStatuses = ["done", "closed", "close", "complete", "completed", "deploy", "deployed"];
        try {
            const issue = await this.getIssue(issueKey);
            const processedTransitions = [];
            do {
                const availableTransitions = await this.getIssueTransitions(issueKey);
                if (availableTransitions.length > 0) {
                    const targetTransitions = availableTransitions.filter((transition) => !opposedStatuses.includes(transition.name.toLowerCase()) &&
                        !processedTransitions.includes(transition.name.toLowerCase()));
                    const lastStatus = processedTransitions[processedTransitions?.length - 1]?.toLowerCase();
                    if (targetTransitions.length <= 0) {
                        if (!processedTransitions.length) {
                            throw new Error("Unsupported workflow; no transition available");
                        }
                        if (!doneStatuses.includes(lastStatus)) {
                            throw new Error("Unsupported Workflow: does not contain any of " +
                                doneStatuses.join(",") +
                                "statuses");
                        }
                        break;
                    }
                    else if (doneStatuses.includes(lastStatus)) {
                        return;
                    }
                    const transition = targetTransitions[0];
                    processedTransitions.push(targetTransitions[0].name?.toLowerCase());
                    await this.transitionIssueById(issueKey, transition.id, transition.name);
                    console.log(`Transitioned issue ${issueKey} to the next stage: ${targetTransitions[0].name}`);
                }
                else {
                    break;
                }
            } while (true);
        }
        catch (e) {
            console.log("Error completing the workflow ", e);
        }
    }
    async closeIssue(issueKey) {
        if (!issueKey)
            return;
        try {
            const transitions = await this.getIssueTransitions(issueKey);
            const doneTransition = transitions.find((t) => t.name === "Done");
            if (!doneTransition) {
                try {
                    if (this.transitionMap.length) {
                        await this.closeIssueUsingTransitionMap(issueKey);
                    }
                    else {
                        await this.completeWorkflow(issueKey);
                    }
                }
                catch (e) {
                    await this.completeWorkflow(issueKey);
                }
                return;
            }
            await this.transitionIssueByName(issueKey, doneTransition.name);
        }
        catch (e) {
            throw new Error(`Error closing issue ${issueKey}: ${e.message}`);
        }
    }
}
exports.Jira = Jira;


/***/ }),

/***/ 73109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityHub = void 0;
const client_iam_1 = __nccwpck_require__(26276);
const client_securityhub_1 = __nccwpck_require__(93978);
const index_1 = __nccwpck_require__(6144);
class SecurityHub {
    region;
    severityLabels;
    newIssueDelay;
    accountAlias = '';
    includeAllProducts;
    skipProducts;
    constructor(securityHubJiraSyncConfig) {
        this.region = securityHubJiraSyncConfig.region;
        this.severityLabels = securityHubJiraSyncConfig.severities.map(severity => ({
            Comparison: 'EQUALS',
            Value: severity
        }));
        this.newIssueDelay = securityHubJiraSyncConfig.newIssueDelay;
        this.getAccountAlias().catch(error => console.error(error));
        this.includeAllProducts = securityHubJiraSyncConfig.includeAllProducts;
        this.skipProducts = securityHubJiraSyncConfig.skipProducts
            ?.split(',')
            .map(product => product.trim());
    }
    async getAccountAlias() {
        const iamClient = new client_iam_1.IAMClient({ region: this.region });
        const response = await iamClient.send(new client_iam_1.ListAccountAliasesCommand({}));
        this.accountAlias = response.AccountAliases?.[0] || '';
    }
    async getAllActiveFindings() {
        try {
            const securityHubClient = new client_securityhub_1.SecurityHubClient({ region: this.region });
            const currentTime = new Date();
            // delay for filtering out ephemeral issues
            const delayForNewIssues = +this.newIssueDelay;
            const maxDatetime = new Date(currentTime.getTime() - delayForNewIssues);
            const filters = {
                RecordState: [{ Comparison: 'EQUALS', Value: 'ACTIVE' }],
                WorkflowStatus: [
                    { Comparison: 'EQUALS', Value: 'NEW' },
                    { Comparison: 'EQUALS', Value: 'NOTIFIED' }
                ],
                SeverityLabel: this.severityLabels,
                CreatedAt: [
                    {
                        Start: '1970-01-01T00:00:00Z',
                        End: maxDatetime.toISOString()
                    }
                ]
            };
            if (this.includeAllProducts !== true) {
                filters.ProductName = [{ Comparison: 'EQUALS', Value: 'Security Hub' }];
            }
            if (this.skipProducts) {
                this.skipProducts.forEach((product) => {
                    if (!filters.ProductName) {
                        filters.ProductName = [];
                    }
                    filters.ProductName?.push({
                        Comparison: 'NOT_EQUALS',
                        Value: product
                    });
                });
            }
            // use an object to store unique findings by title
            const uniqueFindings = {};
            // use a variable to track pagination
            let nextToken = undefined;
            do {
                const response = await securityHubClient.send(new client_securityhub_1.GetFindingsCommand({
                    Filters: filters,
                    MaxResults: 100,
                    NextToken: nextToken
                }));
                if (response && response.Findings) {
                    for (const finding of response.Findings) {
                        const findingForJira = this.awsSecurityFindingToSecurityHubFinding(finding);
                        if (findingForJira.title)
                            uniqueFindings[findingForJira.title] = findingForJira;
                    }
                }
                if (response && response.NextToken)
                    nextToken = response.NextToken;
                else
                    nextToken = undefined;
            } while (nextToken);
            return Object.values(uniqueFindings).map(finding => {
                return {
                    accountAlias: this.accountAlias,
                    ...finding
                };
            });
        }
        catch (error) {
            throw new Error(`Error getting Security Hub findings: ${(0, index_1.extractErrorMessage)(error)}`);
        }
    }
    awsSecurityFindingToSecurityHubFinding(finding) {
        if (!finding)
            return {};
        return {
            id: finding.Id,
            title: finding.Title,
            region: finding.Region,
            accountAlias: this.accountAlias,
            awsAccountId: finding.AwsAccountId,
            severity: finding.Severity && finding.Severity.Label
                ? finding.Severity.Label
                : '',
            description: finding.Description,
            standardsControlArn: finding.ProductFields && finding.ProductFields.StandardsControlArn
                ? finding.ProductFields.StandardsControlArn
                : '',
            remediation: finding.Remediation,
            ProductName: finding.ProductName,
            Resources: finding.Resources
        };
    }
}
exports.SecurityHub = SecurityHub;


/***/ }),

/***/ 39465:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityHubJiraSync = void 0;
const index_1 = __nccwpck_require__(6144);
const libs_1 = __nccwpck_require__(70076);
const client_sts_1 = __nccwpck_require__(52209);
class SecurityHubJiraSync {
    jira;
    securityHub;
    customJiraFields;
    region;
    severities;
    autoClose;
    jiraBaseURI;
    jiraLinkId;
    jiraLinkType;
    jiraLinkDirection;
    jiraLabelsConfig;
    constructor(jiraConfig, securityHubConfig, autoClose) {
        this.securityHub = new libs_1.SecurityHub(securityHubConfig);
        this.region = securityHubConfig.region;
        this.severities = securityHubConfig.severities;
        this.jira = new libs_1.Jira(jiraConfig);
        this.jiraBaseURI = jiraConfig.jiraBaseURI;
        this.customJiraFields = securityHubConfig.customJiraFields;
        this.autoClose = autoClose;
        this.jiraLinkId = jiraConfig.jiraLinkId;
        this.jiraLinkType = jiraConfig.jiraLinkType;
        this.jiraLinkDirection = jiraConfig.jiraLinkDirection;
        if (jiraConfig.jiraLabelsConfig) {
            this.jiraLabelsConfig = JSON.parse(jiraConfig.jiraLabelsConfig);
        }
    }
    async sync() {
        const updatesForReturn = [];
        // Step 0. Gather and set some information that will be used throughout this function
        const accountId = await this.getAWSAccountID();
        const identifyingLabels = [accountId, this.region];
        // Step 1. Get all open Security Hub issues from Jira
        const jiraIssues = await this.jira.getAllSecurityHubIssuesInJiraProject(identifyingLabels);
        // Step 2. Get all current findings from Security Hub
        console.log('Getting active Security Hub Findings with severities: ' + this.severities);
        const shFindingsObj = await this.securityHub.getAllActiveFindings();
        const shFindings = Object.values(shFindingsObj);
        console.log(shFindings);
        // Step 3. Close existing Jira issues if their finding is no longer active/current
        updatesForReturn.push(...(await this.closeIssuesForResolvedFindings(jiraIssues, shFindings)));
        // Step 4. Create Jira issue for current findings that do not already have a Jira issue
        updatesForReturn.push(...(await this.createJiraIssuesForNewFindings(jiraIssues, shFindings, identifyingLabels)));
        console.log(JSON.stringify(updatesForReturn));
    }
    async getAWSAccountID() {
        const client = new client_sts_1.STSClient({
            region: this.region
        });
        const command = new client_sts_1.GetCallerIdentityCommand({});
        let response;
        try {
            response = await client.send(command);
        }
        catch (e) {
            throw new Error(`Error getting AWS Account ID: ${(0, index_1.extractErrorMessage)(e)}`);
        }
        const accountID = response.Account || '';
        if (!accountID.match('[0-9]{12}')) {
            throw new Error('ERROR:  An issue was encountered when looking up your AWS Account ID.  Refusing to continue.');
        }
        return accountID;
    }
    async closeIssuesForResolvedFindings(jiraIssues, shFindings) {
        const updatesForReturn = [];
        const expectedJiraIssueTitles = Array.from(new Set(shFindings.map(finding => `SecurityHub Finding - ${finding.title}`)));
        try {
            const makeComment = () => `As of ${new Date(Date.now()).toDateString()}, this Security Hub finding has been marked resolved`;
            // close all security-hub labeled Jira issues that do not have an active finding
            if (this.autoClose) {
                for (let i = 0; i < jiraIssues.length; i++) {
                    if (!expectedJiraIssueTitles.includes(jiraIssues[i].fields.summary)) {
                        await this.jira.closeIssue(jiraIssues[i].key);
                        updatesForReturn.push({
                            action: 'closed',
                            webUrl: `${this.jiraBaseURI}/browse/${jiraIssues[i].key}`,
                            summary: jiraIssues[i].fields.summary
                        });
                        await this.jira.addCommentToIssueById(jiraIssues[i].id, makeComment());
                    }
                }
            }
            else {
                console.log('Skipping auto closing...');
                for (let i = 0; i < jiraIssues.length; i++) {
                    if (!expectedJiraIssueTitles.includes(jiraIssues[i].fields.summary) &&
                        !jiraIssues[i].fields.summary.includes('Resolved') // skip already resolved issues
                    ) {
                        try {
                            await this.jira.updateIssueTitleById(jiraIssues[i].id, {
                                fields: {
                                    summary: `Resolved ${jiraIssues[i].fields.summary}`
                                }
                            });
                            await this.jira.addCommentToIssueById(jiraIssues[i].id, makeComment());
                        }
                        catch (e) {
                            console.log(`Title of ISSUE with id ${jiraIssues[i].id} is not changed with error: ${JSON.stringify(e)}`);
                        }
                    }
                }
            }
        }
        catch (e) {
            throw new Error(`Error closing Jira issue for resolved finding: ${(0, index_1.extractErrorMessage)(e)}`);
        }
        return updatesForReturn;
    }
    makeResourceList(resources) {
        if (!resources) {
            return `No Resources`;
        }
        const maxLength = Math.max(...resources.map(({ Id }) => Id?.length || 0));
        const title = 'Resource Id'.padEnd(maxLength + maxLength / 2 + 4);
        let Table = `${title}| Partition   | Region     | Type    \n`;
        resources.forEach(({ Id, Partition, Region, Type }) => {
            Table += `${Id?.padEnd(maxLength + 2)}| ${(Partition ?? '').padEnd(11)} | ${(Region ?? '').padEnd(9)} | ${Type ?? ''} \n`;
        });
        Table += `------------------------------------------------------------------------------------------------`;
        return Table;
    }
    createSecurityHubFindingUrlThroughFilters(findingId) {
        let region;
        if (findingId.startsWith('arn:')) {
            // Extract region and account ID from the ARN
            const arnParts = findingId.split(':');
            region = arnParts[3];
        }
        else {
            // Extract region and account ID from the non-ARN format
            const parts = findingId.split('/');
            region = parts[1];
        }
        const baseUrl = `https://${region}.console.aws.amazon.com/securityhub/home?region=${region}`;
        const searchParam = `Id%3D%255Coperator%255C%253AEQUALS%255C%253A${findingId}`;
        const url = `${baseUrl}#/findings?search=${searchParam}`;
        return url;
    }
    createIssueBody(finding) {
        const { remediation: { Recommendation: { Url: remediationUrl = '', Text: remediationText = '' } = {} } = {}, id = '', title = '', description = '', accountAlias = '', awsAccountId = '', severity = '', standardsControlArn = '' } = finding;
        return `----

      *This issue was generated from Security Hub data and is managed through automation.*
      Please do not edit the title or body of this issue, or remove the security-hub tag.  All other edits/comments are welcome.
      Finding Title: ${title}

      ----

      h2. Type of Issue:

      * Security Hub Finding

      h2. Title:

      ${title}

      h2. Description:

      ${description}

      ${remediationText || remediationUrl
            ? `
      h2. Remediation:

      ${remediationUrl}
      ${remediationText}
        `
            : ''}

      h2. AWS Account:
      ${awsAccountId} (${accountAlias})

      h2. Severity:
      ${severity}

 h2. SecurityHubFindingUrl:
      ${standardsControlArn ? this.createSecurityHubFindingUrl(standardsControlArn) : this.createSecurityHubFindingUrlThroughFilters(id)}

      h2. Resources:
      Following are the resources those were non-compliant at the time of the issue creation
      ${this.makeResourceList(finding.Resources)}

      To check the latest list of resources, kindly refer to the finding url
      h2. AC:

      * All findings of this type are resolved or suppressed, indicated by a Workflow Status of Resolved or Suppressed.  (Note:  this ticket will automatically close when the AC is met.)`;
    }
    createSecurityHubFindingUrl(standardsControlArn = '') {
        if (!standardsControlArn) {
            return '';
        }
        const [, partition, , region, , , securityStandards, , securityStandardsVersion, controlId] = standardsControlArn.split(/[/:]+/);
        return `https://${region}.console.${partition}.amazon.com/securityhub/home?region=${region}#/standards/${securityStandards}-${securityStandardsVersion}/${controlId}`;
    }
    getSeverityMappingToJiraPriority = (severity) => {
        switch (severity) {
            case 'INFORMATIONAL':
                return 'Lowest';
            case 'LOW':
                return 'Low';
            case 'MEDIUM':
                return 'Medium';
            case 'HIGH':
                return 'High';
            case 'CRITICAL':
                return 'Critical';
            default:
                throw new Error(`Invalid severity: ${severity}`);
        }
    };
    createLabels(finding, identifyingLabels, config) {
        const labels = [];
        const fields = ['accountId', 'region', 'identify'];
        const values = [...identifyingLabels, 'security-hub'];
        config.forEach(({ labelField: field, labelDelimiter: delim, labelPrefix: prefix }) => {
            const delimiter = delim ?? '';
            const labelPrefix = prefix ?? '';
            if (fields.includes(field)) {
                const index = fields.indexOf(field);
                if (index >= 0) {
                    labels.push(`${labelPrefix}${delimiter}${values[index]?.trim().replace(/ /g, '')}`);
                }
            }
            else {
                const value = (finding[field] ?? '')
                    .toString()
                    .trim()
                    .replace(/ /g, '');
                labels.push(`${labelPrefix}${delimiter}${value}`);
            }
        });
        return labels;
    }
    async createJiraIssueFromFinding(finding, identifyingLabels) {
        if (!finding.severity) {
            throw new Error(`Severity must be defined in Security Hub finding: ${finding.title}`);
        }
        const newIssueData = {
            fields: {
                summary: `SecurityHub Finding - ${finding.title}`,
                description: this.createIssueBody(finding),
                issuetype: { name: 'Task' },
                labels: [
                    'security-hub',
                    finding.severity,
                    finding.accountAlias,
                    finding.ProductName?.trim().replace(/ /g, ''),
                    ...identifyingLabels
                ],
                priority: {
                    name: this.getSeverityMappingToJiraPriority(finding.severity)
                },
                ...this.customJiraFields
            }
        };
        if (this.jiraLabelsConfig) {
            try {
                const config = this.jiraLabelsConfig;
                newIssueData.fields.labels = this.createLabels(finding, identifyingLabels, config);
            }
            catch (e) {
                console.log('Invalid labels config - going with default labels');
            }
        }
        let newIssueInfo;
        try {
            newIssueInfo = await this.jira.createNewIssue(newIssueData);
            const issue_id = this.jiraLinkId;
            if (issue_id) {
                const linkType = this.jiraLinkType;
                const linkDirection = this.jiraLinkDirection;
                await this.jira.linkIssues(newIssueInfo.key, issue_id, linkType, linkDirection);
            }
        }
        catch (e) {
            throw new Error(`Error creating Jira issue from finding: ${(0, index_1.extractErrorMessage)(e)}`);
        }
        return {
            action: 'created',
            webUrl: newIssueInfo.webUrl,
            summary: newIssueData.fields.summary
        };
    }
    async createJiraIssuesForNewFindings(jiraIssues, shFindings, identifyingLabels) {
        const updatesForReturn = [];
        const existingJiraIssueTitles = jiraIssues.map(i => i.fields.summary);
        const uniqueSecurityHubFindings = [
            ...new Set(shFindings.map(finding => JSON.stringify(finding)))
        ].map(finding => JSON.parse(finding));
        for (let i = 0; i < uniqueSecurityHubFindings.length; i++) {
            const finding = uniqueSecurityHubFindings[i];
            if (!existingJiraIssueTitles.includes(`SecurityHub Finding - ${finding.title}`)) {
                const update = await this.createJiraIssueFromFinding(finding, identifyingLabels);
                updatesForReturn.push(update);
            }
        }
        return updatesForReturn;
    }
}
exports.SecurityHubJiraSync = SecurityHubJiraSync;


/***/ }),

/***/ 87578:
/***/ ((module) => {

module.exports = eval("require")("aws-crt");


/***/ }),

/***/ 39491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 14300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 32081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 82361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 57147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 13685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 85158:
/***/ ((module) => {

"use strict";
module.exports = require("http2");

/***/ }),

/***/ 95687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 41808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 22037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 71017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 77282:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 12781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 24404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 76224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 57310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 73837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 59796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 88757:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Axios v1.6.7 Copyright (c) 2024 Matt Zabriskie and contributors


const FormData$1 = __nccwpck_require__(91403);
const url = __nccwpck_require__(57310);
const proxyFromEnv = __nccwpck_require__(63329);
const http = __nccwpck_require__(13685);
const https = __nccwpck_require__(95687);
const util = __nccwpck_require__(73837);
const followRedirects = __nccwpck_require__(67707);
const zlib = __nccwpck_require__(59796);
const stream = __nccwpck_require__(12781);
const EventEmitter = __nccwpck_require__(82361);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData$1);
const url__default = /*#__PURE__*/_interopDefaultLegacy(url);
const http__default = /*#__PURE__*/_interopDefaultLegacy(http);
const https__default = /*#__PURE__*/_interopDefaultLegacy(https);
const util__default = /*#__PURE__*/_interopDefaultLegacy(util);
const followRedirects__default = /*#__PURE__*/_interopDefaultLegacy(followRedirects);
const zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
const stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);
const EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData__default["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$1.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$1.isArray(value) && isFlatArray(value)) ||
        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$1.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

const InterceptorManager$1 = InterceptorManager;

const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

const URLSearchParams = url__default["default"].URLSearchParams;

const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData__default["default"],
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  protocols: [ 'http', 'https', 'file', 'data' ]
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = (
  (product) => {
    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0
  })(typeof navigator !== 'undefined' && navigator.product);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hasBrowserEnv: hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: hasStandardBrowserEnv
});

const platform = {
  ...utils,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};

    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);

    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$1.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$1.isArrayBuffer(data) ||
      utils$1.isBuffer(data) ||
      utils$1.isStream(data) ||
      utils$1.isFile(data) ||
      utils$1.isBlob(data)
    ) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

const defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
const parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$1.isString(value)) return;

  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$1.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$1.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$1.freezeMethods(AxiosHeaders);

const AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

const VERSION = "1.6.7";

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1000 / freq;
  let timer = null;
  return function throttled(force, args) {
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, args);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, args);
      }, threshold - (now - timestamp));
    }
  };
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

const kInternals = Symbol('internals');

class AxiosTransformStream extends stream__default["default"].Transform{
  constructor(options) {
    options = utils$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1.isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const self = this;

    const internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });

    let bytesNotified = 0;

    internals.updateProgress = throttle(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self.destroyed) return;

      const rate = _speedometer(progressBytes);

      bytesNotified = bytesTransferred;

      process.nextTick(() => {
        self.emit('progress', {
          'loaded': bytesTransferred,
          'total': totalBytes,
          'progress': totalBytes ? (bytesTransferred / totalBytes) : undefined,
          'bytes': progressBytes,
          'rate': rate ? rate : undefined,
          'estimated': rate && totalBytes && bytesTransferred <= totalBytes ?
            (totalBytes - bytesTransferred) / rate : undefined
        });
      });
    }, internals.ticksRate);

    const onFinish = () => {
      internals.updateProgress(true);
    };

    this.once('end', onFinish);
    this.once('error', onFinish);
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const self = this;
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    function pushChunk(_chunk, _callback) {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      if (internals.isCaptured) {
        internals.updateProgress();
      }

      if (self.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }

  setLength(length) {
    this[kInternals].length = +length;
    return this;
  }
}

const AxiosTransformStream$1 = AxiosTransformStream;

const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};

const readBlob$1 = readBlob;

const BOUNDARY_ALPHABET = utils$1.ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = new util.TextEncoder();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = utils$1.isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(utils$1.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob$1(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + utils$1.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!utils$1.isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = utils$1.toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  };

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return stream.Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

const formDataToStream$1 = formDataToStream;

class ZlibHeaderTransformStream extends stream__default["default"].Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;

const callbackify = (fn, reducer) => {
  return utils$1.isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};

const callbackify$1 = callbackify;

const zlibOptions = {
  flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
  finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
};

const isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = followRedirects__default["default"];

const isHttps = /https:?/;

const supportedProtocols = platform.protocols.map(protocol => {
  return protocol + ':';
});

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && utils$1.kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!utils$1.isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
};

const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
const httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = utils$1.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new EventEmitter__default["default"]();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    };

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, 'http://localhost');
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return settle(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = fromDataURI(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = utils$1.stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream__default["default"].Readable.from(convertedData);
      }

      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new AxiosHeaders$1(),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError(
        'Unsupported protocol ' + protocol,
        AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = AxiosHeaders$1.from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + VERSION, false);

    const onDownloadProgress = config.onDownloadProgress;
    const onUploadProgress = config.onUploadProgress;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (utils$1.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = formDataToStream$1(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util__default["default"].promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (utils$1.isBlob(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream__default["default"].Readable.from(readBlob$1(data));
    } else if (data && !utils$1.isStream(data)) {
      if (Buffer.isBuffer(data)) ; else if (utils$1.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$1.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new AxiosError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError(
          'Request body larger than maxBodyLength limit',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());

    if (utils$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$1.isStream(data)) {
        data = stream__default["default"].Readable.from(data, {objectMode: false});
      }

      data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
        length: contentLength,
        maxRate: utils$1.toFiniteNumber(maxUploadRate)
      })], utils$1.noop);

      onUploadProgress && data.on('progress', progress => {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !utils$1.isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https__default["default"] : http__default["default"];
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress) {
        const transformStream = new AxiosTransformStream$1({
          length: utils$1.toFiniteNumber(responseLength),
          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', progress => {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__default["default"].createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new ZlibHeaderTransformStream$1());

          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__default["default"].createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];

      const offListeners = stream__default["default"].finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new AxiosError(
            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
            AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = utils$1.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(AxiosError.from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new AxiosError(
          'error trying to parse `config.timeout` to int',
          AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (utils$1.isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new CanceledError('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

const cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$1.isString(path) && cookie.push('path=' + path);

      utils$1.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

const isURLSameOrigin = platform.hasStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

const xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    let {responseType, withXSRFToken} = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    let contentType;

    if (utils$1.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false); // Let the browser set it
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        // fix semicolon duplication issue for ReactNative FormData implementation
        const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
      }
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if(platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));

      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {
        // Add xsrf header
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};

utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

const adapters = {
  getAdapter: (adapters) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({caseless}, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

const validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;

        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';

        if (!err.stack) {
          err.stack = stack;
          // match without the 2 top stack lines
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
          err.stack += '\n' + stack;
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$1.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

const Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

const CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$1.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

const HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$1.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

module.exports = axios;
//# sourceMappingURL=axios.cjs.map


/***/ }),

/***/ 94646:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-iam","description":"AWS SDK for JavaScript Iam Client for Node.js, Browser and React Native","version":"3.382.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo iam"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/client-sts":"3.382.0","@aws-sdk/credential-provider-node":"3.382.0","@aws-sdk/middleware-host-header":"3.379.1","@aws-sdk/middleware-logger":"3.378.0","@aws-sdk/middleware-recursion-detection":"3.378.0","@aws-sdk/middleware-signing":"3.379.1","@aws-sdk/middleware-user-agent":"3.382.0","@aws-sdk/types":"3.378.0","@aws-sdk/util-endpoints":"3.382.0","@aws-sdk/util-user-agent-browser":"3.378.0","@aws-sdk/util-user-agent-node":"3.378.0","@smithy/config-resolver":"^2.0.1","@smithy/fetch-http-handler":"^2.0.1","@smithy/hash-node":"^2.0.1","@smithy/invalid-dependency":"^2.0.1","@smithy/middleware-content-length":"^2.0.1","@smithy/middleware-endpoint":"^2.0.1","@smithy/middleware-retry":"^2.0.1","@smithy/middleware-serde":"^2.0.1","@smithy/middleware-stack":"^2.0.0","@smithy/node-config-provider":"^2.0.1","@smithy/node-http-handler":"^2.0.1","@smithy/protocol-http":"^2.0.1","@smithy/smithy-client":"^2.0.1","@smithy/types":"^2.0.2","@smithy/url-parser":"^2.0.1","@smithy/util-base64":"^2.0.0","@smithy/util-body-length-browser":"^2.0.0","@smithy/util-body-length-node":"^2.0.0","@smithy/util-defaults-mode-browser":"^2.0.1","@smithy/util-defaults-mode-node":"^2.0.1","@smithy/util-retry":"^2.0.0","@smithy/util-utf8":"^2.0.0","@smithy/util-waiter":"^2.0.1","fast-xml-parser":"4.2.5","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.23.23","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-iam","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-iam"}}');

/***/ }),

/***/ 61984:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-securityhub","description":"AWS SDK for JavaScript Securityhub Client for Node.js, Browser and React Native","version":"3.382.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo securityhub"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/client-sts":"3.382.0","@aws-sdk/credential-provider-node":"3.382.0","@aws-sdk/middleware-host-header":"3.379.1","@aws-sdk/middleware-logger":"3.378.0","@aws-sdk/middleware-recursion-detection":"3.378.0","@aws-sdk/middleware-signing":"3.379.1","@aws-sdk/middleware-user-agent":"3.382.0","@aws-sdk/types":"3.378.0","@aws-sdk/util-endpoints":"3.382.0","@aws-sdk/util-user-agent-browser":"3.378.0","@aws-sdk/util-user-agent-node":"3.378.0","@smithy/config-resolver":"^2.0.1","@smithy/fetch-http-handler":"^2.0.1","@smithy/hash-node":"^2.0.1","@smithy/invalid-dependency":"^2.0.1","@smithy/middleware-content-length":"^2.0.1","@smithy/middleware-endpoint":"^2.0.1","@smithy/middleware-retry":"^2.0.1","@smithy/middleware-serde":"^2.0.1","@smithy/middleware-stack":"^2.0.0","@smithy/node-config-provider":"^2.0.1","@smithy/node-http-handler":"^2.0.1","@smithy/protocol-http":"^2.0.1","@smithy/smithy-client":"^2.0.1","@smithy/types":"^2.0.2","@smithy/url-parser":"^2.0.1","@smithy/util-base64":"^2.0.0","@smithy/util-body-length-browser":"^2.0.0","@smithy/util-body-length-node":"^2.0.0","@smithy/util-defaults-mode-browser":"^2.0.1","@smithy/util-defaults-mode-node":"^2.0.1","@smithy/util-retry":"^2.0.0","@smithy/util-utf8":"^2.0.0","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.23.23","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-securityhub","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-securityhub"}}');

/***/ }),

/***/ 69722:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sso-oidc","description":"AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native","version":"3.382.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo sso-oidc"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/middleware-host-header":"3.379.1","@aws-sdk/middleware-logger":"3.378.0","@aws-sdk/middleware-recursion-detection":"3.378.0","@aws-sdk/middleware-user-agent":"3.382.0","@aws-sdk/types":"3.378.0","@aws-sdk/util-endpoints":"3.382.0","@aws-sdk/util-user-agent-browser":"3.378.0","@aws-sdk/util-user-agent-node":"3.378.0","@smithy/config-resolver":"^2.0.1","@smithy/fetch-http-handler":"^2.0.1","@smithy/hash-node":"^2.0.1","@smithy/invalid-dependency":"^2.0.1","@smithy/middleware-content-length":"^2.0.1","@smithy/middleware-endpoint":"^2.0.1","@smithy/middleware-retry":"^2.0.1","@smithy/middleware-serde":"^2.0.1","@smithy/middleware-stack":"^2.0.0","@smithy/node-config-provider":"^2.0.1","@smithy/node-http-handler":"^2.0.1","@smithy/protocol-http":"^2.0.1","@smithy/smithy-client":"^2.0.1","@smithy/types":"^2.0.2","@smithy/url-parser":"^2.0.1","@smithy/util-base64":"^2.0.0","@smithy/util-body-length-browser":"^2.0.0","@smithy/util-body-length-node":"^2.0.0","@smithy/util-defaults-mode-browser":"^2.0.1","@smithy/util-defaults-mode-node":"^2.0.1","@smithy/util-retry":"^2.0.0","@smithy/util-utf8":"^2.0.0","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.23.23","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sso-oidc"}}');

/***/ }),

/***/ 91092:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sso","description":"AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native","version":"3.382.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo sso"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/middleware-host-header":"3.379.1","@aws-sdk/middleware-logger":"3.378.0","@aws-sdk/middleware-recursion-detection":"3.378.0","@aws-sdk/middleware-user-agent":"3.382.0","@aws-sdk/types":"3.378.0","@aws-sdk/util-endpoints":"3.382.0","@aws-sdk/util-user-agent-browser":"3.378.0","@aws-sdk/util-user-agent-node":"3.378.0","@smithy/config-resolver":"^2.0.1","@smithy/fetch-http-handler":"^2.0.1","@smithy/hash-node":"^2.0.1","@smithy/invalid-dependency":"^2.0.1","@smithy/middleware-content-length":"^2.0.1","@smithy/middleware-endpoint":"^2.0.1","@smithy/middleware-retry":"^2.0.1","@smithy/middleware-serde":"^2.0.1","@smithy/middleware-stack":"^2.0.0","@smithy/node-config-provider":"^2.0.1","@smithy/node-http-handler":"^2.0.1","@smithy/protocol-http":"^2.0.1","@smithy/smithy-client":"^2.0.1","@smithy/types":"^2.0.2","@smithy/url-parser":"^2.0.1","@smithy/util-base64":"^2.0.0","@smithy/util-body-length-browser":"^2.0.0","@smithy/util-body-length-node":"^2.0.0","@smithy/util-defaults-mode-browser":"^2.0.1","@smithy/util-defaults-mode-node":"^2.0.1","@smithy/util-retry":"^2.0.0","@smithy/util-utf8":"^2.0.0","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.23.23","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sso"}}');

/***/ }),

/***/ 7947:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sts","description":"AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native","version":"3.382.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo sts","test":"yarn test:unit","test:unit":"jest"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/credential-provider-node":"3.382.0","@aws-sdk/middleware-host-header":"3.379.1","@aws-sdk/middleware-logger":"3.378.0","@aws-sdk/middleware-recursion-detection":"3.378.0","@aws-sdk/middleware-sdk-sts":"3.379.1","@aws-sdk/middleware-signing":"3.379.1","@aws-sdk/middleware-user-agent":"3.382.0","@aws-sdk/types":"3.378.0","@aws-sdk/util-endpoints":"3.382.0","@aws-sdk/util-user-agent-browser":"3.378.0","@aws-sdk/util-user-agent-node":"3.378.0","@smithy/config-resolver":"^2.0.1","@smithy/fetch-http-handler":"^2.0.1","@smithy/hash-node":"^2.0.1","@smithy/invalid-dependency":"^2.0.1","@smithy/middleware-content-length":"^2.0.1","@smithy/middleware-endpoint":"^2.0.1","@smithy/middleware-retry":"^2.0.1","@smithy/middleware-serde":"^2.0.1","@smithy/middleware-stack":"^2.0.0","@smithy/node-config-provider":"^2.0.1","@smithy/node-http-handler":"^2.0.1","@smithy/protocol-http":"^2.0.1","@smithy/smithy-client":"^2.0.1","@smithy/types":"^2.0.2","@smithy/url-parser":"^2.0.1","@smithy/util-base64":"^2.0.0","@smithy/util-body-length-browser":"^2.0.0","@smithy/util-body-length-node":"^2.0.0","@smithy/util-defaults-mode-browser":"^2.0.1","@smithy/util-defaults-mode-node":"^2.0.1","@smithy/util-retry":"^2.0.0","@smithy/util-utf8":"^2.0.0","fast-xml-parser":"4.2.5","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.23.23","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sts"}}');

/***/ }),

/***/ 95367:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"partitions":[{"id":"aws","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","name":"aws","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^(us|eu|ap|sa|ca|me|af|il)\\\\-\\\\w+\\\\-\\\\d+$","regions":{"af-south-1":{"description":"Africa (Cape Town)"},"ap-east-1":{"description":"Asia Pacific (Hong Kong)"},"ap-northeast-1":{"description":"Asia Pacific (Tokyo)"},"ap-northeast-2":{"description":"Asia Pacific (Seoul)"},"ap-northeast-3":{"description":"Asia Pacific (Osaka)"},"ap-south-1":{"description":"Asia Pacific (Mumbai)"},"ap-south-2":{"description":"Asia Pacific (Hyderabad)"},"ap-southeast-1":{"description":"Asia Pacific (Singapore)"},"ap-southeast-2":{"description":"Asia Pacific (Sydney)"},"ap-southeast-3":{"description":"Asia Pacific (Jakarta)"},"ap-southeast-4":{"description":"Asia Pacific (Melbourne)"},"aws-global":{"description":"AWS Standard global region"},"ca-central-1":{"description":"Canada (Central)"},"eu-central-1":{"description":"Europe (Frankfurt)"},"eu-central-2":{"description":"Europe (Zurich)"},"eu-north-1":{"description":"Europe (Stockholm)"},"eu-south-1":{"description":"Europe (Milan)"},"eu-south-2":{"description":"Europe (Spain)"},"eu-west-1":{"description":"Europe (Ireland)"},"eu-west-2":{"description":"Europe (London)"},"eu-west-3":{"description":"Europe (Paris)"},"me-central-1":{"description":"Middle East (UAE)"},"me-south-1":{"description":"Middle East (Bahrain)"},"sa-east-1":{"description":"South America (Sao Paulo)"},"us-east-1":{"description":"US East (N. Virginia)"},"us-east-2":{"description":"US East (Ohio)"},"us-west-1":{"description":"US West (N. California)"},"us-west-2":{"description":"US West (Oregon)"}}},{"id":"aws-cn","outputs":{"dnsSuffix":"amazonaws.com.cn","dualStackDnsSuffix":"api.amazonwebservices.com.cn","name":"aws-cn","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^cn\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-cn-global":{"description":"AWS China global region"},"cn-north-1":{"description":"China (Beijing)"},"cn-northwest-1":{"description":"China (Ningxia)"}}},{"id":"aws-us-gov","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","name":"aws-us-gov","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-us-gov-global":{"description":"AWS GovCloud (US) global region"},"us-gov-east-1":{"description":"AWS GovCloud (US-East)"},"us-gov-west-1":{"description":"AWS GovCloud (US-West)"}}},{"id":"aws-iso","outputs":{"dnsSuffix":"c2s.ic.gov","dualStackDnsSuffix":"c2s.ic.gov","name":"aws-iso","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-global":{"description":"AWS ISO (US) global region"},"us-iso-east-1":{"description":"US ISO East"},"us-iso-west-1":{"description":"US ISO WEST"}}},{"id":"aws-iso-b","outputs":{"dnsSuffix":"sc2s.sgov.gov","dualStackDnsSuffix":"sc2s.sgov.gov","name":"aws-iso-b","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-b-global":{"description":"AWS ISOB (US) global region"},"us-isob-east-1":{"description":"US ISOB East (Ohio)"}}},{"id":"aws-iso-e","outputs":{"dnsSuffix":"cloud.adc-e.uk","dualStackDnsSuffix":"cloud.adc-e.uk","name":"aws-iso-e","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^eu\\\\-isoe\\\\-\\\\w+\\\\-\\\\d+$","regions":{}},{"id":"aws-iso-f","outputs":{"dnsSuffix":"csp.hci.ic.gov","dualStackDnsSuffix":"csp.hci.ic.gov","name":"aws-iso-f","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isof\\\\-\\\\w+\\\\-\\\\d+$","regions":{}}],"version":"1.1"}');

/***/ }),

/***/ 49968:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"dotenv","version":"16.3.1","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","lint-readme":"standard-markdown","pretest":"npm run lint && npm run dts-check","test":"tap tests/*.js --100 -Rspec","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"funding":"https://github.com/motdotla/dotenv?sponsor=1","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@definitelytyped/dtslint":"^0.0.133","@types/node":"^18.11.3","decache":"^4.6.1","sinon":"^14.0.1","standard":"^17.0.0","standard-markdown":"^7.1.0","standard-version":"^9.5.0","tap":"^16.3.0","tar":"^6.1.11","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ }),

/***/ 53765:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(6144);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;